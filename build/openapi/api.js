"use strict";
// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Payment Gateway API Specification.
 * The documentation here is designed to provide all of the technical guidance required to consume and integrate with our APIs for payment processing. To learn more about our APIs please visit https://docs.firstdata.com/org/gateway.
 *
 * The version of the OpenAPI document: 6.14.0.20201015.001
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var globalImportUrl = require("url");
var axios_1 = require("axios");
var base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var AVSResponseStreetMatchEnum;
(function (AVSResponseStreetMatchEnum) {
    AVSResponseStreetMatchEnum["Y"] = "Y";
    AVSResponseStreetMatchEnum["N"] = "N";
    AVSResponseStreetMatchEnum["NOINPUTDATA"] = "NO_INPUT_DATA";
    AVSResponseStreetMatchEnum["NOTCHECKED"] = "NOT_CHECKED";
})(AVSResponseStreetMatchEnum = exports.AVSResponseStreetMatchEnum || (exports.AVSResponseStreetMatchEnum = {}));
/**
    * @export
    * @enum {string}
    */
var AVSResponsePostalCodeMatchEnum;
(function (AVSResponsePostalCodeMatchEnum) {
    AVSResponsePostalCodeMatchEnum["Y"] = "Y";
    AVSResponsePostalCodeMatchEnum["N"] = "N";
    AVSResponsePostalCodeMatchEnum["NOINPUTDATA"] = "NO_INPUT_DATA";
    AVSResponsePostalCodeMatchEnum["NOTCHECKED"] = "NOT_CHECKED";
})(AVSResponsePostalCodeMatchEnum = exports.AVSResponsePostalCodeMatchEnum || (exports.AVSResponsePostalCodeMatchEnum = {}));
/**
 * Identifies if the transaction is single or recurring for ACH transaction which is a optional field for Application Type ICA.
 * @export
 * @enum {string}
 */
var AchRecurringType;
(function (AchRecurringType) {
    AchRecurringType["Single"] = "Single";
    AchRecurringType["Recurring"] = "Recurring";
})(AchRecurringType = exports.AchRecurringType || (exports.AchRecurringType = {}));
/**
    * @export
    * @enum {string}
    */
var AdditionalDetailsScaExemptionTypeEnum;
(function (AdditionalDetailsScaExemptionTypeEnum) {
    AdditionalDetailsScaExemptionTypeEnum["LowValueExemption"] = "Low Value Exemption";
    AdditionalDetailsScaExemptionTypeEnum["TRAExemption"] = "TRA Exemption";
    AdditionalDetailsScaExemptionTypeEnum["TrustedMerchantExemption"] = "Trusted Merchant Exemption";
    AdditionalDetailsScaExemptionTypeEnum["SCPExemption"] = "SCP Exemption";
    AdditionalDetailsScaExemptionTypeEnum["DelegatedAuthentication"] = "Delegated Authentication";
})(AdditionalDetailsScaExemptionTypeEnum = exports.AdditionalDetailsScaExemptionTypeEnum || (exports.AdditionalDetailsScaExemptionTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var AdditionalTransactionDetailsDisbursementTransTypeEnum;
(function (AdditionalTransactionDetailsDisbursementTransTypeEnum) {
    AdditionalTransactionDetailsDisbursementTransTypeEnum["FUNDING"] = "FUNDING";
    AdditionalTransactionDetailsDisbursementTransTypeEnum["DISBURSEMENT"] = "DISBURSEMENT";
})(AdditionalTransactionDetailsDisbursementTransTypeEnum = exports.AdditionalTransactionDetailsDisbursementTransTypeEnum || (exports.AdditionalTransactionDetailsDisbursementTransTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var AdditionalTransactionDetailsWalletProviderEnum;
(function (AdditionalTransactionDetailsWalletProviderEnum) {
    AdditionalTransactionDetailsWalletProviderEnum["GOOGLEPAY"] = "GOOGLE_PAY";
    AdditionalTransactionDetailsWalletProviderEnum["APPLEPAY"] = "APPLE_PAY";
    AdditionalTransactionDetailsWalletProviderEnum["SAMSUNGPAY"] = "SAMSUNG_PAY";
    AdditionalTransactionDetailsWalletProviderEnum["MASTERPASS"] = "MASTERPASS";
})(AdditionalTransactionDetailsWalletProviderEnum = exports.AdditionalTransactionDetailsWalletProviderEnum || (exports.AdditionalTransactionDetailsWalletProviderEnum = {}));
/**
    * @export
    * @enum {string}
    */
var AirlineReservationSystemEnum;
(function (AirlineReservationSystemEnum) {
    AirlineReservationSystemEnum["START"] = "START";
    AirlineReservationSystemEnum["TWA"] = "TWA";
    AirlineReservationSystemEnum["DELTA"] = "DELTA";
    AirlineReservationSystemEnum["SABRE"] = "SABRE";
    AirlineReservationSystemEnum["COVIAAPOLLO"] = "COVIA_APOLLO";
    AirlineReservationSystemEnum["DRBLANK"] = "DR_BLANK";
    AirlineReservationSystemEnum["DER"] = "DER";
    AirlineReservationSystemEnum["TUI"] = "TUI";
})(AirlineReservationSystemEnum = exports.AirlineReservationSystemEnum || (exports.AirlineReservationSystemEnum = {}));
/**
    * @export
    * @enum {string}
    */
var AirlineAncillaryServiceCategoryServiceCategoryEnum;
(function (AirlineAncillaryServiceCategoryServiceCategoryEnum) {
    AirlineAncillaryServiceCategoryServiceCategoryEnum["BUNDLEDSERVICE"] = "BUNDLED_SERVICE";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["BAGGAGEFEE"] = "BAGGAGE_FEE";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["CHANGEFEE"] = "CHANGE_FEE";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["CARGO"] = "CARGO";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["CARBONOFFSET"] = "CARBON_OFFSET";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["FREQUENTFLYER"] = "FREQUENT_FLYER";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["GIFTCARD"] = "GIFT_CARD";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["GROUNDTRANSPORT"] = "GROUND_TRANSPORT";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["INFLIGHTENTERTAINMENT"] = "IN_FLIGHT_ENTERTAINMENT";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["LOUNGE"] = "LOUNGE";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["MEDICAL"] = "MEDICAL";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["MEALBEVERAGE"] = "MEAL_BEVERAGE";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["OTHER"] = "OTHER";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["PASSENGERASSISTFEE"] = "PASSENGER_ASSIST_FEE";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["PETS"] = "PETS";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["SEATFEES"] = "SEAT_FEES";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["STANDBY"] = "STANDBY";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["SERVICEFEE"] = "SERVICE_FEE";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["STORE"] = "STORE";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["TRAVELSERVICE"] = "TRAVEL_SERVICE";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["UNACCOMPANIEDTRAVEL"] = "UNACCOMPANIED_TRAVEL";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["UPGRADES"] = "UPGRADES";
    AirlineAncillaryServiceCategoryServiceCategoryEnum["WIFI"] = "WI_FI";
})(AirlineAncillaryServiceCategoryServiceCategoryEnum = exports.AirlineAncillaryServiceCategoryServiceCategoryEnum || (exports.AirlineAncillaryServiceCategoryServiceCategoryEnum = {}));
/**
    * @export
    * @enum {string}
    */
var AirlineTravelRouteStopoverTypeEnum;
(function (AirlineTravelRouteStopoverTypeEnum) {
    AirlineTravelRouteStopoverTypeEnum["DIRECT"] = "DIRECT";
    AirlineTravelRouteStopoverTypeEnum["STOPOVER"] = "STOPOVER";
})(AirlineTravelRouteStopoverTypeEnum = exports.AirlineTravelRouteStopoverTypeEnum || (exports.AirlineTravelRouteStopoverTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var AliPayPaymentDataTypeEnum;
(function (AliPayPaymentDataTypeEnum) {
    AliPayPaymentDataTypeEnum["BARCODE"] = "BARCODE";
    AliPayPaymentDataTypeEnum["QRCODE"] = "QRCODE";
})(AliPayPaymentDataTypeEnum = exports.AliPayPaymentDataTypeEnum || (exports.AliPayPaymentDataTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var BancontactQRTransactionRoutingMeansEnum;
(function (BancontactQRTransactionRoutingMeansEnum) {
    BancontactQRTransactionRoutingMeansEnum["QRCode"] = "QR Code";
    BancontactQRTransactionRoutingMeansEnum["URLIntent"] = "URL Intent";
})(BancontactQRTransactionRoutingMeansEnum = exports.BancontactQRTransactionRoutingMeansEnum || (exports.BancontactQRTransactionRoutingMeansEnum = {}));
/**
    * @export
    * @enum {string}
    */
var CarRentalExtraChargesChargeItemEnum;
(function (CarRentalExtraChargesChargeItemEnum) {
    CarRentalExtraChargesChargeItemEnum["EXTRAMILEAGE"] = "EXTRA_MILEAGE";
    CarRentalExtraChargesChargeItemEnum["GAS"] = "GAS";
    CarRentalExtraChargesChargeItemEnum["LATERETURN"] = "LATE_RETURN";
    CarRentalExtraChargesChargeItemEnum["ONEWAYSERVICEFEE"] = "ONE_WAY_SERVICE_FEE";
    CarRentalExtraChargesChargeItemEnum["PARKINGVIOLATION"] = "PARKING_VIOLATION";
})(CarRentalExtraChargesChargeItemEnum = exports.CarRentalExtraChargesChargeItemEnum || (exports.CarRentalExtraChargesChargeItemEnum = {}));
/**
 * Card function. This field is required when performing transactions for Brazil merchants.
 * @export
 * @enum {string}
 */
var CardFunction;
(function (CardFunction) {
    CardFunction["CREDIT"] = "CREDIT";
    CardFunction["DEBIT"] = "DEBIT";
    CardFunction["PREPAID"] = "PREPAID";
    CardFunction["VOUCHER"] = "VOUCHER";
    CardFunction["UNDEFINED"] = "UNDEFINED";
})(CardFunction = exports.CardFunction || (exports.CardFunction = {}));
/**
    * @export
    * @enum {string}
    */
var CardInfoCommercialCardEnum;
(function (CardInfoCommercialCardEnum) {
    CardInfoCommercialCardEnum["CORPORATE"] = "CORPORATE";
    CardInfoCommercialCardEnum["NONCORPORATE"] = "NON_CORPORATE";
})(CardInfoCommercialCardEnum = exports.CardInfoCommercialCardEnum || (exports.CardInfoCommercialCardEnum = {}));
/**
    * @export
    * @enum {string}
    */
var CardInfoLookupResponseRequestStatusEnum;
(function (CardInfoLookupResponseRequestStatusEnum) {
    CardInfoLookupResponseRequestStatusEnum["SUCCESS"] = "SUCCESS";
    CardInfoLookupResponseRequestStatusEnum["LISTEMPTY"] = "LIST_EMPTY";
})(CardInfoLookupResponseRequestStatusEnum = exports.CardInfoLookupResponseRequestStatusEnum || (exports.CardInfoLookupResponseRequestStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ChinaDomesticPaymentMethodBrandEnum;
(function (ChinaDomesticPaymentMethodBrandEnum) {
    ChinaDomesticPaymentMethodBrandEnum["ALIPAYDOMESTIC"] = "ALIPAY_DOMESTIC";
    ChinaDomesticPaymentMethodBrandEnum["CUPDOMESTIC"] = "CUP_DOMESTIC";
    ChinaDomesticPaymentMethodBrandEnum["WECHATDOMESTIC"] = "WECHAT_DOMESTIC";
})(ChinaDomesticPaymentMethodBrandEnum = exports.ChinaDomesticPaymentMethodBrandEnum || (exports.ChinaDomesticPaymentMethodBrandEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ChinaDomesticPaymentMethodAllOfBrandEnum;
(function (ChinaDomesticPaymentMethodAllOfBrandEnum) {
    ChinaDomesticPaymentMethodAllOfBrandEnum["ALIPAYDOMESTIC"] = "ALIPAY_DOMESTIC";
    ChinaDomesticPaymentMethodAllOfBrandEnum["CUPDOMESTIC"] = "CUP_DOMESTIC";
    ChinaDomesticPaymentMethodAllOfBrandEnum["WECHATDOMESTIC"] = "WECHAT_DOMESTIC";
})(ChinaDomesticPaymentMethodAllOfBrandEnum = exports.ChinaDomesticPaymentMethodAllOfBrandEnum || (exports.ChinaDomesticPaymentMethodAllOfBrandEnum = {}));
/**
 * The type of connect mode.
 * @export
 * @enum {string}
 */
var ConnectMode;
(function (ConnectMode) {
    ConnectMode["Classic"] = "Classic";
    ConnectMode["Combined"] = "Combined";
})(ConnectMode = exports.ConnectMode || (exports.ConnectMode = {}));
/**
    * @export
    * @enum {string}
    */
var CustomerGenderEnum;
(function (CustomerGenderEnum) {
    CustomerGenderEnum["Male"] = "male";
    CustomerGenderEnum["Female"] = "female";
    CustomerGenderEnum["Other"] = "other";
})(CustomerGenderEnum = exports.CustomerGenderEnum || (exports.CustomerGenderEnum = {}));
/**
    * @export
    * @enum {string}
    */
var DeviceDeviceTypeEnum;
(function (DeviceDeviceTypeEnum) {
    DeviceDeviceTypeEnum["Pos"] = "device/pos";
    DeviceDeviceTypeEnum["Mobile"] = "device/mobile";
})(DeviceDeviceTypeEnum = exports.DeviceDeviceTypeEnum || (exports.DeviceDeviceTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var DocumentTypeEnum;
(function (DocumentTypeEnum) {
    DocumentTypeEnum["NATIONALIDENTITY"] = "NATIONAL_IDENTITY";
    DocumentTypeEnum["SINGLETAXIDENTIFICATION"] = "SINGLE_TAX_IDENTIFICATION";
    DocumentTypeEnum["SINGLECODEOFLABORIDENTIFICATION"] = "SINGLE_CODE_OF_LABOR_IDENTIFICATION";
    DocumentTypeEnum["BOOKENLISTMENT"] = "BOOK_ENLISTMENT";
    DocumentTypeEnum["CIVICNOTEBOOK"] = "CIVIC_NOTEBOOK";
    DocumentTypeEnum["PASSPORT"] = "PASSPORT";
})(DocumentTypeEnum = exports.DocumentTypeEnum || (exports.DocumentTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var EncryptedApplePayVersionEnum;
(function (EncryptedApplePayVersionEnum) {
    EncryptedApplePayVersionEnum["ECV1"] = "EC_v1";
})(EncryptedApplePayVersionEnum = exports.EncryptedApplePayVersionEnum || (exports.EncryptedApplePayVersionEnum = {}));
/**
    * @export
    * @enum {string}
    */
var EndpointResponseStatusEnum;
(function (EndpointResponseStatusEnum) {
    EndpointResponseStatusEnum["APPROVED"] = "APPROVED";
    EndpointResponseStatusEnum["DECLINED"] = "DECLINED";
    EndpointResponseStatusEnum["FAILED"] = "FAILED";
})(EndpointResponseStatusEnum = exports.EndpointResponseStatusEnum || (exports.EndpointResponseStatusEnum = {}));
/**
 * Font face property.
 * @export
 * @enum {string}
 */
var FontFace;
(function (FontFace) {
    FontFace["Arial"] = "arial";
    FontFace["CourierNew"] = "courier new";
    FontFace["TimesNewRoman"] = "times new roman";
    FontFace["TrebuchetMs"] = "trebuchet ms";
    FontFace["Verdana"] = "verdana";
})(FontFace = exports.FontFace || (exports.FontFace = {}));
/**
 * Font weight property.
 * @export
 * @enum {string}
 */
var FontWeight;
(function (FontWeight) {
    FontWeight["Normal"] = "normal";
    FontWeight["Bold"] = "bold";
})(FontWeight = exports.FontWeight || (exports.FontWeight = {}));
/**
    * @export
    * @enum {string}
    */
var FraudRegistrationDeviceDeviceTypeEnum;
(function (FraudRegistrationDeviceDeviceTypeEnum) {
    FraudRegistrationDeviceDeviceTypeEnum["Pos"] = "device/pos";
    FraudRegistrationDeviceDeviceTypeEnum["Mobile"] = "device/mobile";
})(FraudRegistrationDeviceDeviceTypeEnum = exports.FraudRegistrationDeviceDeviceTypeEnum || (exports.FraudRegistrationDeviceDeviceTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var FraudRegistrationDeviceItemsNetworkTypeEnum;
(function (FraudRegistrationDeviceItemsNetworkTypeEnum) {
    FraudRegistrationDeviceItemsNetworkTypeEnum["Mobile"] = "network/mobile";
    FraudRegistrationDeviceItemsNetworkTypeEnum["Wifi"] = "network/wifi";
})(FraudRegistrationDeviceItemsNetworkTypeEnum = exports.FraudRegistrationDeviceItemsNetworkTypeEnum || (exports.FraudRegistrationDeviceItemsNetworkTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var FraudRegistrationResponseTransactionStatusEnum;
(function (FraudRegistrationResponseTransactionStatusEnum) {
    FraudRegistrationResponseTransactionStatusEnum["ScoredSuccessfully"] = "Scored Successfully";
    FraudRegistrationResponseTransactionStatusEnum["NotProcessed"] = "Not Processed";
})(FraudRegistrationResponseTransactionStatusEnum = exports.FraudRegistrationResponseTransactionStatusEnum || (exports.FraudRegistrationResponseTransactionStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var FrequencyUnitEnum;
(function (FrequencyUnitEnum) {
    FrequencyUnitEnum["DAY"] = "DAY";
    FrequencyUnitEnum["WEEK"] = "WEEK";
    FrequencyUnitEnum["MONTH"] = "MONTH";
    FrequencyUnitEnum["YEAR"] = "YEAR";
})(FrequencyUnitEnum = exports.FrequencyUnitEnum || (exports.FrequencyUnitEnum = {}));
/**
    * @export
    * @enum {string}
    */
var InitiateClearingResponseRequestStatusEnum;
(function (InitiateClearingResponseRequestStatusEnum) {
    InitiateClearingResponseRequestStatusEnum["SUCCESS"] = "SUCCESS";
    InitiateClearingResponseRequestStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
    InitiateClearingResponseRequestStatusEnum["FAILURE"] = "FAILURE";
})(InitiateClearingResponseRequestStatusEnum = exports.InitiateClearingResponseRequestStatusEnum || (exports.InitiateClearingResponseRequestStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var InitiateClearingResponseAllOfRequestStatusEnum;
(function (InitiateClearingResponseAllOfRequestStatusEnum) {
    InitiateClearingResponseAllOfRequestStatusEnum["SUCCESS"] = "SUCCESS";
    InitiateClearingResponseAllOfRequestStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
    InitiateClearingResponseAllOfRequestStatusEnum["FAILURE"] = "FAILURE";
})(InitiateClearingResponseAllOfRequestStatusEnum = exports.InitiateClearingResponseAllOfRequestStatusEnum || (exports.InitiateClearingResponseAllOfRequestStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var InstallmentOptionsRecurringTypeEnum;
(function (InstallmentOptionsRecurringTypeEnum) {
    InstallmentOptionsRecurringTypeEnum["FIRST"] = "FIRST";
    InstallmentOptionsRecurringTypeEnum["REPEAT"] = "REPEAT";
    InstallmentOptionsRecurringTypeEnum["STANDINGINSTRUCTION"] = "STANDING_INSTRUCTION";
})(InstallmentOptionsRecurringTypeEnum = exports.InstallmentOptionsRecurringTypeEnum || (exports.InstallmentOptionsRecurringTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var IssuerResponseStatusEnum;
(function (IssuerResponseStatusEnum) {
    IssuerResponseStatusEnum["Approved"] = "approved";
    IssuerResponseStatusEnum["Declined"] = "declined";
    IssuerResponseStatusEnum["Disabled"] = "disabled";
    IssuerResponseStatusEnum["Unknown"] = "unknown";
})(IssuerResponseStatusEnum = exports.IssuerResponseStatusEnum || (exports.IssuerResponseStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ItemsNetworkTypeEnum;
(function (ItemsNetworkTypeEnum) {
    ItemsNetworkTypeEnum["Mobile"] = "network/mobile";
    ItemsNetworkTypeEnum["Wifi"] = "network/wifi";
})(ItemsNetworkTypeEnum = exports.ItemsNetworkTypeEnum || (exports.ItemsNetworkTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var LodgingExtraChargesChargeItemEnum;
(function (LodgingExtraChargesChargeItemEnum) {
    LodgingExtraChargesChargeItemEnum["GIFTSHOP"] = "GIFT_SHOP";
    LodgingExtraChargesChargeItemEnum["LAUNDRY"] = "LAUNDRY";
    LodgingExtraChargesChargeItemEnum["MINIBAR"] = "MINI_BAR";
    LodgingExtraChargesChargeItemEnum["RESTAURANT"] = "RESTAURANT";
    LodgingExtraChargesChargeItemEnum["TELEPHONE"] = "TELEPHONE";
    LodgingExtraChargesChargeItemEnum["OTHER"] = "OTHER";
})(LodgingExtraChargesChargeItemEnum = exports.LodgingExtraChargesChargeItemEnum || (exports.LodgingExtraChargesChargeItemEnum = {}));
/**
    * @export
    * @enum {string}
    */
var LogoPositionEnum;
(function (LogoPositionEnum) {
    LogoPositionEnum["TOP"] = "TOP";
    LogoPositionEnum["BOTTOM"] = "BOTTOM";
})(LogoPositionEnum = exports.LogoPositionEnum || (exports.LogoPositionEnum = {}));
/**
    * @export
    * @enum {string}
    */
var MethodMethodTypeEnum;
(function (MethodMethodTypeEnum) {
    MethodMethodTypeEnum["Card"] = "method/card";
    MethodMethodTypeEnum["Wallet"] = "method/wallet";
})(MethodMethodTypeEnum = exports.MethodMethodTypeEnum || (exports.MethodMethodTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PaymentPaymentTypeEnum;
(function (PaymentPaymentTypeEnum) {
    PaymentPaymentTypeEnum["Card"] = "payment/card";
    PaymentPaymentTypeEnum["Wallet"] = "payment/wallet";
})(PaymentPaymentTypeEnum = exports.PaymentPaymentTypeEnum || (exports.PaymentPaymentTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PaymentEntryMethodEnum;
(function (PaymentEntryMethodEnum) {
    PaymentEntryMethodEnum["Manual"] = "manual";
    PaymentEntryMethodEnum["Stripe"] = "stripe";
    PaymentEntryMethodEnum["Ocr"] = "ocr";
    PaymentEntryMethodEnum["Emv"] = "emv";
    PaymentEntryMethodEnum["Nfc"] = "nfc";
    PaymentEntryMethodEnum["Remote"] = "remote";
    PaymentEntryMethodEnum["PinPresent"] = "pin_present";
})(PaymentEntryMethodEnum = exports.PaymentEntryMethodEnum || (exports.PaymentEntryMethodEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PaymentDeviceDeviceTypeEnum;
(function (PaymentDeviceDeviceTypeEnum) {
    PaymentDeviceDeviceTypeEnum["SWIPE"] = "SWIPE";
})(PaymentDeviceDeviceTypeEnum = exports.PaymentDeviceDeviceTypeEnum || (exports.PaymentDeviceDeviceTypeEnum = {}));
/**
 * Type of payment method.
 * @export
 * @enum {string}
 */
var PaymentMethodType;
(function (PaymentMethodType) {
    PaymentMethodType["ALIPAY"] = "ALIPAY";
    PaymentMethodType["ALIPAYPAYSECUREUS"] = "ALIPAY_PAYSECURE_US";
    PaymentMethodType["ALIPAYDOMESTIC"] = "ALIPAY_DOMESTIC";
    PaymentMethodType["APM"] = "APM";
    PaymentMethodType["CUPDOMESTIC"] = "CUP_DOMESTIC";
    PaymentMethodType["DEBITDE"] = "DEBITDE";
    PaymentMethodType["EMI"] = "EMI";
    PaymentMethodType["GIROPAY"] = "GIROPAY";
    PaymentMethodType["IDEAL"] = "IDEAL";
    PaymentMethodType["INDIAWALLET"] = "INDIAWALLET";
    PaymentMethodType["KLARNA"] = "KLARNA";
    PaymentMethodType["KPS"] = "KPS";
    PaymentMethodType["NETBANKING"] = "NETBANKING";
    PaymentMethodType["PAYMENTCARD"] = "PAYMENT_CARD";
    PaymentMethodType["PAYMENTTOKEN"] = "PAYMENT_TOKEN";
    PaymentMethodType["PAYPAL"] = "PAYPAL";
    PaymentMethodType["SEPA"] = "SEPA";
    PaymentMethodType["SOFORT"] = "SOFORT";
    PaymentMethodType["WALLET"] = "WALLET";
    PaymentMethodType["WECHATDOMESTIC"] = "WECHAT_DOMESTIC";
    PaymentMethodType["TELECHECK"] = "TELECHECK";
})(PaymentMethodType = exports.PaymentMethodType || (exports.PaymentMethodType = {}));
/**
    * @export
    * @enum {string}
    */
var PaymentSchedulesErrorResponseRequestStatusEnum;
(function (PaymentSchedulesErrorResponseRequestStatusEnum) {
    PaymentSchedulesErrorResponseRequestStatusEnum["SUCCESS"] = "SUCCESS";
    PaymentSchedulesErrorResponseRequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
    PaymentSchedulesErrorResponseRequestStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
    PaymentSchedulesErrorResponseRequestStatusEnum["FAILURE"] = "FAILURE";
    PaymentSchedulesErrorResponseRequestStatusEnum["DECLINED"] = "DECLINED";
})(PaymentSchedulesErrorResponseRequestStatusEnum = exports.PaymentSchedulesErrorResponseRequestStatusEnum || (exports.PaymentSchedulesErrorResponseRequestStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PaymentSchedulesResponseRequestStatusEnum;
(function (PaymentSchedulesResponseRequestStatusEnum) {
    PaymentSchedulesResponseRequestStatusEnum["SUCCESS"] = "SUCCESS";
    PaymentSchedulesResponseRequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
    PaymentSchedulesResponseRequestStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
    PaymentSchedulesResponseRequestStatusEnum["FAILURE"] = "FAILURE";
    PaymentSchedulesResponseRequestStatusEnum["DECLINED"] = "DECLINED";
})(PaymentSchedulesResponseRequestStatusEnum = exports.PaymentSchedulesResponseRequestStatusEnum || (exports.PaymentSchedulesResponseRequestStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PaymentTokenUpdateResponseRequestStatusEnum;
(function (PaymentTokenUpdateResponseRequestStatusEnum) {
    PaymentTokenUpdateResponseRequestStatusEnum["FAILED"] = "FAILED";
    PaymentTokenUpdateResponseRequestStatusEnum["SUCCESS"] = "SUCCESS";
    PaymentTokenUpdateResponseRequestStatusEnum["PARTIALSUCCESS"] = "PARTIAL_SUCCESS";
})(PaymentTokenUpdateResponseRequestStatusEnum = exports.PaymentTokenUpdateResponseRequestStatusEnum || (exports.PaymentTokenUpdateResponseRequestStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PaymentTokenizationErrorResponseRequestStatusEnum;
(function (PaymentTokenizationErrorResponseRequestStatusEnum) {
    PaymentTokenizationErrorResponseRequestStatusEnum["DELETED"] = "DELETED";
    PaymentTokenizationErrorResponseRequestStatusEnum["FAILED"] = "FAILED";
    PaymentTokenizationErrorResponseRequestStatusEnum["SUCCESS"] = "SUCCESS";
    PaymentTokenizationErrorResponseRequestStatusEnum["APPROVED"] = "APPROVED";
    PaymentTokenizationErrorResponseRequestStatusEnum["WAITING"] = "WAITING";
    PaymentTokenizationErrorResponseRequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
    PaymentTokenizationErrorResponseRequestStatusEnum["DECLINED"] = "DECLINED";
})(PaymentTokenizationErrorResponseRequestStatusEnum = exports.PaymentTokenizationErrorResponseRequestStatusEnum || (exports.PaymentTokenizationErrorResponseRequestStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PaymentTokenizationResponseRequestStatusEnum;
(function (PaymentTokenizationResponseRequestStatusEnum) {
    PaymentTokenizationResponseRequestStatusEnum["DELETED"] = "DELETED";
    PaymentTokenizationResponseRequestStatusEnum["FAILED"] = "FAILED";
    PaymentTokenizationResponseRequestStatusEnum["SUCCESS"] = "SUCCESS";
    PaymentTokenizationResponseRequestStatusEnum["APPROVED"] = "APPROVED";
    PaymentTokenizationResponseRequestStatusEnum["WAITING"] = "WAITING";
    PaymentTokenizationResponseRequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
    PaymentTokenizationResponseRequestStatusEnum["DECLINED"] = "DECLINED";
})(PaymentTokenizationResponseRequestStatusEnum = exports.PaymentTokenizationResponseRequestStatusEnum || (exports.PaymentTokenizationResponseRequestStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PaymentUrlErrorResponseRequestStatusEnum;
(function (PaymentUrlErrorResponseRequestStatusEnum) {
    PaymentUrlErrorResponseRequestStatusEnum["SUCCESS"] = "SUCCESS";
    PaymentUrlErrorResponseRequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
    PaymentUrlErrorResponseRequestStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
    PaymentUrlErrorResponseRequestStatusEnum["FAILURE"] = "FAILURE";
})(PaymentUrlErrorResponseRequestStatusEnum = exports.PaymentUrlErrorResponseRequestStatusEnum || (exports.PaymentUrlErrorResponseRequestStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var PaymentUrlResponseRequestStatusEnum;
(function (PaymentUrlResponseRequestStatusEnum) {
    PaymentUrlResponseRequestStatusEnum["SUCCESS"] = "SUCCESS";
    PaymentUrlResponseRequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
    PaymentUrlResponseRequestStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
    PaymentUrlResponseRequestStatusEnum["FAILURE"] = "FAILURE";
})(PaymentUrlResponseRequestStatusEnum = exports.PaymentUrlResponseRequestStatusEnum || (exports.PaymentUrlResponseRequestStatusEnum = {}));
/**
 * The status of payment URL.
 * @export
 * @enum {string}
 */
var PaymentUrlStatus;
(function (PaymentUrlStatus) {
    PaymentUrlStatus["Created"] = "Created";
    PaymentUrlStatus["Used"] = "Used";
    PaymentUrlStatus["Expired"] = "Expired";
    PaymentUrlStatus["Cancelled"] = "Cancelled";
})(PaymentUrlStatus = exports.PaymentUrlStatus || (exports.PaymentUrlStatus = {}));
/**
    * @export
    * @enum {string}
    */
var ProcessorDataSecurityCodeResponseEnum;
(function (ProcessorDataSecurityCodeResponseEnum) {
    ProcessorDataSecurityCodeResponseEnum["MATCHED"] = "MATCHED";
    ProcessorDataSecurityCodeResponseEnum["NOTMATCHED"] = "NOT_MATCHED";
    ProcessorDataSecurityCodeResponseEnum["NOTPROCESSED"] = "NOT_PROCESSED";
    ProcessorDataSecurityCodeResponseEnum["NOTPRESENT"] = "NOT_PRESENT";
    ProcessorDataSecurityCodeResponseEnum["NOTCERTIFIED"] = "NOT_CERTIFIED";
    ProcessorDataSecurityCodeResponseEnum["NOTCHECKED"] = "NOT_CHECKED";
})(ProcessorDataSecurityCodeResponseEnum = exports.ProcessorDataSecurityCodeResponseEnum || (exports.ProcessorDataSecurityCodeResponseEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ReceiptTypeEnum;
(function (ReceiptTypeEnum) {
    ReceiptTypeEnum["Cardholder"] = "cardholder";
    ReceiptTypeEnum["Merchant"] = "merchant";
})(ReceiptTypeEnum = exports.ReceiptTypeEnum || (exports.ReceiptTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ReceiptRequestInfoTypeEnum;
(function (ReceiptRequestInfoTypeEnum) {
    ReceiptRequestInfoTypeEnum["Cardholder"] = "cardholder";
    ReceiptRequestInfoTypeEnum["Merchant"] = "merchant";
})(ReceiptRequestInfoTypeEnum = exports.ReceiptRequestInfoTypeEnum || (exports.ReceiptRequestInfoTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var RecurringPaymentDetailsStateEnum;
(function (RecurringPaymentDetailsStateEnum) {
    RecurringPaymentDetailsStateEnum["Installed"] = "Installed";
    RecurringPaymentDetailsStateEnum["Inactivated"] = "Inactivated";
    RecurringPaymentDetailsStateEnum["Cancelled"] = "Cancelled";
})(RecurringPaymentDetailsStateEnum = exports.RecurringPaymentDetailsStateEnum || (exports.RecurringPaymentDetailsStateEnum = {}));
/**
    * @export
    * @enum {string}
    */
var RegistrationMethodMethodTypeEnum;
(function (RegistrationMethodMethodTypeEnum) {
    RegistrationMethodMethodTypeEnum["Card"] = "method/card";
    RegistrationMethodMethodTypeEnum["Wallet"] = "method/wallet";
})(RegistrationMethodMethodTypeEnum = exports.RegistrationMethodMethodTypeEnum || (exports.RegistrationMethodMethodTypeEnum = {}));
/**
 * The type of the response.
 * @export
 * @enum {string}
 */
var ResponseType;
(function (ResponseType) {
    ResponseType["BadRequest"] = "BadRequest";
    ResponseType["Unauthenticated"] = "Unauthenticated";
    ResponseType["Unauthorized"] = "Unauthorized";
    ResponseType["NotFound"] = "NotFound";
    ResponseType["GatewayDeclined"] = "GatewayDeclined";
    ResponseType["EndpointDeclined"] = "EndpointDeclined";
    ResponseType["ServerError"] = "ServerError";
    ResponseType["EndpointCommunicationError"] = "EndpointCommunicationError";
    ResponseType["UnsupportedMediaType"] = "UnsupportedMediaType";
})(ResponseType = exports.ResponseType || (exports.ResponseType = {}));
/**
    * @export
    * @enum {string}
    */
var ScoreOnlyRequestOriginalTransactionTypeEnum;
(function (ScoreOnlyRequestOriginalTransactionTypeEnum) {
    ScoreOnlyRequestOriginalTransactionTypeEnum["Authorization"] = "transaction/authorization";
    ScoreOnlyRequestOriginalTransactionTypeEnum["AuthorizationReversal"] = "transaction/authorization-reversal";
    ScoreOnlyRequestOriginalTransactionTypeEnum["Deposit"] = "transaction/deposit";
    ScoreOnlyRequestOriginalTransactionTypeEnum["DepositReversal"] = "transaction/deposit-reversal";
    ScoreOnlyRequestOriginalTransactionTypeEnum["Purchase"] = "transaction/purchase";
    ScoreOnlyRequestOriginalTransactionTypeEnum["PurchaseReversal"] = "transaction/purchase-reversal";
    ScoreOnlyRequestOriginalTransactionTypeEnum["RefundAuthorization"] = "transaction/refund-authorization";
    ScoreOnlyRequestOriginalTransactionTypeEnum["RefundDeposit"] = "transaction/refund-deposit";
    ScoreOnlyRequestOriginalTransactionTypeEnum["Verification"] = "transaction/verification";
    ScoreOnlyRequestOriginalTransactionTypeEnum["BalanceInquiry"] = "transaction/balance-inquiry";
})(ScoreOnlyRequestOriginalTransactionTypeEnum = exports.ScoreOnlyRequestOriginalTransactionTypeEnum || (exports.ScoreOnlyRequestOriginalTransactionTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var ScoreOnlyResponseTransactionStatusEnum;
(function (ScoreOnlyResponseTransactionStatusEnum) {
    ScoreOnlyResponseTransactionStatusEnum["ScoredSuccessfully"] = "Scored Successfully";
    ScoreOnlyResponseTransactionStatusEnum["NotProcessed"] = "Not Processed";
})(ScoreOnlyResponseTransactionStatusEnum = exports.ScoreOnlyResponseTransactionStatusEnum || (exports.ScoreOnlyResponseTransactionStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D10AuthenticationResultVerificationResponseEnum;
(function (Secure3D10AuthenticationResultVerificationResponseEnum) {
    Secure3D10AuthenticationResultVerificationResponseEnum["Y"] = "Y";
    Secure3D10AuthenticationResultVerificationResponseEnum["N"] = "N";
    Secure3D10AuthenticationResultVerificationResponseEnum["U"] = "U";
})(Secure3D10AuthenticationResultVerificationResponseEnum = exports.Secure3D10AuthenticationResultVerificationResponseEnum || (exports.Secure3D10AuthenticationResultVerificationResponseEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D10AuthenticationResultAuthenticationAttemptResultEnum;
(function (Secure3D10AuthenticationResultAuthenticationAttemptResultEnum) {
    Secure3D10AuthenticationResultAuthenticationAttemptResultEnum["Y"] = "Y";
    Secure3D10AuthenticationResultAuthenticationAttemptResultEnum["N"] = "N";
    Secure3D10AuthenticationResultAuthenticationAttemptResultEnum["U"] = "U";
    Secure3D10AuthenticationResultAuthenticationAttemptResultEnum["A"] = "A";
})(Secure3D10AuthenticationResultAuthenticationAttemptResultEnum = exports.Secure3D10AuthenticationResultAuthenticationAttemptResultEnum || (exports.Secure3D10AuthenticationResultAuthenticationAttemptResultEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D10AuthenticationResultAllOfVerificationResponseEnum;
(function (Secure3D10AuthenticationResultAllOfVerificationResponseEnum) {
    Secure3D10AuthenticationResultAllOfVerificationResponseEnum["Y"] = "Y";
    Secure3D10AuthenticationResultAllOfVerificationResponseEnum["N"] = "N";
    Secure3D10AuthenticationResultAllOfVerificationResponseEnum["U"] = "U";
})(Secure3D10AuthenticationResultAllOfVerificationResponseEnum = exports.Secure3D10AuthenticationResultAllOfVerificationResponseEnum || (exports.Secure3D10AuthenticationResultAllOfVerificationResponseEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum;
(function (Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum) {
    Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum["Y"] = "Y";
    Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum["N"] = "N";
    Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum["U"] = "U";
    Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum["A"] = "A";
})(Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum = exports.Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum || (exports.Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D21AuthenticationRequestChallengeIndicatorEnum;
(function (Secure3D21AuthenticationRequestChallengeIndicatorEnum) {
    Secure3D21AuthenticationRequestChallengeIndicatorEnum["_01"] = "01";
    Secure3D21AuthenticationRequestChallengeIndicatorEnum["_02"] = "02";
    Secure3D21AuthenticationRequestChallengeIndicatorEnum["_03"] = "03";
    Secure3D21AuthenticationRequestChallengeIndicatorEnum["_04"] = "04";
})(Secure3D21AuthenticationRequestChallengeIndicatorEnum = exports.Secure3D21AuthenticationRequestChallengeIndicatorEnum || (exports.Secure3D21AuthenticationRequestChallengeIndicatorEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D21AuthenticationRequestChallengeWindowSizeEnum;
(function (Secure3D21AuthenticationRequestChallengeWindowSizeEnum) {
    Secure3D21AuthenticationRequestChallengeWindowSizeEnum["_01"] = "01";
    Secure3D21AuthenticationRequestChallengeWindowSizeEnum["_02"] = "02";
    Secure3D21AuthenticationRequestChallengeWindowSizeEnum["_03"] = "03";
    Secure3D21AuthenticationRequestChallengeWindowSizeEnum["_04"] = "04";
    Secure3D21AuthenticationRequestChallengeWindowSizeEnum["_05"] = "05";
})(Secure3D21AuthenticationRequestChallengeWindowSizeEnum = exports.Secure3D21AuthenticationRequestChallengeWindowSizeEnum || (exports.Secure3D21AuthenticationRequestChallengeWindowSizeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum;
(function (Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum) {
    Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum["_01"] = "01";
    Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum["_02"] = "02";
    Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum["_03"] = "03";
    Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum["_04"] = "04";
})(Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum = exports.Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum || (exports.Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum;
(function (Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum) {
    Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum["_01"] = "01";
    Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum["_02"] = "02";
    Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum["_03"] = "03";
    Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum["_04"] = "04";
    Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum["_05"] = "05";
})(Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum = exports.Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum || (exports.Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D21AuthenticationResultAuthenticationResponseEnum;
(function (Secure3D21AuthenticationResultAuthenticationResponseEnum) {
    Secure3D21AuthenticationResultAuthenticationResponseEnum["A"] = "A";
    Secure3D21AuthenticationResultAuthenticationResponseEnum["N"] = "N";
    Secure3D21AuthenticationResultAuthenticationResponseEnum["U"] = "U";
    Secure3D21AuthenticationResultAuthenticationResponseEnum["Y"] = "Y";
    Secure3D21AuthenticationResultAuthenticationResponseEnum["C"] = "C";
    Secure3D21AuthenticationResultAuthenticationResponseEnum["R"] = "R";
})(Secure3D21AuthenticationResultAuthenticationResponseEnum = exports.Secure3D21AuthenticationResultAuthenticationResponseEnum || (exports.Secure3D21AuthenticationResultAuthenticationResponseEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D21AuthenticationResultTransactionStatusEnum;
(function (Secure3D21AuthenticationResultTransactionStatusEnum) {
    Secure3D21AuthenticationResultTransactionStatusEnum["A"] = "A";
    Secure3D21AuthenticationResultTransactionStatusEnum["N"] = "N";
    Secure3D21AuthenticationResultTransactionStatusEnum["U"] = "U";
    Secure3D21AuthenticationResultTransactionStatusEnum["Y"] = "Y";
    Secure3D21AuthenticationResultTransactionStatusEnum["C"] = "C";
    Secure3D21AuthenticationResultTransactionStatusEnum["R"] = "R";
})(Secure3D21AuthenticationResultTransactionStatusEnum = exports.Secure3D21AuthenticationResultTransactionStatusEnum || (exports.Secure3D21AuthenticationResultTransactionStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum;
(function (Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum) {
    Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum["A"] = "A";
    Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum["N"] = "N";
    Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum["U"] = "U";
    Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum["Y"] = "Y";
    Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum["C"] = "C";
    Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum["R"] = "R";
})(Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum = exports.Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum || (exports.Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D21AuthenticationResultAllOfTransactionStatusEnum;
(function (Secure3D21AuthenticationResultAllOfTransactionStatusEnum) {
    Secure3D21AuthenticationResultAllOfTransactionStatusEnum["A"] = "A";
    Secure3D21AuthenticationResultAllOfTransactionStatusEnum["N"] = "N";
    Secure3D21AuthenticationResultAllOfTransactionStatusEnum["U"] = "U";
    Secure3D21AuthenticationResultAllOfTransactionStatusEnum["Y"] = "Y";
    Secure3D21AuthenticationResultAllOfTransactionStatusEnum["C"] = "C";
    Secure3D21AuthenticationResultAllOfTransactionStatusEnum["R"] = "R";
})(Secure3D21AuthenticationResultAllOfTransactionStatusEnum = exports.Secure3D21AuthenticationResultAllOfTransactionStatusEnum || (exports.Secure3D21AuthenticationResultAllOfTransactionStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D21AuthenticationUpdateRequestMethodNotificationStatusEnum;
(function (Secure3D21AuthenticationUpdateRequestMethodNotificationStatusEnum) {
    Secure3D21AuthenticationUpdateRequestMethodNotificationStatusEnum["RECEIVED"] = "RECEIVED";
    Secure3D21AuthenticationUpdateRequestMethodNotificationStatusEnum["EXPECTEDBUTNOTRECEIVED"] = "EXPECTED_BUT_NOT_RECEIVED";
    Secure3D21AuthenticationUpdateRequestMethodNotificationStatusEnum["NOTEXPECTED"] = "NOT_EXPECTED";
})(Secure3D21AuthenticationUpdateRequestMethodNotificationStatusEnum = exports.Secure3D21AuthenticationUpdateRequestMethodNotificationStatusEnum || (exports.Secure3D21AuthenticationUpdateRequestMethodNotificationStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3D21AuthenticationUpdateRequestAllOfMethodNotificationStatusEnum;
(function (Secure3D21AuthenticationUpdateRequestAllOfMethodNotificationStatusEnum) {
    Secure3D21AuthenticationUpdateRequestAllOfMethodNotificationStatusEnum["RECEIVED"] = "RECEIVED";
    Secure3D21AuthenticationUpdateRequestAllOfMethodNotificationStatusEnum["EXPECTEDBUTNOTRECEIVED"] = "EXPECTED_BUT_NOT_RECEIVED";
    Secure3D21AuthenticationUpdateRequestAllOfMethodNotificationStatusEnum["NOTEXPECTED"] = "NOT_EXPECTED";
})(Secure3D21AuthenticationUpdateRequestAllOfMethodNotificationStatusEnum = exports.Secure3D21AuthenticationUpdateRequestAllOfMethodNotificationStatusEnum || (exports.Secure3D21AuthenticationUpdateRequestAllOfMethodNotificationStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3DAuthenticationResponseTypeEnum;
(function (Secure3DAuthenticationResponseTypeEnum) {
    Secure3DAuthenticationResponseTypeEnum["_3DSECURE"] = "3D_SECURE";
})(Secure3DAuthenticationResponseTypeEnum = exports.Secure3DAuthenticationResponseTypeEnum || (exports.Secure3DAuthenticationResponseTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var Secure3DAuthenticationResponseVersionEnum;
(function (Secure3DAuthenticationResponseVersionEnum) {
    Secure3DAuthenticationResponseVersionEnum["_10"] = "1.0";
    Secure3DAuthenticationResponseVersionEnum["_21"] = "2.1";
    Secure3DAuthenticationResponseVersionEnum["_22"] = "2.2";
})(Secure3DAuthenticationResponseVersionEnum = exports.Secure3DAuthenticationResponseVersionEnum || (exports.Secure3DAuthenticationResponseVersionEnum = {}));
/**
    * @export
    * @enum {string}
    */
var SepaMandateTypeEnum;
(function (SepaMandateTypeEnum) {
    SepaMandateTypeEnum["SINGLE"] = "SINGLE";
    SepaMandateTypeEnum["FIRSTCOLLECTION"] = "FIRST_COLLECTION";
    SepaMandateTypeEnum["RECURRINGCOLLECTION"] = "RECURRING_COLLECTION";
    SepaMandateTypeEnum["FINALCOLLECTION"] = "FINAL_COLLECTION";
})(SepaMandateTypeEnum = exports.SepaMandateTypeEnum || (exports.SepaMandateTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var StoredCredentialSequenceEnum;
(function (StoredCredentialSequenceEnum) {
    StoredCredentialSequenceEnum["FIRST"] = "FIRST";
    StoredCredentialSequenceEnum["SUBSEQUENT"] = "SUBSEQUENT";
})(StoredCredentialSequenceEnum = exports.StoredCredentialSequenceEnum || (exports.StoredCredentialSequenceEnum = {}));
/**
    * @export
    * @enum {string}
    */
var StoredCredentialInitiatorEnum;
(function (StoredCredentialInitiatorEnum) {
    StoredCredentialInitiatorEnum["MERCHANT"] = "MERCHANT";
    StoredCredentialInitiatorEnum["CARDHOLDER"] = "CARDHOLDER";
})(StoredCredentialInitiatorEnum = exports.StoredCredentialInitiatorEnum || (exports.StoredCredentialInitiatorEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TeleCheckAchPaymentMethodAccountTypeEnum;
(function (TeleCheckAchPaymentMethodAccountTypeEnum) {
    TeleCheckAchPaymentMethodAccountTypeEnum["C"] = "C";
    TeleCheckAchPaymentMethodAccountTypeEnum["S"] = "S";
})(TeleCheckAchPaymentMethodAccountTypeEnum = exports.TeleCheckAchPaymentMethodAccountTypeEnum || (exports.TeleCheckAchPaymentMethodAccountTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TeleCheckAchPaymentMethodCheckTypeEnum;
(function (TeleCheckAchPaymentMethodCheckTypeEnum) {
    TeleCheckAchPaymentMethodCheckTypeEnum["P"] = "P";
    TeleCheckAchPaymentMethodCheckTypeEnum["C"] = "C";
})(TeleCheckAchPaymentMethodCheckTypeEnum = exports.TeleCheckAchPaymentMethodCheckTypeEnum || (exports.TeleCheckAchPaymentMethodCheckTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TeleCheckAchPaymentMethodReleaseTypeEnum;
(function (TeleCheckAchPaymentMethodReleaseTypeEnum) {
    TeleCheckAchPaymentMethodReleaseTypeEnum["C"] = "C";
    TeleCheckAchPaymentMethodReleaseTypeEnum["D"] = "D";
    TeleCheckAchPaymentMethodReleaseTypeEnum["P"] = "P";
    TeleCheckAchPaymentMethodReleaseTypeEnum["T"] = "T";
})(TeleCheckAchPaymentMethodReleaseTypeEnum = exports.TeleCheckAchPaymentMethodReleaseTypeEnum || (exports.TeleCheckAchPaymentMethodReleaseTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TeleCheckAchPaymentMethodVipCustomerEnum;
(function (TeleCheckAchPaymentMethodVipCustomerEnum) {
    TeleCheckAchPaymentMethodVipCustomerEnum["Y"] = "Y";
    TeleCheckAchPaymentMethodVipCustomerEnum["N"] = "N";
})(TeleCheckAchPaymentMethodVipCustomerEnum = exports.TeleCheckAchPaymentMethodVipCustomerEnum || (exports.TeleCheckAchPaymentMethodVipCustomerEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TransactionErrorResponseTransactionStatusEnum;
(function (TransactionErrorResponseTransactionStatusEnum) {
    TransactionErrorResponseTransactionStatusEnum["APPROVED"] = "APPROVED";
    TransactionErrorResponseTransactionStatusEnum["WAITING"] = "WAITING";
    TransactionErrorResponseTransactionStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
    TransactionErrorResponseTransactionStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
    TransactionErrorResponseTransactionStatusEnum["DECLINED"] = "DECLINED";
})(TransactionErrorResponseTransactionStatusEnum = exports.TransactionErrorResponseTransactionStatusEnum || (exports.TransactionErrorResponseTransactionStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TransactionErrorResponseTransactionStateEnum;
(function (TransactionErrorResponseTransactionStateEnum) {
    TransactionErrorResponseTransactionStateEnum["AUTHORIZED"] = "AUTHORIZED";
    TransactionErrorResponseTransactionStateEnum["CAPTURED"] = "CAPTURED";
    TransactionErrorResponseTransactionStateEnum["DECLINED"] = "DECLINED";
    TransactionErrorResponseTransactionStateEnum["CHECKED"] = "CHECKED";
    TransactionErrorResponseTransactionStateEnum["COMPLETEDGET"] = "COMPLETED_GET";
    TransactionErrorResponseTransactionStateEnum["INITIALIZED"] = "INITIALIZED";
    TransactionErrorResponseTransactionStateEnum["PENDING"] = "PENDING";
    TransactionErrorResponseTransactionStateEnum["READY"] = "READY";
    TransactionErrorResponseTransactionStateEnum["TEMPLATE"] = "TEMPLATE";
    TransactionErrorResponseTransactionStateEnum["SETTLED"] = "SETTLED";
    TransactionErrorResponseTransactionStateEnum["VOIDED"] = "VOIDED";
    TransactionErrorResponseTransactionStateEnum["WAITING"] = "WAITING";
})(TransactionErrorResponseTransactionStateEnum = exports.TransactionErrorResponseTransactionStateEnum || (exports.TransactionErrorResponseTransactionStateEnum = {}));
/**
 * The source of the transaction. The possible values are ECOM (if the order was received via email or Internet), MAIL, PHONE and RETAIL (face to face).
 * @export
 * @enum {string}
 */
var TransactionOrigin;
(function (TransactionOrigin) {
    TransactionOrigin["ECOM"] = "ECOM";
    TransactionOrigin["MAIL"] = "MAIL";
    TransactionOrigin["PHONE"] = "PHONE";
    TransactionOrigin["RETAIL"] = "RETAIL";
})(TransactionOrigin = exports.TransactionOrigin || (exports.TransactionOrigin = {}));
/**
    * @export
    * @enum {string}
    */
var TransactionResponseTransactionStatusEnum;
(function (TransactionResponseTransactionStatusEnum) {
    TransactionResponseTransactionStatusEnum["APPROVED"] = "APPROVED";
    TransactionResponseTransactionStatusEnum["WAITING"] = "WAITING";
    TransactionResponseTransactionStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
    TransactionResponseTransactionStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
    TransactionResponseTransactionStatusEnum["DECLINED"] = "DECLINED";
})(TransactionResponseTransactionStatusEnum = exports.TransactionResponseTransactionStatusEnum || (exports.TransactionResponseTransactionStatusEnum = {}));
/**
    * @export
    * @enum {string}
    */
var TransactionResponseTransactionStateEnum;
(function (TransactionResponseTransactionStateEnum) {
    TransactionResponseTransactionStateEnum["AUTHORIZED"] = "AUTHORIZED";
    TransactionResponseTransactionStateEnum["CAPTURED"] = "CAPTURED";
    TransactionResponseTransactionStateEnum["DECLINED"] = "DECLINED";
    TransactionResponseTransactionStateEnum["CHECKED"] = "CHECKED";
    TransactionResponseTransactionStateEnum["COMPLETEDGET"] = "COMPLETED_GET";
    TransactionResponseTransactionStateEnum["INITIALIZED"] = "INITIALIZED";
    TransactionResponseTransactionStateEnum["PENDING"] = "PENDING";
    TransactionResponseTransactionStateEnum["READY"] = "READY";
    TransactionResponseTransactionStateEnum["TEMPLATE"] = "TEMPLATE";
    TransactionResponseTransactionStateEnum["SETTLED"] = "SETTLED";
    TransactionResponseTransactionStateEnum["VOIDED"] = "VOIDED";
    TransactionResponseTransactionStateEnum["WAITING"] = "WAITING";
})(TransactionResponseTransactionStateEnum = exports.TransactionResponseTransactionStateEnum || (exports.TransactionResponseTransactionStateEnum = {}));
/**
 * Type of transaction to perform. Primary transaction types in requests include \'SALE\', \'PREAUTH\', \'CREDIT\' and \'FORCED_TICKET\'.
 * @export
 * @enum {string}
 */
var TransactionType;
(function (TransactionType) {
    TransactionType["SALE"] = "SALE";
    TransactionType["PREAUTH"] = "PREAUTH";
    TransactionType["CREDIT"] = "CREDIT";
    TransactionType["FORCEDTICKET"] = "FORCED_TICKET";
    TransactionType["VOID"] = "VOID";
    TransactionType["RETURN"] = "RETURN";
    TransactionType["POSTAUTH"] = "POSTAUTH";
    TransactionType["PAYERAUTH"] = "PAYER_AUTH";
    TransactionType["DISBURSEMENT"] = "DISBURSEMENT";
})(TransactionType = exports.TransactionType || (exports.TransactionType = {}));
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
exports.AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccessTokenRequest} accessTokenRequest Access token request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost: function (contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'accessTokenRequest' is not null or undefined
            if (accessTokenRequest === null || accessTokenRequest === undefined) {
                throw new base_1.RequiredError('accessTokenRequest', 'Required parameter accessTokenRequest was null or undefined when calling authenticationAccessTokensPost.');
            }
            var localVarPath = "/authentication/access-tokens";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("AccessTokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(accessTokenRequest !== undefined ? accessTokenRequest : {}) : (accessTokenRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
exports.AuthenticationApiFp = function (configuration) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccessTokenRequest} accessTokenRequest Access token request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost: function (contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options) {
            var localVarAxiosArgs = exports.AuthenticationApiAxiosParamCreator(configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
exports.AuthenticationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccessTokenRequest} accessTokenRequest Access token request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost: function (contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options) {
            return exports.AuthenticationApiFp(configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options)(axios, basePath);
        },
    };
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
var AuthenticationApi = /** @class */ (function (_super) {
    __extends(AuthenticationApi, _super);
    function AuthenticationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
     * @summary Generate an access token for user authentication.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccessTokenRequest} accessTokenRequest Access token request
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    AuthenticationApi.prototype.authenticationAccessTokensPost = function (contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options) {
        return exports.AuthenticationApiFp(this.configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options)(this.axios, this.basePath);
    };
    return AuthenticationApi;
}(base_1.BaseAPI));
exports.AuthenticationApi = AuthenticationApi;
/**
 * CurrencyConversionApi - axios parameter creator
 * @export
 */
exports.CurrencyConversionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate: function (contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'exchangeRateRequest' is not null or undefined
            if (exchangeRateRequest === null || exchangeRateRequest === undefined) {
                throw new base_1.RequiredError('exchangeRateRequest', 'Required parameter exchangeRateRequest was null or undefined when calling getExchangeRate.');
            }
            var localVarPath = "/exchange-rates";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("ExchangeRateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(exchangeRateRequest !== undefined ? exchangeRateRequest : {}) : (exchangeRateRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CurrencyConversionApi - functional programming interface
 * @export
 */
exports.CurrencyConversionApiFp = function (configuration) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate: function (contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options) {
            var localVarAxiosArgs = exports.CurrencyConversionApiAxiosParamCreator(configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * CurrencyConversionApi - factory interface
 * @export
 */
exports.CurrencyConversionApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate: function (contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options) {
            return exports.CurrencyConversionApiFp(configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * CurrencyConversionApi - object-oriented interface
 * @export
 * @class CurrencyConversionApi
 * @extends {BaseAPI}
 */
var CurrencyConversionApi = /** @class */ (function (_super) {
    __extends(CurrencyConversionApi, _super);
    function CurrencyConversionApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Sale, return and lookup exchange rate with dynamic currency conversion option.
     * @summary Generate dynamic currency conversion transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyConversionApi
     */
    CurrencyConversionApi.prototype.getExchangeRate = function (contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options) {
        return exports.CurrencyConversionApiFp(this.configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options)(this.axios, this.basePath);
    };
    return CurrencyConversionApi;
}(base_1.BaseAPI));
exports.CurrencyConversionApi = CurrencyConversionApi;
/**
 * FraudDetectApi - axios parameter creator
 * @export
 */
exports.FraudDetectApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost: function (contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'clientRegistration' is not null or undefined
            if (clientRegistration === null || clientRegistration === undefined) {
                throw new base_1.RequiredError('clientRegistration', 'Required parameter clientRegistration was null or undefined when calling fraudClientRegistrationPost.');
            }
            var localVarPath = "/fraud/client-registration";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("ClientRegistration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(clientRegistration !== undefined ? clientRegistration : {}) : (clientRegistration || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost: function (contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'paymentRegistration' is not null or undefined
            if (paymentRegistration === null || paymentRegistration === undefined) {
                throw new base_1.RequiredError('paymentRegistration', 'Required parameter paymentRegistration was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            var localVarPath = "/fraud/payment-registration";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PaymentRegistration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentRegistration !== undefined ? paymentRegistration : {}) : (paymentRegistration || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly: function (contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'scoreOnlyRequest' is not null or undefined
            if (scoreOnlyRequest === null || scoreOnlyRequest === undefined) {
                throw new base_1.RequiredError('scoreOnlyRequest', 'Required parameter scoreOnlyRequest was null or undefined when calling scoreOnly.');
            }
            var localVarPath = "/fraud/score-only";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("ScoreOnlyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(scoreOnlyRequest !== undefined ? scoreOnlyRequest : {}) : (scoreOnlyRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FraudDetectApi - functional programming interface
 * @export
 */
exports.FraudDetectApiFp = function (configuration) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost: function (contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options) {
            var localVarAxiosArgs = exports.FraudDetectApiAxiosParamCreator(configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost: function (contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options) {
            var localVarAxiosArgs = exports.FraudDetectApiAxiosParamCreator(configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly: function (contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options) {
            var localVarAxiosArgs = exports.FraudDetectApiAxiosParamCreator(configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * FraudDetectApi - factory interface
 * @export
 */
exports.FraudDetectApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost: function (contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options) {
            return exports.FraudDetectApiFp(configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost: function (contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options) {
            return exports.FraudDetectApiFp(configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly: function (contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options) {
            return exports.FraudDetectApiFp(configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * FraudDetectApi - object-oriented interface
 * @export
 * @class FraudDetectApi
 * @extends {BaseAPI}
 */
var FraudDetectApi = /** @class */ (function (_super) {
    __extends(FraudDetectApi, _super);
    function FraudDetectApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this to register client for fraud detect transaction.
     * @summary Client registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ClientRegistration} clientRegistration
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    FraudDetectApi.prototype.fraudClientRegistrationPost = function (contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options) {
        return exports.FraudDetectApiFp(this.configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options)(this.axios, this.basePath);
    };
    /**
     * Use this to register payment for fraud detect transaction.
     * @summary Payment registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentRegistration} paymentRegistration
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    FraudDetectApi.prototype.fraudPaymentRegistrationPost = function (contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options) {
        return exports.FraudDetectApiFp(this.configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options)(this.axios, this.basePath);
    };
    /**
     * Use this to obtain a fraud score for a transaction.
     * @summary Score a transaction for fraud.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    FraudDetectApi.prototype.scoreOnly = function (contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options) {
        return exports.FraudDetectApiFp(this.configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options)(this.axios, this.basePath);
    };
    return FraudDetectApi;
}(base_1.BaseAPI));
exports.FraudDetectApi = FraudDetectApi;
/**
 * InformationLookupApi - axios parameter creator
 * @export
 */
exports.InformationLookupApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup: function (contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'cardInfoLookupRequest' is not null or undefined
            if (cardInfoLookupRequest === null || cardInfoLookupRequest === undefined) {
                throw new base_1.RequiredError('cardInfoLookupRequest', 'Required parameter cardInfoLookupRequest was null or undefined when calling cardInfoLookup.');
            }
            var localVarPath = "/card-information";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("CardInfoLookupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(cardInfoLookupRequest !== undefined ? cardInfoLookupRequest : {}) : (cardInfoLookupRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to look up card related information associated with a payment card or payment token.
         * @summary Account information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountInfoLookupRequest} accountInfoLookupRequest Accepted request type: PaymentCardInfoLookupRequest and PaymentTokenInfoLookupRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccount: function (contentType, clientRequestId, apiKey, timestamp, accountInfoLookupRequest, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling lookupAccount.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling lookupAccount.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling lookupAccount.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling lookupAccount.');
            }
            // verify required parameter 'accountInfoLookupRequest' is not null or undefined
            if (accountInfoLookupRequest === null || accountInfoLookupRequest === undefined) {
                throw new base_1.RequiredError('accountInfoLookupRequest', 'Required parameter accountInfoLookupRequest was null or undefined when calling lookupAccount.');
            }
            var localVarPath = "/account-information";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("AccountInfoLookupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(accountInfoLookupRequest !== undefined ? accountInfoLookupRequest : {}) : (accountInfoLookupRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * InformationLookupApi - functional programming interface
 * @export
 */
exports.InformationLookupApiFp = function (configuration) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup: function (contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options) {
            var localVarAxiosArgs = exports.InformationLookupApiAxiosParamCreator(configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to look up card related information associated with a payment card or payment token.
         * @summary Account information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountInfoLookupRequest} accountInfoLookupRequest Accepted request type: PaymentCardInfoLookupRequest and PaymentTokenInfoLookupRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccount: function (contentType, clientRequestId, apiKey, timestamp, accountInfoLookupRequest, messageSignature, region, options) {
            var localVarAxiosArgs = exports.InformationLookupApiAxiosParamCreator(configuration).lookupAccount(contentType, clientRequestId, apiKey, timestamp, accountInfoLookupRequest, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * InformationLookupApi - factory interface
 * @export
 */
exports.InformationLookupApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup: function (contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options) {
            return exports.InformationLookupApiFp(configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to look up card related information associated with a payment card or payment token.
         * @summary Account information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountInfoLookupRequest} accountInfoLookupRequest Accepted request type: PaymentCardInfoLookupRequest and PaymentTokenInfoLookupRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccount: function (contentType, clientRequestId, apiKey, timestamp, accountInfoLookupRequest, messageSignature, region, options) {
            return exports.InformationLookupApiFp(configuration).lookupAccount(contentType, clientRequestId, apiKey, timestamp, accountInfoLookupRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * InformationLookupApi - object-oriented interface
 * @export
 * @class InformationLookupApi
 * @extends {BaseAPI}
 */
var InformationLookupApi = /** @class */ (function (_super) {
    __extends(InformationLookupApi, _super);
    function InformationLookupApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this to look up card related information such as issuer country, card function and card brand.
     * @summary Card information lookup.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationLookupApi
     */
    InformationLookupApi.prototype.cardInfoLookup = function (contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options) {
        return exports.InformationLookupApiFp(this.configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options)(this.axios, this.basePath);
    };
    /**
     * Use this to look up card related information associated with a payment card or payment token.
     * @summary Account information lookup.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccountInfoLookupRequest} accountInfoLookupRequest Accepted request type: PaymentCardInfoLookupRequest and PaymentTokenInfoLookupRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationLookupApi
     */
    InformationLookupApi.prototype.lookupAccount = function (contentType, clientRequestId, apiKey, timestamp, accountInfoLookupRequest, messageSignature, region, options) {
        return exports.InformationLookupApiFp(this.configuration).lookupAccount(contentType, clientRequestId, apiKey, timestamp, accountInfoLookupRequest, messageSignature, region, options)(this.axios, this.basePath);
    };
    return InformationLookupApi;
}(base_1.BaseAPI));
exports.InformationLookupApi = InformationLookupApi;
/**
 * OrderApi - axios parameter creator
 * @export
 */
exports.OrderApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry: function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling orderInquiry.');
            }
            var localVarPath = "/orders/{order-id}"
                .replace("{" + "order-id" + "}", encodeURIComponent(String(orderId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder: function (contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new base_1.RequiredError('secondaryTransaction', 'Required parameter secondaryTransaction was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            var localVarPath = "/orders/{order-id}"
                .replace("{" + "order-id" + "}", encodeURIComponent(String(orderId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(secondaryTransaction !== undefined ? secondaryTransaction : {}) : (secondaryTransaction || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrderApi - functional programming interface
 * @export
 */
exports.OrderApiFp = function (configuration) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry: function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            var localVarAxiosArgs = exports.OrderApiAxiosParamCreator(configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder: function (contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options) {
            var localVarAxiosArgs = exports.OrderApiAxiosParamCreator(configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * OrderApi - factory interface
 * @export
 */
exports.OrderApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry: function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            return exports.OrderApiFp(configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder: function (contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options) {
            return exports.OrderApiFp(configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
var OrderApi = /** @class */ (function (_super) {
    __extends(OrderApi, _super);
    function OrderApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this query to get the current state of an existing order.
     * @summary Retrieve the state of an order.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    OrderApi.prototype.orderInquiry = function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
        return exports.OrderApiFp(this.configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    };
    /**
     * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
     * @summary Perform return or postAuth secondary transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    OrderApi.prototype.submitSecondaryTransactionFromOrder = function (contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options) {
        return exports.OrderApiFp(this.configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options)(this.axios, this.basePath);
    };
    return OrderApi;
}(base_1.BaseAPI));
exports.OrderApi = OrderApi;
/**
 * PaymentApi - axios parameter creator
 * @export
 */
exports.PaymentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction: function (contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new base_1.RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'authenticationUpdateRequest' is not null or undefined
            if (authenticationUpdateRequest === null || authenticationUpdateRequest === undefined) {
                throw new base_1.RequiredError('authenticationUpdateRequest', 'Required parameter authenticationUpdateRequest was null or undefined when calling finalizeSecureTransaction.');
            }
            var localVarPath = "/payments/{transaction-id}"
                .replace("{" + "transaction-id" + "}", encodeURIComponent(String(transactionId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'PATCH' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("AuthenticationUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(authenticationUpdateRequest !== undefined ? authenticationUpdateRequest : {}) : (authenticationUpdateRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction, AchPreAuthTransaction, AchSaleTransaction, AchCreditTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction: function (contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'primaryTransaction' is not null or undefined
            if (primaryTransaction === null || primaryTransaction === undefined) {
                throw new base_1.RequiredError('primaryTransaction', 'Required parameter primaryTransaction was null or undefined when calling submitPrimaryTransaction.');
            }
            var localVarPath = "/payments";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PrimaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(primaryTransaction !== undefined ? primaryTransaction : {}) : (primaryTransaction || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction: function (contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new base_1.RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new base_1.RequiredError('secondaryTransaction', 'Required parameter secondaryTransaction was null or undefined when calling submitSecondaryTransaction.');
            }
            var localVarPath = "/payments/{transaction-id}"
                .replace("{" + "transaction-id" + "}", encodeURIComponent(String(transactionId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(secondaryTransaction !== undefined ? secondaryTransaction : {}) : (secondaryTransaction || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry: function (contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new base_1.RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling transactionInquiry.');
            }
            var localVarPath = "/payments/{transaction-id}"
                .replace("{" + "transaction-id" + "}", encodeURIComponent(String(transactionId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentApi - functional programming interface
 * @export
 */
exports.PaymentApiFp = function (configuration) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction: function (contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options) {
            var localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction, AchPreAuthTransaction, AchSaleTransaction, AchCreditTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction: function (contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options) {
            var localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction: function (contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
            var localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry: function (contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
            var localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentApi - factory interface
 * @export
 */
exports.PaymentApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction: function (contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options) {
            return exports.PaymentApiFp(configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction, AchPreAuthTransaction, AchSaleTransaction, AchCreditTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction: function (contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options) {
            return exports.PaymentApiFp(configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction: function (contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
            return exports.PaymentApiFp(configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry: function (contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
            return exports.PaymentApiFp(configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(axios, basePath);
        },
    };
};
/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
var PaymentApi = /** @class */ (function (_super) {
    __extends(PaymentApi, _super);
    function PaymentApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
     * @summary Update a 3DSecure or UnionPay payment and continue processing.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    PaymentApi.prototype.finalizeSecureTransaction = function (contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options) {
        return exports.PaymentApiFp(this.configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options)(this.axios, this.basePath);
    };
    /**
     * Use this to originate a financial transaction like a sale, preauthorization, or credit.
     * @summary Generate a primary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction, AchPreAuthTransaction, AchSaleTransaction, AchCreditTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    PaymentApi.prototype.submitPrimaryTransaction = function (contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options) {
        return exports.PaymentApiFp(this.configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options)(this.axios, this.basePath);
    };
    /**
     * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
     * @summary Perform a secondary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    PaymentApi.prototype.submitSecondaryTransaction = function (contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
        return exports.PaymentApiFp(this.configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(this.axios, this.basePath);
    };
    /**
     * Use this query to get the current state of an existing transaction.
     * @summary Retrieve the state of a transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    PaymentApi.prototype.transactionInquiry = function (contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
        return exports.PaymentApiFp(this.configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    };
    return PaymentApi;
}(base_1.BaseAPI));
exports.PaymentApi = PaymentApi;
/**
 * PaymentSchedulesApi - axios parameter creator
 * @export
 */
exports.PaymentSchedulesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling cancelPaymentSchedule.');
            }
            var localVarPath = "/payment-schedules/{order-id}"
                .replace("{" + "order-id" + "}", encodeURIComponent(String(orderId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'paymentSchedulesRequest' is not null or undefined
            if (paymentSchedulesRequest === null || paymentSchedulesRequest === undefined) {
                throw new base_1.RequiredError('paymentSchedulesRequest', 'Required parameter paymentSchedulesRequest was null or undefined when calling createPaymentSchedule.');
            }
            var localVarPath = "/payment-schedules";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PaymentSchedulesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentSchedulesRequest !== undefined ? paymentSchedulesRequest : {}) : (paymentSchedulesRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling inquiryPaymentSchedule.');
            }
            var localVarPath = "/payment-schedules/{order-id}"
                .replace("{" + "order-id" + "}", encodeURIComponent(String(orderId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'paymentSchedulesRequest' is not null or undefined
            if (paymentSchedulesRequest === null || paymentSchedulesRequest === undefined) {
                throw new base_1.RequiredError('paymentSchedulesRequest', 'Required parameter paymentSchedulesRequest was null or undefined when calling updatePaymentSchedule.');
            }
            var localVarPath = "/payment-schedules/{order-id}"
                .replace("{" + "order-id" + "}", encodeURIComponent(String(orderId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'PATCH' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PaymentSchedulesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentSchedulesRequest !== undefined ? paymentSchedulesRequest : {}) : (paymentSchedulesRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentSchedulesApi - functional programming interface
 * @export
 */
exports.PaymentSchedulesApiFp = function (configuration) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            var localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options) {
            var localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            var localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options) {
            var localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentSchedulesApi - factory interface
 * @export
 */
exports.PaymentSchedulesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            return exports.PaymentSchedulesApiFp(configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options) {
            return exports.PaymentSchedulesApiFp(configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            return exports.PaymentSchedulesApiFp(configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule: function (contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options) {
            return exports.PaymentSchedulesApiFp(configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * PaymentSchedulesApi - object-oriented interface
 * @export
 * @class PaymentSchedulesApi
 * @extends {BaseAPI}
 */
var PaymentSchedulesApi = /** @class */ (function (_super) {
    __extends(PaymentSchedulesApi, _super);
    function PaymentSchedulesApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this to cancel an existing gateway payment schedule.
     * @summary Cancel a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    PaymentSchedulesApi.prototype.cancelPaymentSchedule = function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    };
    /**
     * Use this to create a gateway payment schedule.
     * @summary Create gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    PaymentSchedulesApi.prototype.createPaymentSchedule = function (contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options)(this.axios, this.basePath);
    };
    /**
     * Use this to view an existing gateway payment schedule.
     * @summary View a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    PaymentSchedulesApi.prototype.inquiryPaymentSchedule = function (contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    };
    /**
     * Use this to update a gateway payment schedule.
     * @summary Update a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    PaymentSchedulesApi.prototype.updatePaymentSchedule = function (contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options)(this.axios, this.basePath);
    };
    return PaymentSchedulesApi;
}(base_1.BaseAPI));
exports.PaymentSchedulesApi = PaymentSchedulesApi;
/**
 * PaymentTokenApi - axios parameter creator
 * @export
 */
exports.PaymentTokenApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken: function (contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'paymentTokenizationRequest' is not null or undefined
            if (paymentTokenizationRequest === null || paymentTokenizationRequest === undefined) {
                throw new base_1.RequiredError('paymentTokenizationRequest', 'Required parameter paymentTokenizationRequest was null or undefined when calling createPaymentToken.');
            }
            var localVarPath = "/payment-tokens";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PaymentTokenizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentTokenizationRequest !== undefined ? paymentTokenizationRequest : {}) : (paymentTokenizationRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken: function (contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new base_1.RequiredError('tokenId', 'Required parameter tokenId was null or undefined when calling deletePaymentToken.');
            }
            var localVarPath = "/payment-tokens/{token-id}"
                .replace("{" + "token-id" + "}", encodeURIComponent(String(tokenId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payment card details associated with token.
         * @summary Get payment card details associated with token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTokenDetails: function (contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new base_1.RequiredError('tokenId', 'Required parameter tokenId was null or undefined when calling getPaymentTokenDetails.');
            }
            var localVarPath = "/payment-tokens/{token-id}"
                .replace("{" + "token-id" + "}", encodeURIComponent(String(tokenId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this update one or more payment tokens.
         * @summary Update one or more payment tokens.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentCardPaymentTokenUpdateRequest} paymentCardPaymentTokenUpdateRequest Accepted request type: PaymentCardPaymentTokenUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentToken: function (contentType, clientRequestId, apiKey, timestamp, paymentCardPaymentTokenUpdateRequest, messageSignature, authorization, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling updatePaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling updatePaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling updatePaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling updatePaymentToken.');
            }
            // verify required parameter 'paymentCardPaymentTokenUpdateRequest' is not null or undefined
            if (paymentCardPaymentTokenUpdateRequest === null || paymentCardPaymentTokenUpdateRequest === undefined) {
                throw new base_1.RequiredError('paymentCardPaymentTokenUpdateRequest', 'Required parameter paymentCardPaymentTokenUpdateRequest was null or undefined when calling updatePaymentToken.');
            }
            var localVarPath = "/payment-tokens";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'PATCH' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PaymentCardPaymentTokenUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentCardPaymentTokenUpdateRequest !== undefined ? paymentCardPaymentTokenUpdateRequest : {}) : (paymentCardPaymentTokenUpdateRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentTokenApi - functional programming interface
 * @export
 */
exports.PaymentTokenApiFp = function (configuration) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken: function (contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options) {
            var localVarAxiosArgs = exports.PaymentTokenApiAxiosParamCreator(configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken: function (contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
            var localVarAxiosArgs = exports.PaymentTokenApiAxiosParamCreator(configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get payment card details associated with token.
         * @summary Get payment card details associated with token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTokenDetails: function (contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
            var localVarAxiosArgs = exports.PaymentTokenApiAxiosParamCreator(configuration).getPaymentTokenDetails(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this update one or more payment tokens.
         * @summary Update one or more payment tokens.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentCardPaymentTokenUpdateRequest} paymentCardPaymentTokenUpdateRequest Accepted request type: PaymentCardPaymentTokenUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentToken: function (contentType, clientRequestId, apiKey, timestamp, paymentCardPaymentTokenUpdateRequest, messageSignature, authorization, region, options) {
            var localVarAxiosArgs = exports.PaymentTokenApiAxiosParamCreator(configuration).updatePaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentCardPaymentTokenUpdateRequest, messageSignature, authorization, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentTokenApi - factory interface
 * @export
 */
exports.PaymentTokenApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken: function (contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options) {
            return exports.PaymentTokenApiFp(configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options)(axios, basePath);
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken: function (contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
            return exports.PaymentTokenApiFp(configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(axios, basePath);
        },
        /**
         * Get payment card details associated with token.
         * @summary Get payment card details associated with token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTokenDetails: function (contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
            return exports.PaymentTokenApiFp(configuration).getPaymentTokenDetails(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this update one or more payment tokens.
         * @summary Update one or more payment tokens.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentCardPaymentTokenUpdateRequest} paymentCardPaymentTokenUpdateRequest Accepted request type: PaymentCardPaymentTokenUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentToken: function (contentType, clientRequestId, apiKey, timestamp, paymentCardPaymentTokenUpdateRequest, messageSignature, authorization, region, options) {
            return exports.PaymentTokenApiFp(configuration).updatePaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentCardPaymentTokenUpdateRequest, messageSignature, authorization, region, options)(axios, basePath);
        },
    };
};
/**
 * PaymentTokenApi - object-oriented interface
 * @export
 * @class PaymentTokenApi
 * @extends {BaseAPI}
 */
var PaymentTokenApi = /** @class */ (function (_super) {
    __extends(PaymentTokenApi, _super);
    function PaymentTokenApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this to create a payment token from a payment card.
     * @summary Create a payment token from a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    PaymentTokenApi.prototype.createPaymentToken = function (contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options) {
        return exports.PaymentTokenApiFp(this.configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options)(this.axios, this.basePath);
    };
    /**
     * Use this to delete a payment token.
     * @summary Delete a payment token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    PaymentTokenApi.prototype.deletePaymentToken = function (contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
        return exports.PaymentTokenApiFp(this.configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(this.axios, this.basePath);
    };
    /**
     * Get payment card details associated with token.
     * @summary Get payment card details associated with token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    PaymentTokenApi.prototype.getPaymentTokenDetails = function (contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
        return exports.PaymentTokenApiFp(this.configuration).getPaymentTokenDetails(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(this.axios, this.basePath);
    };
    /**
     * Use this update one or more payment tokens.
     * @summary Update one or more payment tokens.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentCardPaymentTokenUpdateRequest} paymentCardPaymentTokenUpdateRequest Accepted request type: PaymentCardPaymentTokenUpdateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    PaymentTokenApi.prototype.updatePaymentToken = function (contentType, clientRequestId, apiKey, timestamp, paymentCardPaymentTokenUpdateRequest, messageSignature, authorization, region, options) {
        return exports.PaymentTokenApiFp(this.configuration).updatePaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentCardPaymentTokenUpdateRequest, messageSignature, authorization, region, options)(this.axios, this.basePath);
    };
    return PaymentTokenApi;
}(base_1.BaseAPI));
exports.PaymentTokenApi = PaymentTokenApi;
/**
 * PaymentURLApi - axios parameter creator
 * @export
 */
exports.PaymentURLApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl: function (contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'paymentUrlRequest' is not null or undefined
            if (paymentUrlRequest === null || paymentUrlRequest === undefined) {
                throw new base_1.RequiredError('paymentUrlRequest', 'Required parameter paymentUrlRequest was null or undefined when calling createPaymentUrl.');
            }
            var localVarPath = "/payment-url";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("PaymentUrlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentUrlRequest !== undefined ? paymentUrlRequest : {}) : (paymentUrlRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl: function (contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling deletePaymentUrl.');
            }
            var localVarPath = "/payment-url";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'DELETE' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }
            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (paymentUrlId !== undefined) {
                localVarQueryParameter['paymentUrlId'] = paymentUrlId;
            }
            if (transactionTime !== undefined) {
                localVarQueryParameter['transactionTime'] = transactionTime;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail: function (contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'fromDate' is not null or undefined
            if (fromDate === null || fromDate === undefined) {
                throw new base_1.RequiredError('fromDate', 'Required parameter fromDate was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'toDate' is not null or undefined
            if (toDate === null || toDate === undefined) {
                throw new base_1.RequiredError('toDate', 'Required parameter toDate was null or undefined when calling paymentUrlDetail.');
            }
            var localVarPath = "/payment-url";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'GET' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (merchantTransactionId !== undefined) {
                localVarQueryParameter['merchantTransactionId'] = merchantTransactionId;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentURLApi - functional programming interface
 * @export
 */
exports.PaymentURLApiFp = function (configuration) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl: function (contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options) {
            var localVarAxiosArgs = exports.PaymentURLApiAxiosParamCreator(configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl: function (contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options) {
            var localVarAxiosArgs = exports.PaymentURLApiAxiosParamCreator(configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail: function (contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options) {
            var localVarAxiosArgs = exports.PaymentURLApiAxiosParamCreator(configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentURLApi - factory interface
 * @export
 */
exports.PaymentURLApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl: function (contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options) {
            return exports.PaymentURLApiFp(configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl: function (contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options) {
            return exports.PaymentURLApiFp(configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options)(axios, basePath);
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail: function (contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options) {
            return exports.PaymentURLApiFp(configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options)(axios, basePath);
        },
    };
};
/**
 * PaymentURLApi - object-oriented interface
 * @export
 * @class PaymentURLApi
 * @extends {BaseAPI}
 */
var PaymentURLApi = /** @class */ (function (_super) {
    __extends(PaymentURLApi, _super);
    function PaymentURLApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this to generate an embedding payment link.
     * @summary Create a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    PaymentURLApi.prototype.createPaymentUrl = function (contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options) {
        return exports.PaymentURLApiFp(this.configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options)(this.axios, this.basePath);
    };
    /**
     * Use this to delete an embedding payment link.
     * @summary Delete a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [paymentUrlId] The ID code from the payment URL.
     * @param {string} [transactionTime] The transaction time in seconds since epoch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    PaymentURLApi.prototype.deletePaymentUrl = function (contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options) {
        return exports.PaymentURLApiFp(this.configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options)(this.axios, this.basePath);
    };
    /**
     * Use this query to get the current state of an existing paymentURL.
     * @summary Retrieve the state of payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} fromDate The start date for payment URL in seconds since epoch.
     * @param {string} toDate The end date for payment URL search query in seconds since epoch.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
     * @param {string} [status] The status of payment URL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    PaymentURLApi.prototype.paymentUrlDetail = function (contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options) {
        return exports.PaymentURLApiFp(this.configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options)(this.axios, this.basePath);
    };
    return PaymentURLApi;
}(base_1.BaseAPI));
exports.PaymentURLApi = PaymentURLApi;
/**
 * VerificationApi - axios parameter creator
 * @export
 */
exports.VerificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to perform an account verification for a payment card or payment token.
         * @summary Verify a payment card or payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountVerificationRequest} accountVerificationRequest Accepted request type: PaymentCardVerificationRequest and PaymentTokenVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAccount: function (contentType, clientRequestId, apiKey, timestamp, accountVerificationRequest, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling verifyAccount.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling verifyAccount.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling verifyAccount.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling verifyAccount.');
            }
            // verify required parameter 'accountVerificationRequest' is not null or undefined
            if (accountVerificationRequest === null || accountVerificationRequest === undefined) {
                throw new base_1.RequiredError('accountVerificationRequest', 'Required parameter accountVerificationRequest was null or undefined when calling verifyAccount.');
            }
            var localVarPath = "/account-verification";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("AccountVerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(accountVerificationRequest !== undefined ? accountVerificationRequest : {}) : (accountVerificationRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to perform card verification for a payment card. Use the account-verification endpoint instead for this request.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard: function (contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new base_1.RequiredError('contentType', 'Required parameter contentType was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new base_1.RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new base_1.RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new base_1.RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'cardVerificationRequest' is not null or undefined
            if (cardVerificationRequest === null || cardVerificationRequest === undefined) {
                throw new base_1.RequiredError('cardVerificationRequest', 'Required parameter cardVerificationRequest was null or undefined when calling verifyCard.');
            }
            var localVarPath = "/card-verification";
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign({ method: 'POST' }, baseOptions, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = __assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = ("CardVerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(cardVerificationRequest !== undefined ? cardVerificationRequest : {}) : (cardVerificationRequest || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * VerificationApi - functional programming interface
 * @export
 */
exports.VerificationApiFp = function (configuration) {
    return {
        /**
         * Use this to perform an account verification for a payment card or payment token.
         * @summary Verify a payment card or payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountVerificationRequest} accountVerificationRequest Accepted request type: PaymentCardVerificationRequest and PaymentTokenVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAccount: function (contentType, clientRequestId, apiKey, timestamp, accountVerificationRequest, messageSignature, region, options) {
            var localVarAxiosArgs = exports.VerificationApiAxiosParamCreator(configuration).verifyAccount(contentType, clientRequestId, apiKey, timestamp, accountVerificationRequest, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to perform card verification for a payment card. Use the account-verification endpoint instead for this request.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard: function (contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options) {
            var localVarAxiosArgs = exports.VerificationApiAxiosParamCreator(configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = axios_1.default; }
                if (basePath === void 0) { basePath = base_1.BASE_PATH; }
                var axiosRequestArgs = __assign({}, localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * VerificationApi - factory interface
 * @export
 */
exports.VerificationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to perform an account verification for a payment card or payment token.
         * @summary Verify a payment card or payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountVerificationRequest} accountVerificationRequest Accepted request type: PaymentCardVerificationRequest and PaymentTokenVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAccount: function (contentType, clientRequestId, apiKey, timestamp, accountVerificationRequest, messageSignature, region, options) {
            return exports.VerificationApiFp(configuration).verifyAccount(contentType, clientRequestId, apiKey, timestamp, accountVerificationRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to perform card verification for a payment card. Use the account-verification endpoint instead for this request.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard: function (contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options) {
            return exports.VerificationApiFp(configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
var VerificationApi = /** @class */ (function (_super) {
    __extends(VerificationApi, _super);
    function VerificationApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Use this to perform an account verification for a payment card or payment token.
     * @summary Verify a payment card or payment token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccountVerificationRequest} accountVerificationRequest Accepted request type: PaymentCardVerificationRequest and PaymentTokenVerificationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    VerificationApi.prototype.verifyAccount = function (contentType, clientRequestId, apiKey, timestamp, accountVerificationRequest, messageSignature, region, options) {
        return exports.VerificationApiFp(this.configuration).verifyAccount(contentType, clientRequestId, apiKey, timestamp, accountVerificationRequest, messageSignature, region, options)(this.axios, this.basePath);
    };
    /**
     * Use this to perform card verification for a payment card. Use the account-verification endpoint instead for this request.
     * @summary Verify a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    VerificationApi.prototype.verifyCard = function (contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options) {
        return exports.VerificationApiFp(this.configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options)(this.axios, this.basePath);
    };
    return VerificationApi;
}(base_1.BaseAPI));
exports.VerificationApi = VerificationApi;
