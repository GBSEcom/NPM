"use strict";
// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Payment Gateway API Specification.
 * Payment Gateway API for payment processing. Version 6.4.0.20181018.001
 *
 * OpenAPI spec version: 6.4.0.20181018.001
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
const axios_1 = require("axios");
const BASE_PATH = "https://cert.api.firstdata.com/gateway".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, axios = axios_1.default) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace AVSResponse
 */
var AVSResponse;
(function (AVSResponse) {
    /**
     * @export
     * @enum {string}
     */
    let StreetMatchEnum;
    (function (StreetMatchEnum) {
        StreetMatchEnum["Y"] = "Y";
        StreetMatchEnum["N"] = "N";
        StreetMatchEnum["NOINPUTDATA"] = "NO_INPUT_DATA";
        StreetMatchEnum["NOTCHECKED"] = "NOT_CHECKED";
    })(StreetMatchEnum = AVSResponse.StreetMatchEnum || (AVSResponse.StreetMatchEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let PostalCodeMatchEnum;
    (function (PostalCodeMatchEnum) {
        PostalCodeMatchEnum["Y"] = "Y";
        PostalCodeMatchEnum["N"] = "N";
        PostalCodeMatchEnum["NOINPUTDATA"] = "NO_INPUT_DATA";
        PostalCodeMatchEnum["NOTCHECKED"] = "NOT_CHECKED";
    })(PostalCodeMatchEnum = AVSResponse.PostalCodeMatchEnum || (AVSResponse.PostalCodeMatchEnum = {}));
})(AVSResponse = exports.AVSResponse || (exports.AVSResponse = {}));
/**
 * @export
 * @namespace AccessTokenResponse
 */
var AccessTokenResponse;
(function (AccessTokenResponse) {
    /**
     * @export
     * @enum {string}
     */
    let RequestStatusEnum;
    (function (RequestStatusEnum) {
        RequestStatusEnum["SUCCESS"] = "SUCCESS";
    })(RequestStatusEnum = AccessTokenResponse.RequestStatusEnum || (AccessTokenResponse.RequestStatusEnum = {}));
})(AccessTokenResponse = exports.AccessTokenResponse || (exports.AccessTokenResponse = {}));
/**
 * @export
 * @namespace Airline
 */
var Airline;
(function (Airline) {
    /**
     * @export
     * @enum {string}
     */
    let ReservationSystemEnum;
    (function (ReservationSystemEnum) {
        ReservationSystemEnum["START"] = "START";
        ReservationSystemEnum["TWA"] = "TWA";
        ReservationSystemEnum["DELTA"] = "DELTA";
        ReservationSystemEnum["SABRE"] = "SABRE";
        ReservationSystemEnum["COVIAAPOLLO"] = "COVIA_APOLLO";
        ReservationSystemEnum["DRBLANK"] = "DR_BLANK";
        ReservationSystemEnum["DER"] = "DER";
        ReservationSystemEnum["TUI"] = "TUI";
    })(ReservationSystemEnum = Airline.ReservationSystemEnum || (Airline.ReservationSystemEnum = {}));
})(Airline = exports.Airline || (exports.Airline = {}));
/**
 * @export
 * @namespace AirlineAncillaryServiceCategory
 */
var AirlineAncillaryServiceCategory;
(function (AirlineAncillaryServiceCategory) {
    /**
     * @export
     * @enum {string}
     */
    let ServiceCategoryEnum;
    (function (ServiceCategoryEnum) {
        ServiceCategoryEnum["BUNDLEDSERVICE"] = "BUNDLED_SERVICE";
        ServiceCategoryEnum["BAGGAGEFEE"] = "BAGGAGE_FEE";
        ServiceCategoryEnum["CHANGEFEE"] = "CHANGE_FEE";
        ServiceCategoryEnum["CARGO"] = "CARGO";
        ServiceCategoryEnum["CARBONOFFSET"] = "CARBON_OFFSET";
        ServiceCategoryEnum["FREQUENTFLYER"] = "FREQUENT_FLYER";
        ServiceCategoryEnum["GIFTCARD"] = "GIFT_CARD";
        ServiceCategoryEnum["GROUNDTRANSPORT"] = "GROUND_TRANSPORT";
        ServiceCategoryEnum["INFLIGHTENTERTAINMENT"] = "IN_FLIGHT_ENTERTAINMENT";
        ServiceCategoryEnum["LOUNGE"] = "LOUNGE";
        ServiceCategoryEnum["MEDICAL"] = "MEDICAL";
        ServiceCategoryEnum["MEALBEVERAGE"] = "MEAL_BEVERAGE";
        ServiceCategoryEnum["OTHER"] = "OTHER";
        ServiceCategoryEnum["PASSENGERASSISTFEE"] = "PASSENGER_ASSIST_FEE";
        ServiceCategoryEnum["PETS"] = "PETS";
        ServiceCategoryEnum["SEATFEES"] = "SEAT_FEES";
        ServiceCategoryEnum["STANDBY"] = "STANDBY";
        ServiceCategoryEnum["SERVICEFEE"] = "SERVICE_FEE";
        ServiceCategoryEnum["STORE"] = "STORE";
        ServiceCategoryEnum["TRAVELSERVICE"] = "TRAVEL_SERVICE";
        ServiceCategoryEnum["UNACCOMPANIEDTRAVEL"] = "UNACCOMPANIED_TRAVEL";
        ServiceCategoryEnum["UPGRADES"] = "UPGRADES";
        ServiceCategoryEnum["WIFI"] = "WI_FI";
    })(ServiceCategoryEnum = AirlineAncillaryServiceCategory.ServiceCategoryEnum || (AirlineAncillaryServiceCategory.ServiceCategoryEnum = {}));
})(AirlineAncillaryServiceCategory = exports.AirlineAncillaryServiceCategory || (exports.AirlineAncillaryServiceCategory = {}));
/**
 * @export
 * @namespace AirlineTravelRoute
 */
var AirlineTravelRoute;
(function (AirlineTravelRoute) {
    /**
     * @export
     * @enum {string}
     */
    let StopoverTypeEnum;
    (function (StopoverTypeEnum) {
        StopoverTypeEnum["DIRECT"] = "DIRECT";
        StopoverTypeEnum["STOPOVER"] = "STOPOVER";
    })(StopoverTypeEnum = AirlineTravelRoute.StopoverTypeEnum || (AirlineTravelRoute.StopoverTypeEnum = {}));
})(AirlineTravelRoute = exports.AirlineTravelRoute || (exports.AirlineTravelRoute = {}));
/**
 * @export
 * @namespace AliPay
 */
var AliPay;
(function (AliPay) {
    /**
     * @export
     * @enum {string}
     */
    let PaymentDataTypeEnum;
    (function (PaymentDataTypeEnum) {
        PaymentDataTypeEnum["BARCODE"] = "BARCODE";
        PaymentDataTypeEnum["QRCODE"] = "QRCODE";
    })(PaymentDataTypeEnum = AliPay.PaymentDataTypeEnum || (AliPay.PaymentDataTypeEnum = {}));
})(AliPay = exports.AliPay || (exports.AliPay = {}));
/**
 * @export
 * @namespace AuthenticationRequest
 */
var AuthenticationRequest;
(function (AuthenticationRequest) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["SECURE3D"] = "SECURE_3D";
        TypeEnum["UNIONPAY"] = "UNIONPAY";
    })(TypeEnum = AuthenticationRequest.TypeEnum || (AuthenticationRequest.TypeEnum = {}));
})(AuthenticationRequest = exports.AuthenticationRequest || (exports.AuthenticationRequest = {}));
/**
 * @export
 * @namespace AuthenticationResponseVerification
 */
var AuthenticationResponseVerification;
(function (AuthenticationResponseVerification) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["SECURE3D"] = "SECURE_3D";
        TypeEnum["UNIONPAY"] = "UNIONPAY";
    })(TypeEnum = AuthenticationResponseVerification.TypeEnum || (AuthenticationResponseVerification.TypeEnum = {}));
})(AuthenticationResponseVerification = exports.AuthenticationResponseVerification || (exports.AuthenticationResponseVerification = {}));
/**
 * @export
 * @namespace Billing
 */
var Billing;
(function (Billing) {
    /**
     * @export
     * @enum {string}
     */
    let GenderEnum;
    (function (GenderEnum) {
        GenderEnum["MALE"] = "MALE";
        GenderEnum["FEMALE"] = "FEMALE";
        GenderEnum["UNKNOWN"] = "UNKNOWN";
    })(GenderEnum = Billing.GenderEnum || (Billing.GenderEnum = {}));
})(Billing = exports.Billing || (exports.Billing = {}));
/**
 * @export
 * @namespace CarRentalExtraCharges
 */
var CarRentalExtraCharges;
(function (CarRentalExtraCharges) {
    /**
     * @export
     * @enum {string}
     */
    let ChargeItemEnum;
    (function (ChargeItemEnum) {
        ChargeItemEnum["EXTRAMILEAGE"] = "EXTRA_MILEAGE";
        ChargeItemEnum["GAS"] = "GAS";
        ChargeItemEnum["LATERETURN"] = "LATE_RETURN";
        ChargeItemEnum["ONEWAYSERVICEFEE"] = "ONE_WAY_SERVICE_FEE";
        ChargeItemEnum["PARKINGVIOLATION"] = "PARKING_VIOLATION";
    })(ChargeItemEnum = CarRentalExtraCharges.ChargeItemEnum || (CarRentalExtraCharges.ChargeItemEnum = {}));
})(CarRentalExtraCharges = exports.CarRentalExtraCharges || (exports.CarRentalExtraCharges = {}));
/**
 * @export
 * @namespace CardInfo
 */
var CardInfo;
(function (CardInfo) {
    /**
     * @export
     * @enum {string}
     */
    let CardFunctionEnum;
    (function (CardFunctionEnum) {
        CardFunctionEnum["Credit"] = "credit";
        CardFunctionEnum["Debit"] = "debit";
        CardFunctionEnum["Prepaid"] = "prepaid";
        CardFunctionEnum["Voucher"] = "voucher";
        CardFunctionEnum["Undefined"] = "undefined";
    })(CardFunctionEnum = CardInfo.CardFunctionEnum || (CardInfo.CardFunctionEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let CommercialCardEnum;
    (function (CommercialCardEnum) {
        CommercialCardEnum["CORPORATE"] = "CORPORATE";
        CommercialCardEnum["NONCORPORATE"] = "NON_CORPORATE";
    })(CommercialCardEnum = CardInfo.CommercialCardEnum || (CardInfo.CommercialCardEnum = {}));
})(CardInfo = exports.CardInfo || (exports.CardInfo = {}));
/**
 * @export
 * @namespace CardInfoLookupResponse
 */
var CardInfoLookupResponse;
(function (CardInfoLookupResponse) {
    /**
     * @export
     * @enum {string}
     */
    let RequestStatusEnum;
    (function (RequestStatusEnum) {
        RequestStatusEnum["SUCCESS"] = "SUCCESS";
        RequestStatusEnum["LISTEMPTY"] = "LIST_EMPTY";
    })(RequestStatusEnum = CardInfoLookupResponse.RequestStatusEnum || (CardInfoLookupResponse.RequestStatusEnum = {}));
})(CardInfoLookupResponse = exports.CardInfoLookupResponse || (exports.CardInfoLookupResponse = {}));
/**
 * @export
 * @namespace Customer
 */
var Customer;
(function (Customer) {
    /**
     * @export
     * @enum {string}
     */
    let GenderEnum;
    (function (GenderEnum) {
        GenderEnum["Male"] = "male";
        GenderEnum["Female"] = "female";
        GenderEnum["Other"] = "other";
    })(GenderEnum = Customer.GenderEnum || (Customer.GenderEnum = {}));
})(Customer = exports.Customer || (exports.Customer = {}));
/**
 * @export
 * @namespace Device
 */
var Device;
(function (Device) {
    /**
     * @export
     * @enum {string}
     */
    let DeviceTypeEnum;
    (function (DeviceTypeEnum) {
        DeviceTypeEnum["Pos"] = "device/pos";
        DeviceTypeEnum["Mobile"] = "device/mobile";
    })(DeviceTypeEnum = Device.DeviceTypeEnum || (Device.DeviceTypeEnum = {}));
})(Device = exports.Device || (exports.Device = {}));
/**
 * @export
 * @namespace DeviceNetworks
 */
var DeviceNetworks;
(function (DeviceNetworks) {
    /**
     * @export
     * @enum {string}
     */
    let NetworkTypeEnum;
    (function (NetworkTypeEnum) {
        NetworkTypeEnum["Mobile"] = "network/mobile";
        NetworkTypeEnum["Wifi"] = "network/wifi";
    })(NetworkTypeEnum = DeviceNetworks.NetworkTypeEnum || (DeviceNetworks.NetworkTypeEnum = {}));
})(DeviceNetworks = exports.DeviceNetworks || (exports.DeviceNetworks = {}));
/**
 * @export
 * @namespace Document
 */
var Document;
(function (Document) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["NATIONALIDENTITY"] = "NATIONAL_IDENTITY";
        TypeEnum["SINGLETAXIDENTIFICATION"] = "SINGLE_TAX_IDENTIFICATION";
        TypeEnum["SINGLECODEOFLABORIDENTIFICATION"] = "SINGLE_CODE_OF_LABOR_IDENTIFICATION";
        TypeEnum["BOOKENLISTMENT"] = "BOOK_ENLISTMENT";
        TypeEnum["CIVICNOTEBOOK"] = "CIVIC_NOTEBOOK";
        TypeEnum["PASSPORT"] = "PASSPORT";
    })(TypeEnum = Document.TypeEnum || (Document.TypeEnum = {}));
})(Document = exports.Document || (exports.Document = {}));
/**
 * @export
 * @namespace ExchangeRateRequest
 */
var ExchangeRateRequest;
(function (ExchangeRateRequest) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["DCC"] = "DCC";
        TypeEnum["DYNAMICPRICING"] = "DYNAMIC_PRICING";
    })(TypeEnum = ExchangeRateRequest.TypeEnum || (ExchangeRateRequest.TypeEnum = {}));
})(ExchangeRateRequest = exports.ExchangeRateRequest || (exports.ExchangeRateRequest = {}));
/**
 * @export
 * @namespace Frequency
 */
var Frequency;
(function (Frequency) {
    /**
     * @export
     * @enum {string}
     */
    let UnitEnum;
    (function (UnitEnum) {
        UnitEnum["DAY"] = "DAY";
        UnitEnum["WEEK"] = "WEEK";
        UnitEnum["MONTH"] = "MONTH";
        UnitEnum["YEAR"] = "YEAR";
    })(UnitEnum = Frequency.UnitEnum || (Frequency.UnitEnum = {}));
})(Frequency = exports.Frequency || (exports.Frequency = {}));
/**
 * @export
 * @namespace LodgingExtraCharges
 */
var LodgingExtraCharges;
(function (LodgingExtraCharges) {
    /**
     * @export
     * @enum {string}
     */
    let ChargeItemEnum;
    (function (ChargeItemEnum) {
        ChargeItemEnum["GIFTSHOP"] = "GIFT_SHOP";
        ChargeItemEnum["LAUNDRY"] = "LAUNDRY";
        ChargeItemEnum["MINIBAR"] = "MINI_BAR";
        ChargeItemEnum["RESTAURANT"] = "RESTAURANT";
        ChargeItemEnum["TELEPHONE"] = "TELEPHONE";
        ChargeItemEnum["OTHER"] = "OTHER";
    })(ChargeItemEnum = LodgingExtraCharges.ChargeItemEnum || (LodgingExtraCharges.ChargeItemEnum = {}));
})(LodgingExtraCharges = exports.LodgingExtraCharges || (exports.LodgingExtraCharges = {}));
/**
 * @export
 * @namespace Payment
 */
var Payment;
(function (Payment) {
    /**
     * @export
     * @enum {string}
     */
    let PaymentTypeEnum;
    (function (PaymentTypeEnum) {
        PaymentTypeEnum["Card"] = "payment/card";
        PaymentTypeEnum["Wallet"] = "payment/wallet";
    })(PaymentTypeEnum = Payment.PaymentTypeEnum || (Payment.PaymentTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let EntryMethodEnum;
    (function (EntryMethodEnum) {
        EntryMethodEnum["Manual"] = "manual";
        EntryMethodEnum["Stripe"] = "stripe";
        EntryMethodEnum["Ocr"] = "ocr";
        EntryMethodEnum["Emv"] = "emv";
        EntryMethodEnum["Nfc"] = "nfc";
        EntryMethodEnum["Remote"] = "remote";
        EntryMethodEnum["PinPresent"] = "pinPresent";
    })(EntryMethodEnum = Payment.EntryMethodEnum || (Payment.EntryMethodEnum = {}));
})(Payment = exports.Payment || (exports.Payment = {}));
/**
 * @export
 * @namespace PaymentCardAuthenticationResult
 */
var PaymentCardAuthenticationResult;
(function (PaymentCardAuthenticationResult) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["SECURE3D"] = "SECURE_3D";
    })(TypeEnum = PaymentCardAuthenticationResult.TypeEnum || (PaymentCardAuthenticationResult.TypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let VerificationResponseEnum;
    (function (VerificationResponseEnum) {
        VerificationResponseEnum["Y"] = "Y";
        VerificationResponseEnum["N"] = "N";
        VerificationResponseEnum["U"] = "U";
    })(VerificationResponseEnum = PaymentCardAuthenticationResult.VerificationResponseEnum || (PaymentCardAuthenticationResult.VerificationResponseEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let PayerAuthenticationResponseEnum;
    (function (PayerAuthenticationResponseEnum) {
        PayerAuthenticationResponseEnum["Y"] = "Y";
        PayerAuthenticationResponseEnum["N"] = "N";
        PayerAuthenticationResponseEnum["U"] = "U";
        PayerAuthenticationResponseEnum["A"] = "A";
    })(PayerAuthenticationResponseEnum = PaymentCardAuthenticationResult.PayerAuthenticationResponseEnum || (PaymentCardAuthenticationResult.PayerAuthenticationResponseEnum = {}));
})(PaymentCardAuthenticationResult = exports.PaymentCardAuthenticationResult || (exports.PaymentCardAuthenticationResult = {}));
/**
 * @export
 * @namespace PaymentIssuerResponse
 */
var PaymentIssuerResponse;
(function (PaymentIssuerResponse) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum["Approved"] = "approved";
        StatusEnum["Declined"] = "declined";
        StatusEnum["Disabled"] = "disabled";
        StatusEnum["Unknown"] = "unknown";
    })(StatusEnum = PaymentIssuerResponse.StatusEnum || (PaymentIssuerResponse.StatusEnum = {}));
})(PaymentIssuerResponse = exports.PaymentIssuerResponse || (exports.PaymentIssuerResponse = {}));
/**
 * @export
 * @namespace PaymentMethod
 */
var PaymentMethod;
(function (PaymentMethod) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["ALIPAY"] = "ALIPAY";
        TypeEnum["ALIPAYPAYSECUREUS"] = "ALIPAY_PAYSECURE_US";
        TypeEnum["ALIPAYDOMESTIC"] = "ALIPAY_DOMESTIC";
        TypeEnum["APM"] = "APM";
        TypeEnum["CUPDOMESTIC"] = "CUP_DOMESTIC";
        TypeEnum["DEBITDE"] = "DEBITDE";
        TypeEnum["EMI"] = "EMI";
        TypeEnum["GIROPAY"] = "GIROPAY";
        TypeEnum["IDEAL"] = "IDEAL";
        TypeEnum["INDIAWALLET"] = "INDIAWALLET";
        TypeEnum["KLARNA"] = "KLARNA";
        TypeEnum["NETBANKING"] = "NETBANKING";
        TypeEnum["PAYMENTCARD"] = "PAYMENT_CARD";
        TypeEnum["PAYMENTTOKEN"] = "PAYMENT_TOKEN";
        TypeEnum["PAYPAL"] = "PAYPAL";
        TypeEnum["SEPA"] = "SEPA";
        TypeEnum["SOFORT"] = "SOFORT";
        TypeEnum["WALLET"] = "WALLET";
        TypeEnum["WECHATDOMESTIC"] = "WECHAT_DOMESTIC";
    })(TypeEnum = PaymentMethod.TypeEnum || (PaymentMethod.TypeEnum = {}));
})(PaymentMethod = exports.PaymentMethod || (exports.PaymentMethod = {}));
/**
 * @export
 * @namespace PaymentPayMethod
 */
var PaymentPayMethod;
(function (PaymentPayMethod) {
    /**
     * @export
     * @enum {string}
     */
    let MethodTypeEnum;
    (function (MethodTypeEnum) {
        MethodTypeEnum["Card"] = "method/card";
        MethodTypeEnum["Wallet"] = "method/wallet";
    })(MethodTypeEnum = PaymentPayMethod.MethodTypeEnum || (PaymentPayMethod.MethodTypeEnum = {}));
})(PaymentPayMethod = exports.PaymentPayMethod || (exports.PaymentPayMethod = {}));
/**
 * @export
 * @namespace PaymentSchedulesResponse
 */
var PaymentSchedulesResponse;
(function (PaymentSchedulesResponse) {
    /**
     * @export
     * @enum {string}
     */
    let RequestStatusEnum;
    (function (RequestStatusEnum) {
        RequestStatusEnum["SUCCESS"] = "SUCCESS";
        RequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
        RequestStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
        RequestStatusEnum["FAILURE"] = "FAILURE";
        RequestStatusEnum["DECLINED"] = "DECLINED";
    })(RequestStatusEnum = PaymentSchedulesResponse.RequestStatusEnum || (PaymentSchedulesResponse.RequestStatusEnum = {}));
})(PaymentSchedulesResponse = exports.PaymentSchedulesResponse || (exports.PaymentSchedulesResponse = {}));
/**
 * @export
 * @namespace PaymentTokenization
 */
var PaymentTokenization;
(function (PaymentTokenization) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["PAYMENTCARD"] = "PAYMENT_CARD";
    })(TypeEnum = PaymentTokenization.TypeEnum || (PaymentTokenization.TypeEnum = {}));
})(PaymentTokenization = exports.PaymentTokenization || (exports.PaymentTokenization = {}));
/**
 * @export
 * @namespace PaymentTokenizationRequest
 */
var PaymentTokenizationRequest;
(function (PaymentTokenizationRequest) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["PAYMENTCARD"] = "PAYMENT_CARD";
        TypeEnum["EXISTINGORDER"] = "EXISTING_ORDER";
    })(TypeEnum = PaymentTokenizationRequest.TypeEnum || (PaymentTokenizationRequest.TypeEnum = {}));
})(PaymentTokenizationRequest = exports.PaymentTokenizationRequest || (exports.PaymentTokenizationRequest = {}));
/**
 * @export
 * @namespace PaymentTokenizationResponse
 */
var PaymentTokenizationResponse;
(function (PaymentTokenizationResponse) {
    /**
     * @export
     * @enum {string}
     */
    let RequestStatusEnum;
    (function (RequestStatusEnum) {
        RequestStatusEnum["DELETED"] = "DELETED";
        RequestStatusEnum["FAILED"] = "FAILED";
        RequestStatusEnum["SUCCESS"] = "SUCCESS";
        RequestStatusEnum["APPROVED"] = "APPROVED";
        RequestStatusEnum["WAITING"] = "WAITING";
        RequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
        RequestStatusEnum["DECLINED"] = "DECLINED";
    })(RequestStatusEnum = PaymentTokenizationResponse.RequestStatusEnum || (PaymentTokenizationResponse.RequestStatusEnum = {}));
})(PaymentTokenizationResponse = exports.PaymentTokenizationResponse || (exports.PaymentTokenizationResponse = {}));
/**
 * @export
 * @namespace PaymentUrlResponse
 */
var PaymentUrlResponse;
(function (PaymentUrlResponse) {
    /**
     * @export
     * @enum {string}
     */
    let RequestStatusEnum;
    (function (RequestStatusEnum) {
        RequestStatusEnum["SUCCESS"] = "SUCCESS";
        RequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
        RequestStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
        RequestStatusEnum["FAILURE"] = "FAILURE";
    })(RequestStatusEnum = PaymentUrlResponse.RequestStatusEnum || (PaymentUrlResponse.RequestStatusEnum = {}));
})(PaymentUrlResponse = exports.PaymentUrlResponse || (exports.PaymentUrlResponse = {}));
/**
 * @export
 * @namespace ProcessorData
 */
var ProcessorData;
(function (ProcessorData) {
    /**
     * @export
     * @enum {string}
     */
    let SecurityCodeResponseEnum;
    (function (SecurityCodeResponseEnum) {
        SecurityCodeResponseEnum["MATCHED"] = "MATCHED";
        SecurityCodeResponseEnum["NOTMATCHED"] = "NOT_MATCHED";
        SecurityCodeResponseEnum["NOTPROCESSED"] = "NOT_PROCESSED";
        SecurityCodeResponseEnum["NOTPRESENT"] = "NOT_PRESENT";
        SecurityCodeResponseEnum["NOTCERTIFIED"] = "NOT_CERTIFIED";
    })(SecurityCodeResponseEnum = ProcessorData.SecurityCodeResponseEnum || (ProcessorData.SecurityCodeResponseEnum = {}));
})(ProcessorData = exports.ProcessorData || (exports.ProcessorData = {}));
/**
 * @export
 * @namespace RecurringPaymentDetails
 */
var RecurringPaymentDetails;
(function (RecurringPaymentDetails) {
    /**
     * @export
     * @enum {string}
     */
    let StateEnum;
    (function (StateEnum) {
        StateEnum["Installed"] = "Installed";
        StateEnum["Inactivated"] = "Inactivated";
        StateEnum["Cancelled"] = "Cancelled";
    })(StateEnum = RecurringPaymentDetails.StateEnum || (RecurringPaymentDetails.StateEnum = {}));
})(RecurringPaymentDetails = exports.RecurringPaymentDetails || (exports.RecurringPaymentDetails = {}));
/**
 * The type of the response.
 * @export
 * @enum {string}
 */
var ResponseType;
(function (ResponseType) {
    ResponseType["BadRequest"] = "BadRequest";
    ResponseType["Unauthenticated"] = "Unauthenticated";
    ResponseType["Unauthorized"] = "Unauthorized";
    ResponseType["NotFound"] = "NotFound";
    ResponseType["GatewayDeclined"] = "GatewayDeclined";
    ResponseType["EndpointDeclined"] = "EndpointDeclined";
    ResponseType["ServerError"] = "ServerError";
    ResponseType["EndpointCommunicationError"] = "EndpointCommunicationError";
    ResponseType["UnsupportedMediaType"] = "UnsupportedMediaType";
})(ResponseType = exports.ResponseType || (exports.ResponseType = {}));
/**
 * @export
 * @namespace ScoreOnlyRequest
 */
var ScoreOnlyRequest;
(function (ScoreOnlyRequest) {
    /**
     * @export
     * @enum {string}
     */
    let TransactionTypeEnum;
    (function (TransactionTypeEnum) {
        TransactionTypeEnum["ScoreOnly"] = "scoreOnly";
    })(TransactionTypeEnum = ScoreOnlyRequest.TransactionTypeEnum || (ScoreOnlyRequest.TransactionTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let OriginalTransactionTypeEnum;
    (function (OriginalTransactionTypeEnum) {
        OriginalTransactionTypeEnum["Authorization"] = "transaction/authorization";
        OriginalTransactionTypeEnum["AuthorizationReversal"] = "transaction/authorization-reversal";
        OriginalTransactionTypeEnum["Deposit"] = "transaction/deposit";
        OriginalTransactionTypeEnum["DepositReversal"] = "transaction/deposit-reversal";
        OriginalTransactionTypeEnum["Purchase"] = "transaction/purchase";
        OriginalTransactionTypeEnum["PurchaseReversal"] = "transaction/purchase-reversal";
        OriginalTransactionTypeEnum["RefundAuthorization"] = "transaction/refund-authorization";
        OriginalTransactionTypeEnum["RefundDeposit"] = "transaction/refund-deposit";
        OriginalTransactionTypeEnum["Verification"] = "transaction/verification";
        OriginalTransactionTypeEnum["BalanceInquiry"] = "transaction/balance-inquiry";
    })(OriginalTransactionTypeEnum = ScoreOnlyRequest.OriginalTransactionTypeEnum || (ScoreOnlyRequest.OriginalTransactionTypeEnum = {}));
})(ScoreOnlyRequest = exports.ScoreOnlyRequest || (exports.ScoreOnlyRequest = {}));
/**
 * @export
 * @namespace ScoreOnlyResponse
 */
var ScoreOnlyResponse;
(function (ScoreOnlyResponse) {
    /**
     * @export
     * @enum {string}
     */
    let TransactionStatusEnum;
    (function (TransactionStatusEnum) {
        TransactionStatusEnum["ScoredSuccessfully"] = "Scored successfully";
        TransactionStatusEnum["NotProcessed"] = "Not Processed";
    })(TransactionStatusEnum = ScoreOnlyResponse.TransactionStatusEnum || (ScoreOnlyResponse.TransactionStatusEnum = {}));
})(ScoreOnlyResponse = exports.ScoreOnlyResponse || (exports.ScoreOnlyResponse = {}));
/**
 * @export
 * @namespace SepaMandate
 */
var SepaMandate;
(function (SepaMandate) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["SINGLE"] = "SINGLE";
        TypeEnum["FIRSTCOLLECTION"] = "FIRST_COLLECTION";
        TypeEnum["RECURRINGCOLLECTION"] = "RECURRING_COLLECTION";
        TypeEnum["FINALCOLLECTION"] = "FINAL_COLLECTION";
    })(TypeEnum = SepaMandate.TypeEnum || (SepaMandate.TypeEnum = {}));
})(SepaMandate = exports.SepaMandate || (exports.SepaMandate = {}));
/**
 * @export
 * @namespace StoredCredential
 */
var StoredCredential;
(function (StoredCredential) {
    /**
     * @export
     * @enum {string}
     */
    let SequenceEnum;
    (function (SequenceEnum) {
        SequenceEnum["FIRST"] = "FIRST";
        SequenceEnum["SUBSEQUENT"] = "SUBSEQUENT";
    })(SequenceEnum = StoredCredential.SequenceEnum || (StoredCredential.SequenceEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let InitiatorEnum;
    (function (InitiatorEnum) {
        InitiatorEnum["MERCHANT"] = "MERCHANT";
        InitiatorEnum["CARDHOLDER"] = "CARDHOLDER";
    })(InitiatorEnum = StoredCredential.InitiatorEnum || (StoredCredential.InitiatorEnum = {}));
})(StoredCredential = exports.StoredCredential || (exports.StoredCredential = {}));
/**
 * @export
 * @namespace Transaction
 */
var Transaction;
(function (Transaction) {
    /**
     * @export
     * @enum {string}
     */
    let TransactionStateEnum;
    (function (TransactionStateEnum) {
        TransactionStateEnum["AUTHORIZED"] = "AUTHORIZED";
        TransactionStateEnum["CAPTURED"] = "CAPTURED";
        TransactionStateEnum["COMPLETEDGET"] = "COMPLETED_GET";
        TransactionStateEnum["DECLINED"] = "DECLINED";
        TransactionStateEnum["CHECKED"] = "CHECKED";
        TransactionStateEnum["INITIALIZED"] = "INITIALIZED";
        TransactionStateEnum["PENDINGAUTHORIZATION"] = "PENDING_AUTHORIZATION";
        TransactionStateEnum["PENDINGAUTOVOID"] = "PENDING_AUTOVOID";
        TransactionStateEnum["PENDINGCAPTURE"] = "PENDING_CAPTURE";
        TransactionStateEnum["PENDINGCREDIT"] = "PENDING_CREDIT";
        TransactionStateEnum["PENDINGGIROPAYINIT"] = "PENDING_GIROPAY_INIT";
        TransactionStateEnum["PENDINGIDEALINIT"] = "PENDING_IDEAL_INIT";
        TransactionStateEnum["PENDINGINIT"] = "PENDING_INIT";
        TransactionStateEnum["PENDINGREADY"] = "PENDING_READY";
        TransactionStateEnum["PENDINGRETURN"] = "PENDING_RETURN";
        TransactionStateEnum["PENDINGSETTLEMENT"] = "PENDING_SETTLEMENT";
        TransactionStateEnum["PENDINGSOFORTINIT"] = "PENDING_SOFORT_INIT";
        TransactionStateEnum["PENDINGVOID"] = "PENDING_VOID";
        TransactionStateEnum["READY"] = "READY";
        TransactionStateEnum["SETTLED"] = "SETTLED";
        TransactionStateEnum["VOIDED"] = "VOIDED";
        TransactionStateEnum["WAITING"] = "WAITING";
        TransactionStateEnum["WAITINGAUTHENTICATION"] = "WAITING_AUTHENTICATION";
        TransactionStateEnum["WAITING3DSECURE"] = "WAITING_3D_SECURE";
        TransactionStateEnum["WAITINGCLICKANDBUY"] = "WAITING_CLICK_AND_BUY";
        TransactionStateEnum["WAITINGGIROPAY"] = "WAITING_GIROPAY";
        TransactionStateEnum["WAITINGIDEAL"] = "WAITING_IDEAL";
        TransactionStateEnum["WAITINGKLARNA"] = "WAITING_KLARNA";
        TransactionStateEnum["WAITINGPAYPAL"] = "WAITING_PAYPAL";
        TransactionStateEnum["WAITINGPAYPALEVENT"] = "WAITING_PAYPAL_EVENT";
        TransactionStateEnum["WAITINGPPROLONGWAITING"] = "WAITING_PPRO_LONG_WAITING";
        TransactionStateEnum["WAITINGSOFORT"] = "WAITING_SOFORT";
        TransactionStateEnum["WAITINGTPAY"] = "WAITING_T_PAY";
        TransactionStateEnum["WAITINGALIPAYPAYSECURE"] = "WAITING_ALIPAY_PAYSECURE";
    })(TransactionStateEnum = Transaction.TransactionStateEnum || (Transaction.TransactionStateEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let SubmissionComponentEnum;
    (function (SubmissionComponentEnum) {
        SubmissionComponentEnum["API"] = "API";
        SubmissionComponentEnum["BUS"] = "BUS";
        SubmissionComponentEnum["CONNECT"] = "CONNECT";
        SubmissionComponentEnum["CORE"] = "CORE";
        SubmissionComponentEnum["EPAS"] = "EPAS";
        SubmissionComponentEnum["MCS"] = "MCS";
        SubmissionComponentEnum["RESTAPI"] = "RESTAPI";
        SubmissionComponentEnum["SWITCH"] = "SWITCH";
        SubmissionComponentEnum["VT"] = "VT";
    })(SubmissionComponentEnum = Transaction.SubmissionComponentEnum || (Transaction.SubmissionComponentEnum = {}));
})(Transaction = exports.Transaction || (exports.Transaction = {}));
/**
 * The source of the transaction. The possible values are ECOM (if the order was received via email or Internet), MAIL, PHONE and RETAIL (face to face).
 * @export
 * @enum {string}
 */
var TransactionOrigin;
(function (TransactionOrigin) {
    TransactionOrigin["ECOM"] = "ECOM";
    TransactionOrigin["MAIL"] = "MAIL";
    TransactionOrigin["PHONE"] = "PHONE";
    TransactionOrigin["RETAIL"] = "RETAIL";
})(TransactionOrigin = exports.TransactionOrigin || (exports.TransactionOrigin = {}));
/**
 * @export
 * @namespace TransactionResponse
 */
var TransactionResponse;
(function (TransactionResponse) {
    /**
     * @export
     * @enum {string}
     */
    let TransactionStatusEnum;
    (function (TransactionStatusEnum) {
        TransactionStatusEnum["APPROVED"] = "APPROVED";
        TransactionStatusEnum["WAITING"] = "WAITING";
        TransactionStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
        TransactionStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
        TransactionStatusEnum["DECLINED"] = "DECLINED";
    })(TransactionStatusEnum = TransactionResponse.TransactionStatusEnum || (TransactionResponse.TransactionStatusEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TransactionStateEnum;
    (function (TransactionStateEnum) {
        TransactionStateEnum["AUTHORIZED"] = "AUTHORIZED";
        TransactionStateEnum["CAPTURED"] = "CAPTURED";
        TransactionStateEnum["DECLINED"] = "DECLINED";
        TransactionStateEnum["CHECKED"] = "CHECKED";
        TransactionStateEnum["INITIALIZED"] = "INITIALIZED";
        TransactionStateEnum["PENDING"] = "PENDING";
        TransactionStateEnum["READY"] = "READY";
        TransactionStateEnum["SETTLED"] = "SETTLED";
        TransactionStateEnum["VOIDED"] = "VOIDED";
        TransactionStateEnum["WAITING"] = "WAITING";
    })(TransactionStateEnum = TransactionResponse.TransactionStateEnum || (TransactionResponse.TransactionStateEnum = {}));
})(TransactionResponse = exports.TransactionResponse || (exports.TransactionResponse = {}));
/**
 * Type of transaction to perform. Primary transaction types in requests include 'SALE', 'PREAUTH', 'CREDIT' and 'FORCED_TICKET'.
 * @export
 * @enum {string}
 */
var TransactionType;
(function (TransactionType) {
    TransactionType["SALE"] = "SALE";
    TransactionType["PREAUTH"] = "PREAUTH";
    TransactionType["CREDIT"] = "CREDIT";
    TransactionType["FORCEDTICKET"] = "FORCED_TICKET";
    TransactionType["VOID"] = "VOID";
    TransactionType["RETURN"] = "RETURN";
    TransactionType["POSTAUTH"] = "POSTAUTH";
    TransactionType["PAYERAUTH"] = "PAYER_AUTH";
})(TransactionType = exports.TransactionType || (exports.TransactionType = {}));
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
exports.AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling v1AuthenticationAccessTokensPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling v1AuthenticationAccessTokensPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling v1AuthenticationAccessTokensPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling v1AuthenticationAccessTokensPost.');
            }
            const localVarPath = `/v1/authentication/access-tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
exports.AuthenticationApiFp = function (configuration) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options) {
            const localVarAxiosArgs = exports.AuthenticationApiAxiosParamCreator(configuration).v1AuthenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
exports.AuthenticationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v1AuthenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options) {
            return exports.AuthenticationApiFp(configuration).v1AuthenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options)(axios, basePath);
        },
    };
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
class AuthenticationApi extends BaseAPI {
    /**
     * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
     * @summary Generate an access token for user authentication.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    v1AuthenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options) {
        return exports.AuthenticationApiFp(this.configuration).v1AuthenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options)(this.axios, this.basePath);
    }
}
exports.AuthenticationApi = AuthenticationApi;
/**
 * CardInfoLookupApi - axios parameter creator
 * @export
 */
exports.CardInfoLookupApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookUp
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Card information lookup payload.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'cardInfoLookupRequest' is not null or undefined
            if (cardInfoLookupRequest === null || cardInfoLookupRequest === undefined) {
                throw new RequiredError('cardInfoLookupRequest', 'Required parameter cardInfoLookupRequest was null or undefined when calling cardInfoLookup.');
            }
            const localVarPath = `/v1/card-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CardInfoLookupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(cardInfoLookupRequest || {}) : (cardInfoLookupRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CardInfoLookupApi - functional programming interface
 * @export
 */
exports.CardInfoLookupApiFp = function (configuration) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookUp
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Card information lookup payload.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.CardInfoLookupApiAxiosParamCreator(configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * CardInfoLookupApi - factory interface
 * @export
 */
exports.CardInfoLookupApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookUp
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Card information lookup payload.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options) {
            return exports.CardInfoLookupApiFp(configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * CardInfoLookupApi - object-oriented interface
 * @export
 * @class CardInfoLookupApi
 * @extends {BaseAPI}
 */
class CardInfoLookupApi extends BaseAPI {
    /**
     * Use this to look up card related information such as issuer country, card function and card brand.
     * @summary Card information lookUp
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardInfoLookupRequest} cardInfoLookupRequest Card information lookup payload.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardInfoLookupApi
     */
    cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options) {
        return exports.CardInfoLookupApiFp(this.configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.CardInfoLookupApi = CardInfoLookupApi;
/**
 * CardVerificationApi - axios parameter creator
 * @export
 */
exports.CardVerificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to perform card verification for a payment card.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'cardVerificationRequest' is not null or undefined
            if (cardVerificationRequest === null || cardVerificationRequest === undefined) {
                throw new RequiredError('cardVerificationRequest', 'Required parameter cardVerificationRequest was null or undefined when calling verifyCard.');
            }
            const localVarPath = `/v1/card-verification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CardVerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(cardVerificationRequest || {}) : (cardVerificationRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CardVerificationApi - functional programming interface
 * @export
 */
exports.CardVerificationApiFp = function (configuration) {
    return {
        /**
         * Use this to perform card verification for a payment card.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.CardVerificationApiAxiosParamCreator(configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * CardVerificationApi - factory interface
 * @export
 */
exports.CardVerificationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to perform card verification for a payment card.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options) {
            return exports.CardVerificationApiFp(configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * CardVerificationApi - object-oriented interface
 * @export
 * @class CardVerificationApi
 * @extends {BaseAPI}
 */
class CardVerificationApi extends BaseAPI {
    /**
     * Use this to perform card verification for a payment card.
     * @summary Verify a payment card.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardVerificationRequest} cardVerificationRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardVerificationApi
     */
    verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options) {
        return exports.CardVerificationApiFp(this.configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.CardVerificationApi = CardVerificationApi;
/**
 * CurrencyConversionApi - axios parameter creator
 * @export
 */
exports.CurrencyConversionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option
         * @summary Generate dynamic currency conversion transactions
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'exchangeRateRequest' is not null or undefined
            if (exchangeRateRequest === null || exchangeRateRequest === undefined) {
                throw new RequiredError('exchangeRateRequest', 'Required parameter exchangeRateRequest was null or undefined when calling getExchangeRate.');
            }
            const localVarPath = `/v1/exchange-rates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ExchangeRateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(exchangeRateRequest || {}) : (exchangeRateRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CurrencyConversionApi - functional programming interface
 * @export
 */
exports.CurrencyConversionApiFp = function (configuration) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option
         * @summary Generate dynamic currency conversion transactions
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.CurrencyConversionApiAxiosParamCreator(configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * CurrencyConversionApi - factory interface
 * @export
 */
exports.CurrencyConversionApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option
         * @summary Generate dynamic currency conversion transactions
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options) {
            return exports.CurrencyConversionApiFp(configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * CurrencyConversionApi - object-oriented interface
 * @export
 * @class CurrencyConversionApi
 * @extends {BaseAPI}
 */
class CurrencyConversionApi extends BaseAPI {
    /**
     * Sale, return and lookup exchange rate with dynamic currency conversion option
     * @summary Generate dynamic currency conversion transactions
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ExchangeRateRequest} exchangeRateRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyConversionApi
     */
    getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options) {
        return exports.CurrencyConversionApiFp(this.configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.CurrencyConversionApi = CurrencyConversionApi;
/**
 * FraudDetectApi - axios parameter creator
 * @export
 */
exports.FraudDetectApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'scoreOnlyRequest' is not null or undefined
            if (scoreOnlyRequest === null || scoreOnlyRequest === undefined) {
                throw new RequiredError('scoreOnlyRequest', 'Required parameter scoreOnlyRequest was null or undefined when calling scoreOnly.');
            }
            const localVarPath = `/v1/fraud/score-only`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ScoreOnlyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(scoreOnlyRequest || {}) : (scoreOnlyRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FraudDetectApi - functional programming interface
 * @export
 */
exports.FraudDetectApiFp = function (configuration) {
    return {
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.FraudDetectApiAxiosParamCreator(configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * FraudDetectApi - factory interface
 * @export
 */
exports.FraudDetectApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options) {
            return exports.FraudDetectApiFp(configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * FraudDetectApi - object-oriented interface
 * @export
 * @class FraudDetectApi
 * @extends {BaseAPI}
 */
class FraudDetectApi extends BaseAPI {
    /**
     * Use this to obtain a fraud score for a transaction.
     * @summary Score a transaction for fraud.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ScoreOnlyRequest} scoreOnlyRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options) {
        return exports.FraudDetectApiFp(this.configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.FraudDetectApi = FraudDetectApi;
/**
 * OrderApi - axios parameter creator
 * @export
 */
exports.OrderApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling orderInquiry.');
            }
            const localVarPath = `/v1/orders/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to capture/complete an order. Postauths and partial postauths are allowed.
         * @summary Capture/complete an already existing order.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPostAuth(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling orderPostAuth.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling orderPostAuth.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling orderPostAuth.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling orderPostAuth.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling orderPostAuth.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new RequiredError('secondaryTransaction', 'Required parameter secondaryTransaction was null or undefined when calling orderPostAuth.');
            }
            const localVarPath = `/v1/orders/{order-id}/postauth`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(secondaryTransaction || {}) : (secondaryTransaction || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this for Returns of an existing order. Partial Returns are allowed.
         * @summary Return/refund an order.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderReturnTransaction(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling orderReturnTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling orderReturnTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling orderReturnTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling orderReturnTransaction.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling orderReturnTransaction.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new RequiredError('secondaryTransaction', 'Required parameter secondaryTransaction was null or undefined when calling orderReturnTransaction.');
            }
            const localVarPath = `/v1/orders/{order-id}/return`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(secondaryTransaction || {}) : (secondaryTransaction || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrderApi - functional programming interface
 * @export
 */
exports.OrderApiFp = function (configuration) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.OrderApiAxiosParamCreator(configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to capture/complete an order. Postauths and partial postauths are allowed.
         * @summary Capture/complete an already existing order.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPostAuth(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.OrderApiAxiosParamCreator(configuration).orderPostAuth(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this for Returns of an existing order. Partial Returns are allowed.
         * @summary Return/refund an order.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderReturnTransaction(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.OrderApiAxiosParamCreator(configuration).orderReturnTransaction(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * OrderApi - factory interface
 * @export
 */
exports.OrderApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            return exports.OrderApiFp(configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to capture/complete an order. Postauths and partial postauths are allowed.
         * @summary Capture/complete an already existing order.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderPostAuth(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options) {
            return exports.OrderApiFp(configuration).orderPostAuth(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this for Returns of an existing order. Partial Returns are allowed.
         * @summary Return/refund an order.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderReturnTransaction(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options) {
            return exports.OrderApiFp(configuration).orderReturnTransaction(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options)(axios, basePath);
        },
    };
};
/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
class OrderApi extends BaseAPI {
    /**
     * Use this query to get the current state of an existing order.
     * @summary Retrieve the state of an order
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
        return exports.OrderApiFp(this.configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * Use this to capture/complete an order. Postauths and partial postauths are allowed.
     * @summary Capture/complete an already existing order.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId
     * @param {SecondaryTransaction} secondaryTransaction
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    orderPostAuth(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options) {
        return exports.OrderApiFp(this.configuration).orderPostAuth(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * Use this for Returns of an existing order. Partial Returns are allowed.
     * @summary Return/refund an order.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId
     * @param {SecondaryTransaction} secondaryTransaction
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    orderReturnTransaction(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options) {
        return exports.OrderApiFp(this.configuration).orderReturnTransaction(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
}
exports.OrderApi = OrderApi;
/**
 * PaymentApi - axios parameter creator
 * @export
 */
exports.PaymentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {AuthenticationResponseVerificationRequest} authenticationResponseVerificationRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationResponseVerificationRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'authenticationResponseVerificationRequest' is not null or undefined
            if (authenticationResponseVerificationRequest === null || authenticationResponseVerificationRequest === undefined) {
                throw new RequiredError('authenticationResponseVerificationRequest', 'Required parameter authenticationResponseVerificationRequest was null or undefined when calling finalizeSecureTransaction.');
            }
            const localVarPath = `/v1/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("AuthenticationResponseVerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(authenticationResponseVerificationRequest || {}) : (authenticationResponseVerificationRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to capture/complete an existing transaction. Partial postauths are allowed.
         * @summary Capture/complete a transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performPaymentPostAuthorisation(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling performPaymentPostAuthorisation.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling performPaymentPostAuthorisation.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling performPaymentPostAuthorisation.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling performPaymentPostAuthorisation.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling performPaymentPostAuthorisation.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new RequiredError('secondaryTransaction', 'Required parameter secondaryTransaction was null or undefined when calling performPaymentPostAuthorisation.');
            }
            const localVarPath = `/v1/payments/{transaction-id}/postauth`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(secondaryTransaction || {}) : (secondaryTransaction || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to originate a financial transaction, like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Primary Transaction request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        primaryPaymentTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling primaryPaymentTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling primaryPaymentTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling primaryPaymentTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling primaryPaymentTransaction.');
            }
            // verify required parameter 'primaryTransaction' is not null or undefined
            if (primaryTransaction === null || primaryTransaction === undefined) {
                throw new RequiredError('primaryTransaction', 'Required parameter primaryTransaction was null or undefined when calling primaryPaymentTransaction.');
            }
            const localVarPath = `/v1/payments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PrimaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(primaryTransaction || {}) : (primaryTransaction || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to return/refund an existing transaction.  Partial returns are allowed.
         * @summary Return/refund a transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling returnTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling returnTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling returnTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling returnTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling returnTransaction.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new RequiredError('secondaryTransaction', 'Required parameter secondaryTransaction was null or undefined when calling returnTransaction.');
            }
            const localVarPath = `/v1/payments/{transaction-id}/return`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(secondaryTransaction || {}) : (secondaryTransaction || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling transactionInquiry.');
            }
            const localVarPath = `/v1/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to reverse a postauth/completion, credit, preauth, or sale.
         * @summary Reverse a previous action on an existing transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling voidTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling voidTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling voidTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling voidTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling voidTransaction.');
            }
            const localVarPath = `/v1/payments/{transaction-id}/void`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentApi - functional programming interface
 * @export
 */
exports.PaymentApiFp = function (configuration) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {AuthenticationResponseVerificationRequest} authenticationResponseVerificationRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationResponseVerificationRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationResponseVerificationRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Used to capture/complete an existing transaction. Partial postauths are allowed.
         * @summary Capture/complete a transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performPaymentPostAuthorisation(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).performPaymentPostAuthorisation(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to originate a financial transaction, like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Primary Transaction request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        primaryPaymentTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options) {
            const localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).primaryPaymentTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to return/refund an existing transaction.  Partial returns are allowed.
         * @summary Return/refund a transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).returnTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to reverse a postauth/completion, credit, preauth, or sale.
         * @summary Reverse a previous action on an existing transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).voidTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentApi - factory interface
 * @export
 */
exports.PaymentApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {AuthenticationResponseVerificationRequest} authenticationResponseVerificationRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationResponseVerificationRequest, messageSignature, region, options) {
            return exports.PaymentApiFp(configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationResponseVerificationRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Used to capture/complete an existing transaction. Partial postauths are allowed.
         * @summary Capture/complete a transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        performPaymentPostAuthorisation(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
            return exports.PaymentApiFp(configuration).performPaymentPostAuthorisation(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to originate a financial transaction, like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Primary Transaction request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        primaryPaymentTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options) {
            return exports.PaymentApiFp(configuration).primaryPaymentTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to return/refund an existing transaction.  Partial returns are allowed.
         * @summary Return/refund a transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {SecondaryTransaction} secondaryTransaction
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
            return exports.PaymentApiFp(configuration).returnTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
            return exports.PaymentApiFp(configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to reverse a postauth/completion, credit, preauth, or sale.
         * @summary Reverse a previous action on an existing transaction.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
            return exports.PaymentApiFp(configuration).voidTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(axios, basePath);
        },
    };
};
/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
class PaymentApi extends BaseAPI {
    /**
     * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
     * @summary Update a 3DSecure or UnionPay payment and continue processing.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
     * @param {AuthenticationResponseVerificationRequest} authenticationResponseVerificationRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationResponseVerificationRequest, messageSignature, region, options) {
        return exports.PaymentApiFp(this.configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationResponseVerificationRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
    /**
     * Used to capture/complete an existing transaction. Partial postauths are allowed.
     * @summary Capture/complete a transaction.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
     * @param {SecondaryTransaction} secondaryTransaction
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    performPaymentPostAuthorisation(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
        return exports.PaymentApiFp(this.configuration).performPaymentPostAuthorisation(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * Use this to originate a financial transaction, like a sale, preauthorization, or credit.
     * @summary Generate a primary transaction.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PrimaryTransaction} primaryTransaction Primary Transaction request
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    primaryPaymentTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options) {
        return exports.PaymentApiFp(this.configuration).primaryPaymentTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options)(this.axios, this.basePath);
    }
    /**
     * Use this to return/refund an existing transaction.  Partial returns are allowed.
     * @summary Return/refund a transaction.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
     * @param {SecondaryTransaction} secondaryTransaction
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    returnTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
        return exports.PaymentApiFp(this.configuration).returnTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * Use this query to get the current state of an existing transaction.
     * @summary Retrieve the state of a transaction.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
        return exports.PaymentApiFp(this.configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * Use this to reverse a postauth/completion, credit, preauth, or sale.
     * @summary Reverse a previous action on an existing transaction.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    voidTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
        return exports.PaymentApiFp(this.configuration).voidTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
}
exports.PaymentApi = PaymentApi;
/**
 * PaymentSchedulesApi - axios parameter creator
 * @export
 */
exports.PaymentSchedulesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling cancelPaymentSchedule.');
            }
            const localVarPath = `/v1/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can be used to create a gateway payment schedule.
         * @summary Use this to create a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'paymentSchedulesRequest' is not null or undefined
            if (paymentSchedulesRequest === null || paymentSchedulesRequest === undefined) {
                throw new RequiredError('paymentSchedulesRequest', 'Required parameter paymentSchedulesRequest was null or undefined when calling createPaymentSchedule.');
            }
            const localVarPath = `/v1/payment-schedules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PaymentSchedulesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentSchedulesRequest || {}) : (paymentSchedulesRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can be used to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling inquiryPaymentSchedule.');
            }
            const localVarPath = `/v1/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can be used to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'paymentSchedulesRequest' is not null or undefined
            if (paymentSchedulesRequest === null || paymentSchedulesRequest === undefined) {
                throw new RequiredError('paymentSchedulesRequest', 'Required parameter paymentSchedulesRequest was null or undefined when calling updatePaymentSchedule.');
            }
            const localVarPath = `/v1/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PaymentSchedulesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentSchedulesRequest || {}) : (paymentSchedulesRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentSchedulesApi - functional programming interface
 * @export
 */
exports.PaymentSchedulesApiFp = function (configuration) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can be used to create a gateway payment schedule.
         * @summary Use this to create a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can be used to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This can be used to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentSchedulesApi - factory interface
 * @export
 */
exports.PaymentSchedulesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            return exports.PaymentSchedulesApiFp(configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * This can be used to create a gateway payment schedule.
         * @summary Use this to create a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options) {
            return exports.PaymentSchedulesApiFp(configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * This can be used to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            return exports.PaymentSchedulesApiFp(configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * This can be used to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, storeId, options) {
            return exports.PaymentSchedulesApiFp(configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, storeId, options)(axios, basePath);
        },
    };
};
/**
 * PaymentSchedulesApi - object-oriented interface
 * @export
 * @class PaymentSchedulesApi
 * @extends {BaseAPI}
 */
class PaymentSchedulesApi extends BaseAPI {
    /**
     * Use this to cancel an existing gateway payment schedule.
     * @summary Cancel a gateway payment schedule.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * This can be used to create a gateway payment schedule.
     * @summary Use this to create a gateway payment schedule.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
    /**
     * This can be used to view an existing gateway payment schedule.
     * @summary View a gateway payment schedule.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * This can be used to update a gateway payment schedule.
     * @summary Update a gateway payment schedule.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, storeId, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
}
exports.PaymentSchedulesApi = PaymentSchedulesApi;
/**
 * PaymentTokenApi - axios parameter creator
 * @export
 */
exports.PaymentTokenApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'paymentTokenizationRequest' is not null or undefined
            if (paymentTokenizationRequest === null || paymentTokenizationRequest === undefined) {
                throw new RequiredError('paymentTokenizationRequest', 'Required parameter paymentTokenizationRequest was null or undefined when calling createPaymentToken.');
            }
            const localVarPath = `/v1/payment-tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PaymentTokenizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentTokenizationRequest || {}) : (paymentTokenizationRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId', 'Required parameter tokenId was null or undefined when calling deletePaymentToken.');
            }
            const localVarPath = `/v1/payment-tokens/{token-id}`
                .replace(`{${"token-id"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentTokenApi - functional programming interface
 * @export
 */
exports.PaymentTokenApiFp = function (configuration) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options) {
            const localVarAxiosArgs = exports.PaymentTokenApiAxiosParamCreator(configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentTokenApiAxiosParamCreator(configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentTokenApi - factory interface
 * @export
 */
exports.PaymentTokenApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options) {
            return exports.PaymentTokenApiFp(configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options)(axios, basePath);
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
            return exports.PaymentTokenApiFp(configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(axios, basePath);
        },
    };
};
/**
 * PaymentTokenApi - object-oriented interface
 * @export
 * @class PaymentTokenApi
 * @extends {BaseAPI}
 */
class PaymentTokenApi extends BaseAPI {
    /**
     * Use this to create a payment token from a payment card.
     * @summary Create a payment token from a payment card.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentTokenizationRequest} paymentTokenizationRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options) {
        return exports.PaymentTokenApiFp(this.configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options)(this.axios, this.basePath);
    }
    /**
     * Use this to delete a payment token.
     * @summary Delete a payment token.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {string} [storeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
        return exports.PaymentTokenApiFp(this.configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(this.axios, this.basePath);
    }
}
exports.PaymentTokenApi = PaymentTokenApi;
/**
 * PaymentURLApi - axios parameter creator
 * @export
 */
exports.PaymentURLApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'paymentUrlRequest' is not null or undefined
            if (paymentUrlRequest === null || paymentUrlRequest === undefined) {
                throw new RequiredError('paymentUrlRequest', 'Required parameter paymentUrlRequest was null or undefined when calling createPaymentUrl.');
            }
            const localVarPath = `/v1/payment-url`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PaymentUrlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentUrlRequest || {}) : (paymentUrlRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentURLApi - functional programming interface
 * @export
 */
exports.PaymentURLApiFp = function (configuration) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.PaymentURLApiAxiosParamCreator(configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentURLApi - factory interface
 * @export
 */
exports.PaymentURLApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType content type
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] The region where client wants to process the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options) {
            return exports.PaymentURLApiFp(configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * PaymentURLApi - object-oriented interface
 * @export
 * @class PaymentURLApi
 * @extends {BaseAPI}
 */
class PaymentURLApi extends BaseAPI {
    /**
     * Use this to generate an embedding payment link.
     * @summary Create a payment URL.
     * @param {'application/json'} contentType content type
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentUrlRequest} paymentUrlRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256  algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] The region where client wants to process the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options) {
        return exports.PaymentURLApiFp(this.configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.PaymentURLApi = PaymentURLApi;
