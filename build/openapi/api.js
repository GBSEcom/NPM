"use strict";
// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Payment Gateway API Specification.
 * The documentation here is designed to provide all of the technical guidance required to consume and integrate with our APIs for payment processing. To learn more about our APIs please visit https://docs.firstdata.com/org/gateway.
 *
 * OpenAPI spec version: 6.9.1.20191223.002
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
const axios_1 = require("axios");
const BASE_PATH = "https://cert.api.firstdata.com/gateway/v2".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, axios = axios_1.default) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace AVSResponse
 */
var AVSResponse;
(function (AVSResponse) {
    /**
     * @export
     * @enum {string}
     */
    let StreetMatchEnum;
    (function (StreetMatchEnum) {
        StreetMatchEnum["Y"] = "Y";
        StreetMatchEnum["N"] = "N";
        StreetMatchEnum["NOINPUTDATA"] = "NO_INPUT_DATA";
        StreetMatchEnum["NOTCHECKED"] = "NOT_CHECKED";
    })(StreetMatchEnum = AVSResponse.StreetMatchEnum || (AVSResponse.StreetMatchEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let PostalCodeMatchEnum;
    (function (PostalCodeMatchEnum) {
        PostalCodeMatchEnum["Y"] = "Y";
        PostalCodeMatchEnum["N"] = "N";
        PostalCodeMatchEnum["NOINPUTDATA"] = "NO_INPUT_DATA";
        PostalCodeMatchEnum["NOTCHECKED"] = "NOT_CHECKED";
    })(PostalCodeMatchEnum = AVSResponse.PostalCodeMatchEnum || (AVSResponse.PostalCodeMatchEnum = {}));
})(AVSResponse = exports.AVSResponse || (exports.AVSResponse = {}));
/**
 * @export
 * @namespace AccessTokenResponse
 */
var AccessTokenResponse;
(function (AccessTokenResponse) {
    /**
     * @export
     * @enum {string}
     */
    let RequestStatusEnum;
    (function (RequestStatusEnum) {
        RequestStatusEnum["SUCCESS"] = "SUCCESS";
    })(RequestStatusEnum = AccessTokenResponse.RequestStatusEnum || (AccessTokenResponse.RequestStatusEnum = {}));
})(AccessTokenResponse = exports.AccessTokenResponse || (exports.AccessTokenResponse = {}));
/**
 * @export
 * @namespace AdditionalTransactionDetails
 */
var AdditionalTransactionDetails;
(function (AdditionalTransactionDetails) {
    /**
     * @export
     * @enum {string}
     */
    let DisbursementTransTypeEnum;
    (function (DisbursementTransTypeEnum) {
        DisbursementTransTypeEnum["FUNDING"] = "FUNDING";
        DisbursementTransTypeEnum["DISBURSEMENT"] = "DISBURSEMENT";
    })(DisbursementTransTypeEnum = AdditionalTransactionDetails.DisbursementTransTypeEnum || (AdditionalTransactionDetails.DisbursementTransTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let WalletProviderEnum;
    (function (WalletProviderEnum) {
        WalletProviderEnum["GOOGLEPAY"] = "GOOGLE_PAY";
        WalletProviderEnum["APPLEPAY"] = "APPLE_PAY";
        WalletProviderEnum["SAMSUNGPAY"] = "SAMSUNG_PAY";
    })(WalletProviderEnum = AdditionalTransactionDetails.WalletProviderEnum || (AdditionalTransactionDetails.WalletProviderEnum = {}));
})(AdditionalTransactionDetails = exports.AdditionalTransactionDetails || (exports.AdditionalTransactionDetails = {}));
/**
 * @export
 * @namespace Airline
 */
var Airline;
(function (Airline) {
    /**
     * @export
     * @enum {string}
     */
    let ReservationSystemEnum;
    (function (ReservationSystemEnum) {
        ReservationSystemEnum["START"] = "START";
        ReservationSystemEnum["TWA"] = "TWA";
        ReservationSystemEnum["DELTA"] = "DELTA";
        ReservationSystemEnum["SABRE"] = "SABRE";
        ReservationSystemEnum["COVIAAPOLLO"] = "COVIA_APOLLO";
        ReservationSystemEnum["DRBLANK"] = "DR_BLANK";
        ReservationSystemEnum["DER"] = "DER";
        ReservationSystemEnum["TUI"] = "TUI";
    })(ReservationSystemEnum = Airline.ReservationSystemEnum || (Airline.ReservationSystemEnum = {}));
})(Airline = exports.Airline || (exports.Airline = {}));
/**
 * @export
 * @namespace AirlineAncillaryServiceCategory
 */
var AirlineAncillaryServiceCategory;
(function (AirlineAncillaryServiceCategory) {
    /**
     * @export
     * @enum {string}
     */
    let ServiceCategoryEnum;
    (function (ServiceCategoryEnum) {
        ServiceCategoryEnum["BUNDLEDSERVICE"] = "BUNDLED_SERVICE";
        ServiceCategoryEnum["BAGGAGEFEE"] = "BAGGAGE_FEE";
        ServiceCategoryEnum["CHANGEFEE"] = "CHANGE_FEE";
        ServiceCategoryEnum["CARGO"] = "CARGO";
        ServiceCategoryEnum["CARBONOFFSET"] = "CARBON_OFFSET";
        ServiceCategoryEnum["FREQUENTFLYER"] = "FREQUENT_FLYER";
        ServiceCategoryEnum["GIFTCARD"] = "GIFT_CARD";
        ServiceCategoryEnum["GROUNDTRANSPORT"] = "GROUND_TRANSPORT";
        ServiceCategoryEnum["INFLIGHTENTERTAINMENT"] = "IN_FLIGHT_ENTERTAINMENT";
        ServiceCategoryEnum["LOUNGE"] = "LOUNGE";
        ServiceCategoryEnum["MEDICAL"] = "MEDICAL";
        ServiceCategoryEnum["MEALBEVERAGE"] = "MEAL_BEVERAGE";
        ServiceCategoryEnum["OTHER"] = "OTHER";
        ServiceCategoryEnum["PASSENGERASSISTFEE"] = "PASSENGER_ASSIST_FEE";
        ServiceCategoryEnum["PETS"] = "PETS";
        ServiceCategoryEnum["SEATFEES"] = "SEAT_FEES";
        ServiceCategoryEnum["STANDBY"] = "STANDBY";
        ServiceCategoryEnum["SERVICEFEE"] = "SERVICE_FEE";
        ServiceCategoryEnum["STORE"] = "STORE";
        ServiceCategoryEnum["TRAVELSERVICE"] = "TRAVEL_SERVICE";
        ServiceCategoryEnum["UNACCOMPANIEDTRAVEL"] = "UNACCOMPANIED_TRAVEL";
        ServiceCategoryEnum["UPGRADES"] = "UPGRADES";
        ServiceCategoryEnum["WIFI"] = "WI_FI";
    })(ServiceCategoryEnum = AirlineAncillaryServiceCategory.ServiceCategoryEnum || (AirlineAncillaryServiceCategory.ServiceCategoryEnum = {}));
})(AirlineAncillaryServiceCategory = exports.AirlineAncillaryServiceCategory || (exports.AirlineAncillaryServiceCategory = {}));
/**
 * @export
 * @namespace AirlineTravelRoute
 */
var AirlineTravelRoute;
(function (AirlineTravelRoute) {
    /**
     * @export
     * @enum {string}
     */
    let StopoverTypeEnum;
    (function (StopoverTypeEnum) {
        StopoverTypeEnum["DIRECT"] = "DIRECT";
        StopoverTypeEnum["STOPOVER"] = "STOPOVER";
    })(StopoverTypeEnum = AirlineTravelRoute.StopoverTypeEnum || (AirlineTravelRoute.StopoverTypeEnum = {}));
})(AirlineTravelRoute = exports.AirlineTravelRoute || (exports.AirlineTravelRoute = {}));
/**
 * @export
 * @namespace AliPay
 */
var AliPay;
(function (AliPay) {
    /**
     * @export
     * @enum {string}
     */
    let PaymentDataTypeEnum;
    (function (PaymentDataTypeEnum) {
        PaymentDataTypeEnum["BARCODE"] = "BARCODE";
        PaymentDataTypeEnum["QRCODE"] = "QRCODE";
    })(PaymentDataTypeEnum = AliPay.PaymentDataTypeEnum || (AliPay.PaymentDataTypeEnum = {}));
})(AliPay = exports.AliPay || (exports.AliPay = {}));
/**
 * @export
 * @namespace AuthenticationRedirect
 */
var AuthenticationRedirect;
(function (AuthenticationRedirect) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["SECURE3D"] = "SECURE_3D";
    })(TypeEnum = AuthenticationRedirect.TypeEnum || (AuthenticationRedirect.TypeEnum = {}));
})(AuthenticationRedirect = exports.AuthenticationRedirect || (exports.AuthenticationRedirect = {}));
/**
 * @export
 * @namespace BancontactQR
 */
var BancontactQR;
(function (BancontactQR) {
    /**
     * @export
     * @enum {string}
     */
    let TransactionRoutingMeansEnum;
    (function (TransactionRoutingMeansEnum) {
        TransactionRoutingMeansEnum["QRCode"] = "QR Code";
        TransactionRoutingMeansEnum["URLIntent"] = "URL Intent";
    })(TransactionRoutingMeansEnum = BancontactQR.TransactionRoutingMeansEnum || (BancontactQR.TransactionRoutingMeansEnum = {}));
})(BancontactQR = exports.BancontactQR || (exports.BancontactQR = {}));
/**
 * @export
 * @namespace CarRentalExtraCharges
 */
var CarRentalExtraCharges;
(function (CarRentalExtraCharges) {
    /**
     * @export
     * @enum {string}
     */
    let ChargeItemEnum;
    (function (ChargeItemEnum) {
        ChargeItemEnum["EXTRAMILEAGE"] = "EXTRA_MILEAGE";
        ChargeItemEnum["GAS"] = "GAS";
        ChargeItemEnum["LATERETURN"] = "LATE_RETURN";
        ChargeItemEnum["ONEWAYSERVICEFEE"] = "ONE_WAY_SERVICE_FEE";
        ChargeItemEnum["PARKINGVIOLATION"] = "PARKING_VIOLATION";
    })(ChargeItemEnum = CarRentalExtraCharges.ChargeItemEnum || (CarRentalExtraCharges.ChargeItemEnum = {}));
})(CarRentalExtraCharges = exports.CarRentalExtraCharges || (exports.CarRentalExtraCharges = {}));
/**
 * Card function. This field is required when performing transactions for Brazil merchants.
 * @export
 * @enum {string}
 */
var CardFunction;
(function (CardFunction) {
    CardFunction["CREDIT"] = "CREDIT";
    CardFunction["DEBIT"] = "DEBIT";
    CardFunction["PREPAID"] = "PREPAID";
    CardFunction["VOUCHER"] = "VOUCHER";
    CardFunction["UNDEFINED"] = "UNDEFINED";
})(CardFunction = exports.CardFunction || (exports.CardFunction = {}));
/**
 * @export
 * @namespace CardInfo
 */
var CardInfo;
(function (CardInfo) {
    /**
     * @export
     * @enum {string}
     */
    let CommercialCardEnum;
    (function (CommercialCardEnum) {
        CommercialCardEnum["CORPORATE"] = "CORPORATE";
        CommercialCardEnum["NONCORPORATE"] = "NON_CORPORATE";
    })(CommercialCardEnum = CardInfo.CommercialCardEnum || (CardInfo.CommercialCardEnum = {}));
})(CardInfo = exports.CardInfo || (exports.CardInfo = {}));
/**
 * @export
 * @namespace CardInfoLookupResponse
 */
var CardInfoLookupResponse;
(function (CardInfoLookupResponse) {
    /**
     * @export
     * @enum {string}
     */
    let RequestStatusEnum;
    (function (RequestStatusEnum) {
        RequestStatusEnum["SUCCESS"] = "SUCCESS";
        RequestStatusEnum["LISTEMPTY"] = "LIST_EMPTY";
    })(RequestStatusEnum = CardInfoLookupResponse.RequestStatusEnum || (CardInfoLookupResponse.RequestStatusEnum = {}));
})(CardInfoLookupResponse = exports.CardInfoLookupResponse || (exports.CardInfoLookupResponse = {}));
/**
 * @export
 * @namespace ChinaDomesticPaymentMethod
 */
var ChinaDomesticPaymentMethod;
(function (ChinaDomesticPaymentMethod) {
    /**
     * @export
     * @enum {string}
     */
    let BrandEnum;
    (function (BrandEnum) {
        BrandEnum["ALIPAYDOMESTIC"] = "ALIPAY_DOMESTIC";
        BrandEnum["CUPDOMESTIC"] = "CUP_DOMESTIC";
        BrandEnum["WECHATDOMESTIC"] = "WECHAT_DOMESTIC";
    })(BrandEnum = ChinaDomesticPaymentMethod.BrandEnum || (ChinaDomesticPaymentMethod.BrandEnum = {}));
})(ChinaDomesticPaymentMethod = exports.ChinaDomesticPaymentMethod || (exports.ChinaDomesticPaymentMethod = {}));
/**
 * @export
 * @namespace Customer
 */
var Customer;
(function (Customer) {
    /**
     * @export
     * @enum {string}
     */
    let GenderEnum;
    (function (GenderEnum) {
        GenderEnum["Male"] = "male";
        GenderEnum["Female"] = "female";
        GenderEnum["Other"] = "other";
    })(GenderEnum = Customer.GenderEnum || (Customer.GenderEnum = {}));
})(Customer = exports.Customer || (exports.Customer = {}));
/**
 * @export
 * @namespace Device
 */
var Device;
(function (Device) {
    /**
     * @export
     * @enum {string}
     */
    let DeviceTypeEnum;
    (function (DeviceTypeEnum) {
        DeviceTypeEnum["Pos"] = "device/pos";
        DeviceTypeEnum["Mobile"] = "device/mobile";
    })(DeviceTypeEnum = Device.DeviceTypeEnum || (Device.DeviceTypeEnum = {}));
})(Device = exports.Device || (exports.Device = {}));
/**
 * @export
 * @namespace Document
 */
var Document;
(function (Document) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["NATIONALIDENTITY"] = "NATIONAL_IDENTITY";
        TypeEnum["SINGLETAXIDENTIFICATION"] = "SINGLE_TAX_IDENTIFICATION";
        TypeEnum["SINGLECODEOFLABORIDENTIFICATION"] = "SINGLE_CODE_OF_LABOR_IDENTIFICATION";
        TypeEnum["BOOKENLISTMENT"] = "BOOK_ENLISTMENT";
        TypeEnum["CIVICNOTEBOOK"] = "CIVIC_NOTEBOOK";
        TypeEnum["PASSPORT"] = "PASSPORT";
    })(TypeEnum = Document.TypeEnum || (Document.TypeEnum = {}));
})(Document = exports.Document || (exports.Document = {}));
/**
 * @export
 * @namespace EncryptedApplePay
 */
var EncryptedApplePay;
(function (EncryptedApplePay) {
    /**
     * @export
     * @enum {string}
     */
    let VersionEnum;
    (function (VersionEnum) {
        VersionEnum["ECV1"] = "EC_v1";
    })(VersionEnum = EncryptedApplePay.VersionEnum || (EncryptedApplePay.VersionEnum = {}));
})(EncryptedApplePay = exports.EncryptedApplePay || (exports.EncryptedApplePay = {}));
/**
 * @export
 * @namespace FraudRegistrationDevice
 */
var FraudRegistrationDevice;
(function (FraudRegistrationDevice) {
    /**
     * @export
     * @enum {string}
     */
    let DeviceTypeEnum;
    (function (DeviceTypeEnum) {
        DeviceTypeEnum["Pos"] = "device/pos";
        DeviceTypeEnum["Mobile"] = "device/mobile";
    })(DeviceTypeEnum = FraudRegistrationDevice.DeviceTypeEnum || (FraudRegistrationDevice.DeviceTypeEnum = {}));
})(FraudRegistrationDevice = exports.FraudRegistrationDevice || (exports.FraudRegistrationDevice = {}));
/**
 * @export
 * @namespace FraudRegistrationDeviceItems
 */
var FraudRegistrationDeviceItems;
(function (FraudRegistrationDeviceItems) {
    /**
     * @export
     * @enum {string}
     */
    let NetworkTypeEnum;
    (function (NetworkTypeEnum) {
        NetworkTypeEnum["Mobile"] = "network/mobile";
        NetworkTypeEnum["Wifi"] = "network/wifi";
    })(NetworkTypeEnum = FraudRegistrationDeviceItems.NetworkTypeEnum || (FraudRegistrationDeviceItems.NetworkTypeEnum = {}));
})(FraudRegistrationDeviceItems = exports.FraudRegistrationDeviceItems || (exports.FraudRegistrationDeviceItems = {}));
/**
 * @export
 * @namespace FraudRegistrationResponse
 */
var FraudRegistrationResponse;
(function (FraudRegistrationResponse) {
    /**
     * @export
     * @enum {string}
     */
    let TransactionStatusEnum;
    (function (TransactionStatusEnum) {
        TransactionStatusEnum["ScoredSuccessfully"] = "Scored successfully";
        TransactionStatusEnum["NotProcessed"] = "Not Processed";
    })(TransactionStatusEnum = FraudRegistrationResponse.TransactionStatusEnum || (FraudRegistrationResponse.TransactionStatusEnum = {}));
})(FraudRegistrationResponse = exports.FraudRegistrationResponse || (exports.FraudRegistrationResponse = {}));
/**
 * @export
 * @namespace Frequency
 */
var Frequency;
(function (Frequency) {
    /**
     * @export
     * @enum {string}
     */
    let UnitEnum;
    (function (UnitEnum) {
        UnitEnum["DAY"] = "DAY";
        UnitEnum["WEEK"] = "WEEK";
        UnitEnum["MONTH"] = "MONTH";
        UnitEnum["YEAR"] = "YEAR";
    })(UnitEnum = Frequency.UnitEnum || (Frequency.UnitEnum = {}));
})(Frequency = exports.Frequency || (exports.Frequency = {}));
/**
 * @export
 * @namespace InstallmentOptions
 */
var InstallmentOptions;
(function (InstallmentOptions) {
    /**
     * @export
     * @enum {string}
     */
    let RecurringTypeEnum;
    (function (RecurringTypeEnum) {
        RecurringTypeEnum["FIRST"] = "FIRST";
        RecurringTypeEnum["REPEAT"] = "REPEAT";
        RecurringTypeEnum["STANDINGINSTRUCTION"] = "STANDING_INSTRUCTION";
    })(RecurringTypeEnum = InstallmentOptions.RecurringTypeEnum || (InstallmentOptions.RecurringTypeEnum = {}));
})(InstallmentOptions = exports.InstallmentOptions || (exports.InstallmentOptions = {}));
/**
 * @export
 * @namespace IssuerResponse
 */
var IssuerResponse;
(function (IssuerResponse) {
    /**
     * @export
     * @enum {string}
     */
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum["Approved"] = "approved";
        StatusEnum["Declined"] = "declined";
        StatusEnum["Disabled"] = "disabled";
        StatusEnum["Unknown"] = "unknown";
    })(StatusEnum = IssuerResponse.StatusEnum || (IssuerResponse.StatusEnum = {}));
})(IssuerResponse = exports.IssuerResponse || (exports.IssuerResponse = {}));
/**
 * @export
 * @namespace Items
 */
var Items;
(function (Items) {
    /**
     * @export
     * @enum {string}
     */
    let NetworkTypeEnum;
    (function (NetworkTypeEnum) {
        NetworkTypeEnum["Mobile"] = "network/mobile";
        NetworkTypeEnum["Wifi"] = "network/wifi";
    })(NetworkTypeEnum = Items.NetworkTypeEnum || (Items.NetworkTypeEnum = {}));
})(Items = exports.Items || (exports.Items = {}));
/**
 * @export
 * @namespace LodgingExtraCharges
 */
var LodgingExtraCharges;
(function (LodgingExtraCharges) {
    /**
     * @export
     * @enum {string}
     */
    let ChargeItemEnum;
    (function (ChargeItemEnum) {
        ChargeItemEnum["GIFTSHOP"] = "GIFT_SHOP";
        ChargeItemEnum["LAUNDRY"] = "LAUNDRY";
        ChargeItemEnum["MINIBAR"] = "MINI_BAR";
        ChargeItemEnum["RESTAURANT"] = "RESTAURANT";
        ChargeItemEnum["TELEPHONE"] = "TELEPHONE";
        ChargeItemEnum["OTHER"] = "OTHER";
    })(ChargeItemEnum = LodgingExtraCharges.ChargeItemEnum || (LodgingExtraCharges.ChargeItemEnum = {}));
})(LodgingExtraCharges = exports.LodgingExtraCharges || (exports.LodgingExtraCharges = {}));
/**
 * @export
 * @namespace Method
 */
var Method;
(function (Method) {
    /**
     * @export
     * @enum {string}
     */
    let MethodTypeEnum;
    (function (MethodTypeEnum) {
        MethodTypeEnum["Card"] = "method/card";
        MethodTypeEnum["Wallet"] = "method/wallet";
    })(MethodTypeEnum = Method.MethodTypeEnum || (Method.MethodTypeEnum = {}));
})(Method = exports.Method || (exports.Method = {}));
/**
 * @export
 * @namespace Payment
 */
var Payment;
(function (Payment) {
    /**
     * @export
     * @enum {string}
     */
    let PaymentTypeEnum;
    (function (PaymentTypeEnum) {
        PaymentTypeEnum["Card"] = "payment/card";
        PaymentTypeEnum["Wallet"] = "payment/wallet";
    })(PaymentTypeEnum = Payment.PaymentTypeEnum || (Payment.PaymentTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let EntryMethodEnum;
    (function (EntryMethodEnum) {
        EntryMethodEnum["Manual"] = "manual";
        EntryMethodEnum["Stripe"] = "stripe";
        EntryMethodEnum["Ocr"] = "ocr";
        EntryMethodEnum["Emv"] = "emv";
        EntryMethodEnum["Nfc"] = "nfc";
        EntryMethodEnum["Remote"] = "remote";
        EntryMethodEnum["PinPresent"] = "pin_present";
    })(EntryMethodEnum = Payment.EntryMethodEnum || (Payment.EntryMethodEnum = {}));
})(Payment = exports.Payment || (exports.Payment = {}));
/**
 * @export
 * @namespace PaymentDevice
 */
var PaymentDevice;
(function (PaymentDevice) {
    /**
     * @export
     * @enum {string}
     */
    let DeviceTypeEnum;
    (function (DeviceTypeEnum) {
        DeviceTypeEnum["SWIPE"] = "SWIPE";
    })(DeviceTypeEnum = PaymentDevice.DeviceTypeEnum || (PaymentDevice.DeviceTypeEnum = {}));
})(PaymentDevice = exports.PaymentDevice || (exports.PaymentDevice = {}));
/**
 * Type of payment method.
 * @export
 * @enum {string}
 */
var PaymentMethodType;
(function (PaymentMethodType) {
    PaymentMethodType["ALIPAY"] = "ALIPAY";
    PaymentMethodType["ALIPAYPAYSECUREUS"] = "ALIPAY_PAYSECURE_US";
    PaymentMethodType["ALIPAYDOMESTIC"] = "ALIPAY_DOMESTIC";
    PaymentMethodType["APM"] = "APM";
    PaymentMethodType["CUPDOMESTIC"] = "CUP_DOMESTIC";
    PaymentMethodType["DEBITDE"] = "DEBITDE";
    PaymentMethodType["EMI"] = "EMI";
    PaymentMethodType["GIROPAY"] = "GIROPAY";
    PaymentMethodType["IDEAL"] = "IDEAL";
    PaymentMethodType["INDIAWALLET"] = "INDIAWALLET";
    PaymentMethodType["KLARNA"] = "KLARNA";
    PaymentMethodType["KPS"] = "KPS";
    PaymentMethodType["NETBANKING"] = "NETBANKING";
    PaymentMethodType["PAYMENTCARD"] = "PAYMENT_CARD";
    PaymentMethodType["PAYMENTTOKEN"] = "PAYMENT_TOKEN";
    PaymentMethodType["PAYPAL"] = "PAYPAL";
    PaymentMethodType["SEPA"] = "SEPA";
    PaymentMethodType["SOFORT"] = "SOFORT";
    PaymentMethodType["WALLET"] = "WALLET";
    PaymentMethodType["WECHATDOMESTIC"] = "WECHAT_DOMESTIC";
})(PaymentMethodType = exports.PaymentMethodType || (exports.PaymentMethodType = {}));
/**
 * @export
 * @namespace PaymentSchedulesResponse
 */
var PaymentSchedulesResponse;
(function (PaymentSchedulesResponse) {
    /**
     * @export
     * @enum {string}
     */
    let RequestStatusEnum;
    (function (RequestStatusEnum) {
        RequestStatusEnum["SUCCESS"] = "SUCCESS";
        RequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
        RequestStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
        RequestStatusEnum["FAILURE"] = "FAILURE";
        RequestStatusEnum["DECLINED"] = "DECLINED";
    })(RequestStatusEnum = PaymentSchedulesResponse.RequestStatusEnum || (PaymentSchedulesResponse.RequestStatusEnum = {}));
})(PaymentSchedulesResponse = exports.PaymentSchedulesResponse || (exports.PaymentSchedulesResponse = {}));
/**
 * @export
 * @namespace PaymentTokenizationResponse
 */
var PaymentTokenizationResponse;
(function (PaymentTokenizationResponse) {
    /**
     * @export
     * @enum {string}
     */
    let RequestStatusEnum;
    (function (RequestStatusEnum) {
        RequestStatusEnum["DELETED"] = "DELETED";
        RequestStatusEnum["FAILED"] = "FAILED";
        RequestStatusEnum["SUCCESS"] = "SUCCESS";
        RequestStatusEnum["APPROVED"] = "APPROVED";
        RequestStatusEnum["WAITING"] = "WAITING";
        RequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
        RequestStatusEnum["DECLINED"] = "DECLINED";
    })(RequestStatusEnum = PaymentTokenizationResponse.RequestStatusEnum || (PaymentTokenizationResponse.RequestStatusEnum = {}));
})(PaymentTokenizationResponse = exports.PaymentTokenizationResponse || (exports.PaymentTokenizationResponse = {}));
/**
 * @export
 * @namespace PaymentUrlResponse
 */
var PaymentUrlResponse;
(function (PaymentUrlResponse) {
    /**
     * @export
     * @enum {string}
     */
    let RequestStatusEnum;
    (function (RequestStatusEnum) {
        RequestStatusEnum["SUCCESS"] = "SUCCESS";
        RequestStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
        RequestStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
        RequestStatusEnum["FAILURE"] = "FAILURE";
    })(RequestStatusEnum = PaymentUrlResponse.RequestStatusEnum || (PaymentUrlResponse.RequestStatusEnum = {}));
})(PaymentUrlResponse = exports.PaymentUrlResponse || (exports.PaymentUrlResponse = {}));
/**
 * The status of payment URL.
 * @export
 * @enum {string}
 */
var PaymentUrlStatus;
(function (PaymentUrlStatus) {
    PaymentUrlStatus["Created"] = "Created";
    PaymentUrlStatus["Used"] = "Used";
    PaymentUrlStatus["Expired"] = "Expired";
    PaymentUrlStatus["Cancelled"] = "Cancelled";
})(PaymentUrlStatus = exports.PaymentUrlStatus || (exports.PaymentUrlStatus = {}));
/**
 * @export
 * @namespace ProcessorData
 */
var ProcessorData;
(function (ProcessorData) {
    /**
     * @export
     * @enum {string}
     */
    let SecurityCodeResponseEnum;
    (function (SecurityCodeResponseEnum) {
        SecurityCodeResponseEnum["MATCHED"] = "MATCHED";
        SecurityCodeResponseEnum["NOTMATCHED"] = "NOT_MATCHED";
        SecurityCodeResponseEnum["NOTPROCESSED"] = "NOT_PROCESSED";
        SecurityCodeResponseEnum["NOTPRESENT"] = "NOT_PRESENT";
        SecurityCodeResponseEnum["NOTCERTIFIED"] = "NOT_CERTIFIED";
        SecurityCodeResponseEnum["NOTCHECKED"] = "NOT_CHECKED";
    })(SecurityCodeResponseEnum = ProcessorData.SecurityCodeResponseEnum || (ProcessorData.SecurityCodeResponseEnum = {}));
})(ProcessorData = exports.ProcessorData || (exports.ProcessorData = {}));
/**
 * @export
 * @namespace RecurringPaymentDetails
 */
var RecurringPaymentDetails;
(function (RecurringPaymentDetails) {
    /**
     * @export
     * @enum {string}
     */
    let StateEnum;
    (function (StateEnum) {
        StateEnum["Installed"] = "Installed";
        StateEnum["Inactivated"] = "Inactivated";
        StateEnum["Cancelled"] = "Cancelled";
    })(StateEnum = RecurringPaymentDetails.StateEnum || (RecurringPaymentDetails.StateEnum = {}));
})(RecurringPaymentDetails = exports.RecurringPaymentDetails || (exports.RecurringPaymentDetails = {}));
/**
 * @export
 * @namespace RegistrationMethod
 */
var RegistrationMethod;
(function (RegistrationMethod) {
    /**
     * @export
     * @enum {string}
     */
    let MethodTypeEnum;
    (function (MethodTypeEnum) {
        MethodTypeEnum["Card"] = "method/card";
        MethodTypeEnum["Wallet"] = "method/wallet";
    })(MethodTypeEnum = RegistrationMethod.MethodTypeEnum || (RegistrationMethod.MethodTypeEnum = {}));
})(RegistrationMethod = exports.RegistrationMethod || (exports.RegistrationMethod = {}));
/**
 * The type of the response.
 * @export
 * @enum {string}
 */
var ResponseType;
(function (ResponseType) {
    ResponseType["BadRequest"] = "BadRequest";
    ResponseType["Unauthenticated"] = "Unauthenticated";
    ResponseType["Unauthorized"] = "Unauthorized";
    ResponseType["NotFound"] = "NotFound";
    ResponseType["GatewayDeclined"] = "GatewayDeclined";
    ResponseType["EndpointDeclined"] = "EndpointDeclined";
    ResponseType["ServerError"] = "ServerError";
    ResponseType["EndpointCommunicationError"] = "EndpointCommunicationError";
    ResponseType["UnsupportedMediaType"] = "UnsupportedMediaType";
})(ResponseType = exports.ResponseType || (exports.ResponseType = {}));
/**
 * @export
 * @namespace ScoreOnlyRequest
 */
var ScoreOnlyRequest;
(function (ScoreOnlyRequest) {
    /**
     * @export
     * @enum {string}
     */
    let OriginalTransactionTypeEnum;
    (function (OriginalTransactionTypeEnum) {
        OriginalTransactionTypeEnum["Authorization"] = "transaction/authorization";
        OriginalTransactionTypeEnum["AuthorizationReversal"] = "transaction/authorization-reversal";
        OriginalTransactionTypeEnum["Deposit"] = "transaction/deposit";
        OriginalTransactionTypeEnum["DepositReversal"] = "transaction/deposit-reversal";
        OriginalTransactionTypeEnum["Purchase"] = "transaction/purchase";
        OriginalTransactionTypeEnum["PurchaseReversal"] = "transaction/purchase-reversal";
        OriginalTransactionTypeEnum["RefundAuthorization"] = "transaction/refund-authorization";
        OriginalTransactionTypeEnum["RefundDeposit"] = "transaction/refund-deposit";
        OriginalTransactionTypeEnum["Verification"] = "transaction/verification";
        OriginalTransactionTypeEnum["BalanceInquiry"] = "transaction/balance-inquiry";
    })(OriginalTransactionTypeEnum = ScoreOnlyRequest.OriginalTransactionTypeEnum || (ScoreOnlyRequest.OriginalTransactionTypeEnum = {}));
})(ScoreOnlyRequest = exports.ScoreOnlyRequest || (exports.ScoreOnlyRequest = {}));
/**
 * @export
 * @namespace ScoreOnlyResponse
 */
var ScoreOnlyResponse;
(function (ScoreOnlyResponse) {
    /**
     * @export
     * @enum {string}
     */
    let TransactionStatusEnum;
    (function (TransactionStatusEnum) {
        TransactionStatusEnum["ScoredSuccessfully"] = "Scored successfully";
        TransactionStatusEnum["NotProcessed"] = "Not Processed";
    })(TransactionStatusEnum = ScoreOnlyResponse.TransactionStatusEnum || (ScoreOnlyResponse.TransactionStatusEnum = {}));
})(ScoreOnlyResponse = exports.ScoreOnlyResponse || (exports.ScoreOnlyResponse = {}));
/**
 * @export
 * @namespace Secure3D10AuthenticationResult
 */
var Secure3D10AuthenticationResult;
(function (Secure3D10AuthenticationResult) {
    /**
     * @export
     * @enum {string}
     */
    let VerificationResponseEnum;
    (function (VerificationResponseEnum) {
        VerificationResponseEnum["Y"] = "Y";
        VerificationResponseEnum["N"] = "N";
        VerificationResponseEnum["U"] = "U";
    })(VerificationResponseEnum = Secure3D10AuthenticationResult.VerificationResponseEnum || (Secure3D10AuthenticationResult.VerificationResponseEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let AuthenticationAttemptResultEnum;
    (function (AuthenticationAttemptResultEnum) {
        AuthenticationAttemptResultEnum["Y"] = "Y";
        AuthenticationAttemptResultEnum["N"] = "N";
        AuthenticationAttemptResultEnum["U"] = "U";
        AuthenticationAttemptResultEnum["A"] = "A";
    })(AuthenticationAttemptResultEnum = Secure3D10AuthenticationResult.AuthenticationAttemptResultEnum || (Secure3D10AuthenticationResult.AuthenticationAttemptResultEnum = {}));
})(Secure3D10AuthenticationResult = exports.Secure3D10AuthenticationResult || (exports.Secure3D10AuthenticationResult = {}));
/**
 * @export
 * @namespace Secure3D21AuthenticationResult
 */
var Secure3D21AuthenticationResult;
(function (Secure3D21AuthenticationResult) {
    /**
     * @export
     * @enum {string}
     */
    let AuthenticationResponseEnum;
    (function (AuthenticationResponseEnum) {
        AuthenticationResponseEnum["A"] = "A";
        AuthenticationResponseEnum["N"] = "N";
        AuthenticationResponseEnum["U"] = "U";
        AuthenticationResponseEnum["Y"] = "Y";
        AuthenticationResponseEnum["C"] = "C";
        AuthenticationResponseEnum["R"] = "R";
    })(AuthenticationResponseEnum = Secure3D21AuthenticationResult.AuthenticationResponseEnum || (Secure3D21AuthenticationResult.AuthenticationResponseEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TransactionStatusEnum;
    (function (TransactionStatusEnum) {
        TransactionStatusEnum["A"] = "A";
        TransactionStatusEnum["N"] = "N";
        TransactionStatusEnum["U"] = "U";
        TransactionStatusEnum["Y"] = "Y";
        TransactionStatusEnum["C"] = "C";
        TransactionStatusEnum["R"] = "R";
    })(TransactionStatusEnum = Secure3D21AuthenticationResult.TransactionStatusEnum || (Secure3D21AuthenticationResult.TransactionStatusEnum = {}));
})(Secure3D21AuthenticationResult = exports.Secure3D21AuthenticationResult || (exports.Secure3D21AuthenticationResult = {}));
/**
 * @export
 * @namespace SepaMandate
 */
var SepaMandate;
(function (SepaMandate) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum["SINGLE"] = "SINGLE";
        TypeEnum["FIRSTCOLLECTION"] = "FIRST_COLLECTION";
        TypeEnum["RECURRINGCOLLECTION"] = "RECURRING_COLLECTION";
        TypeEnum["FINALCOLLECTION"] = "FINAL_COLLECTION";
    })(TypeEnum = SepaMandate.TypeEnum || (SepaMandate.TypeEnum = {}));
})(SepaMandate = exports.SepaMandate || (exports.SepaMandate = {}));
/**
 * @export
 * @namespace StoredCredential
 */
var StoredCredential;
(function (StoredCredential) {
    /**
     * @export
     * @enum {string}
     */
    let SequenceEnum;
    (function (SequenceEnum) {
        SequenceEnum["FIRST"] = "FIRST";
        SequenceEnum["SUBSEQUENT"] = "SUBSEQUENT";
    })(SequenceEnum = StoredCredential.SequenceEnum || (StoredCredential.SequenceEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let InitiatorEnum;
    (function (InitiatorEnum) {
        InitiatorEnum["MERCHANT"] = "MERCHANT";
        InitiatorEnum["CARDHOLDER"] = "CARDHOLDER";
    })(InitiatorEnum = StoredCredential.InitiatorEnum || (StoredCredential.InitiatorEnum = {}));
})(StoredCredential = exports.StoredCredential || (exports.StoredCredential = {}));
/**
 * The source of the transaction. The possible values are ECOM (if the order was received via email or Internet), MAIL, PHONE and RETAIL (face to face).
 * @export
 * @enum {string}
 */
var TransactionOrigin;
(function (TransactionOrigin) {
    TransactionOrigin["ECOM"] = "ECOM";
    TransactionOrigin["MAIL"] = "MAIL";
    TransactionOrigin["PHONE"] = "PHONE";
    TransactionOrigin["RETAIL"] = "RETAIL";
})(TransactionOrigin = exports.TransactionOrigin || (exports.TransactionOrigin = {}));
/**
 * @export
 * @namespace TransactionResponse
 */
var TransactionResponse;
(function (TransactionResponse) {
    /**
     * @export
     * @enum {string}
     */
    let TransactionStatusEnum;
    (function (TransactionStatusEnum) {
        TransactionStatusEnum["APPROVED"] = "APPROVED";
        TransactionStatusEnum["WAITING"] = "WAITING";
        TransactionStatusEnum["VALIDATIONFAILED"] = "VALIDATION_FAILED";
        TransactionStatusEnum["PROCESSINGFAILED"] = "PROCESSING_FAILED";
        TransactionStatusEnum["DECLINED"] = "DECLINED";
    })(TransactionStatusEnum = TransactionResponse.TransactionStatusEnum || (TransactionResponse.TransactionStatusEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TransactionStateEnum;
    (function (TransactionStateEnum) {
        TransactionStateEnum["AUTHORIZED"] = "AUTHORIZED";
        TransactionStateEnum["CAPTURED"] = "CAPTURED";
        TransactionStateEnum["DECLINED"] = "DECLINED";
        TransactionStateEnum["CHECKED"] = "CHECKED";
        TransactionStateEnum["COMPLETEDGET"] = "COMPLETED_GET";
        TransactionStateEnum["INITIALIZED"] = "INITIALIZED";
        TransactionStateEnum["PENDING"] = "PENDING";
        TransactionStateEnum["READY"] = "READY";
        TransactionStateEnum["TEMPLATE"] = "TEMPLATE";
        TransactionStateEnum["SETTLED"] = "SETTLED";
        TransactionStateEnum["VOIDED"] = "VOIDED";
        TransactionStateEnum["WAITING"] = "WAITING";
    })(TransactionStateEnum = TransactionResponse.TransactionStateEnum || (TransactionResponse.TransactionStateEnum = {}));
})(TransactionResponse = exports.TransactionResponse || (exports.TransactionResponse = {}));
/**
 * Type of transaction to perform. Primary transaction types in requests include 'SALE', 'PREAUTH', 'CREDIT' and 'FORCED_TICKET'.
 * @export
 * @enum {string}
 */
var TransactionType;
(function (TransactionType) {
    TransactionType["SALE"] = "SALE";
    TransactionType["PREAUTH"] = "PREAUTH";
    TransactionType["CREDIT"] = "CREDIT";
    TransactionType["FORCEDTICKET"] = "FORCED_TICKET";
    TransactionType["VOID"] = "VOID";
    TransactionType["RETURN"] = "RETURN";
    TransactionType["POSTAUTH"] = "POSTAUTH";
    TransactionType["PAYERAUTH"] = "PAYER_AUTH";
    TransactionType["DISBURSEMENT"] = "DISBURSEMENT";
})(TransactionType = exports.TransactionType || (exports.TransactionType = {}));
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
exports.AuthenticationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling authenticationAccessTokensPost.');
            }
            const localVarPath = `/authentication/access-tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
exports.AuthenticationApiFp = function (configuration) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options) {
            const localVarAxiosArgs = exports.AuthenticationApiAxiosParamCreator(configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
exports.AuthenticationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options) {
            return exports.AuthenticationApiFp(configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options)(axios, basePath);
        },
    };
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
class AuthenticationApi extends BaseAPI {
    /**
     * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
     * @summary Generate an access token for user authentication.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options) {
        return exports.AuthenticationApiFp(this.configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, messageSignature, options)(this.axios, this.basePath);
    }
}
exports.AuthenticationApi = AuthenticationApi;
/**
 * CardInfoLookupApi - axios parameter creator
 * @export
 */
exports.CardInfoLookupApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'cardInfoLookupRequest' is not null or undefined
            if (cardInfoLookupRequest === null || cardInfoLookupRequest === undefined) {
                throw new RequiredError('cardInfoLookupRequest', 'Required parameter cardInfoLookupRequest was null or undefined when calling cardInfoLookup.');
            }
            const localVarPath = `/card-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CardInfoLookupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(cardInfoLookupRequest || {}) : (cardInfoLookupRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CardInfoLookupApi - functional programming interface
 * @export
 */
exports.CardInfoLookupApiFp = function (configuration) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.CardInfoLookupApiAxiosParamCreator(configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * CardInfoLookupApi - factory interface
 * @export
 */
exports.CardInfoLookupApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options) {
            return exports.CardInfoLookupApiFp(configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * CardInfoLookupApi - object-oriented interface
 * @export
 * @class CardInfoLookupApi
 * @extends {BaseAPI}
 */
class CardInfoLookupApi extends BaseAPI {
    /**
     * Use this to look up card related information such as issuer country, card function and card brand.
     * @summary Card information lookup.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardInfoLookupApi
     */
    cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options) {
        return exports.CardInfoLookupApiFp(this.configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.CardInfoLookupApi = CardInfoLookupApi;
/**
 * CardVerificationApi - axios parameter creator
 * @export
 */
exports.CardVerificationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to perform card verification for a payment card.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'cardVerificationRequest' is not null or undefined
            if (cardVerificationRequest === null || cardVerificationRequest === undefined) {
                throw new RequiredError('cardVerificationRequest', 'Required parameter cardVerificationRequest was null or undefined when calling verifyCard.');
            }
            const localVarPath = `/card-verification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CardVerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(cardVerificationRequest || {}) : (cardVerificationRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CardVerificationApi - functional programming interface
 * @export
 */
exports.CardVerificationApiFp = function (configuration) {
    return {
        /**
         * Use this to perform card verification for a payment card.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.CardVerificationApiAxiosParamCreator(configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * CardVerificationApi - factory interface
 * @export
 */
exports.CardVerificationApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to perform card verification for a payment card.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options) {
            return exports.CardVerificationApiFp(configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * CardVerificationApi - object-oriented interface
 * @export
 * @class CardVerificationApi
 * @extends {BaseAPI}
 */
class CardVerificationApi extends BaseAPI {
    /**
     * Use this to perform card verification for a payment card.
     * @summary Verify a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardVerificationApi
     */
    verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options) {
        return exports.CardVerificationApiFp(this.configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.CardVerificationApi = CardVerificationApi;
/**
 * CurrencyConversionApi - axios parameter creator
 * @export
 */
exports.CurrencyConversionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'exchangeRateRequest' is not null or undefined
            if (exchangeRateRequest === null || exchangeRateRequest === undefined) {
                throw new RequiredError('exchangeRateRequest', 'Required parameter exchangeRateRequest was null or undefined when calling getExchangeRate.');
            }
            const localVarPath = `/exchange-rates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ExchangeRateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(exchangeRateRequest || {}) : (exchangeRateRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CurrencyConversionApi - functional programming interface
 * @export
 */
exports.CurrencyConversionApiFp = function (configuration) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.CurrencyConversionApiAxiosParamCreator(configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * CurrencyConversionApi - factory interface
 * @export
 */
exports.CurrencyConversionApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options) {
            return exports.CurrencyConversionApiFp(configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * CurrencyConversionApi - object-oriented interface
 * @export
 * @class CurrencyConversionApi
 * @extends {BaseAPI}
 */
class CurrencyConversionApi extends BaseAPI {
    /**
     * Sale, return and lookup exchange rate with dynamic currency conversion option.
     * @summary Generate dynamic currency conversion transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyConversionApi
     */
    getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options) {
        return exports.CurrencyConversionApiFp(this.configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.CurrencyConversionApi = CurrencyConversionApi;
/**
 * FraudDetectApi - axios parameter creator
 * @export
 */
exports.FraudDetectApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'clientRegistration' is not null or undefined
            if (clientRegistration === null || clientRegistration === undefined) {
                throw new RequiredError('clientRegistration', 'Required parameter clientRegistration was null or undefined when calling fraudClientRegistrationPost.');
            }
            const localVarPath = `/fraud/client-registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ClientRegistration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(clientRegistration || {}) : (clientRegistration || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'paymentRegistration' is not null or undefined
            if (paymentRegistration === null || paymentRegistration === undefined) {
                throw new RequiredError('paymentRegistration', 'Required parameter paymentRegistration was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            const localVarPath = `/fraud/payment-registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PaymentRegistration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentRegistration || {}) : (paymentRegistration || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'scoreOnlyRequest' is not null or undefined
            if (scoreOnlyRequest === null || scoreOnlyRequest === undefined) {
                throw new RequiredError('scoreOnlyRequest', 'Required parameter scoreOnlyRequest was null or undefined when calling scoreOnly.');
            }
            const localVarPath = `/fraud/score-only`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ScoreOnlyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(scoreOnlyRequest || {}) : (scoreOnlyRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FraudDetectApi - functional programming interface
 * @export
 */
exports.FraudDetectApiFp = function (configuration) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options) {
            const localVarAxiosArgs = exports.FraudDetectApiAxiosParamCreator(configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options) {
            const localVarAxiosArgs = exports.FraudDetectApiAxiosParamCreator(configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.FraudDetectApiAxiosParamCreator(configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * FraudDetectApi - factory interface
 * @export
 */
exports.FraudDetectApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options) {
            return exports.FraudDetectApiFp(configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options) {
            return exports.FraudDetectApiFp(configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options) {
            return exports.FraudDetectApiFp(configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * FraudDetectApi - object-oriented interface
 * @export
 * @class FraudDetectApi
 * @extends {BaseAPI}
 */
class FraudDetectApi extends BaseAPI {
    /**
     * Use this to register client for fraud detect transaction.
     * @summary Client registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ClientRegistration} clientRegistration
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options) {
        return exports.FraudDetectApiFp(this.configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options)(this.axios, this.basePath);
    }
    /**
     * Use this to register payment for fraud detect transaction.
     * @summary Payment registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentRegistration} paymentRegistration
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options) {
        return exports.FraudDetectApiFp(this.configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options)(this.axios, this.basePath);
    }
    /**
     * Use this to obtain a fraud score for a transaction.
     * @summary Score a transaction for fraud.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options) {
        return exports.FraudDetectApiFp(this.configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.FraudDetectApi = FraudDetectApi;
/**
 * OrderApi - axios parameter creator
 * @export
 */
exports.OrderApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling orderInquiry.');
            }
            const localVarPath = `/orders/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new RequiredError('secondaryTransaction', 'Required parameter secondaryTransaction was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            const localVarPath = `/orders/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(secondaryTransaction || {}) : (secondaryTransaction || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * OrderApi - functional programming interface
 * @export
 */
exports.OrderApiFp = function (configuration) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.OrderApiAxiosParamCreator(configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options) {
            const localVarAxiosArgs = exports.OrderApiAxiosParamCreator(configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * OrderApi - factory interface
 * @export
 */
exports.OrderApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            return exports.OrderApiFp(configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options) {
            return exports.OrderApiFp(configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
class OrderApi extends BaseAPI {
    /**
     * Use this query to get the current state of an existing order.
     * @summary Retrieve the state of an order.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
        return exports.OrderApiFp(this.configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
     * @summary Perform return or postAuth secondary transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options) {
        return exports.OrderApiFp(this.configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.OrderApi = OrderApi;
/**
 * PaymentApi - axios parameter creator
 * @export
 */
exports.PaymentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {AuthenticationVerificationRequest} authenticationVerificationRequest Accepted request types: Secure3dAuthenticationVerificationRequest and UnionPayAuthenticationVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationVerificationRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'authenticationVerificationRequest' is not null or undefined
            if (authenticationVerificationRequest === null || authenticationVerificationRequest === undefined) {
                throw new RequiredError('authenticationVerificationRequest', 'Required parameter authenticationVerificationRequest was null or undefined when calling finalizeSecureTransaction.');
            }
            const localVarPath = `/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("AuthenticationVerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(authenticationVerificationRequest || {}) : (authenticationVerificationRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'primaryTransaction' is not null or undefined
            if (primaryTransaction === null || primaryTransaction === undefined) {
                throw new RequiredError('primaryTransaction', 'Required parameter primaryTransaction was null or undefined when calling submitPrimaryTransaction.');
            }
            const localVarPath = `/payments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PrimaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(primaryTransaction || {}) : (primaryTransaction || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new RequiredError('secondaryTransaction', 'Required parameter secondaryTransaction was null or undefined when calling submitSecondaryTransaction.');
            }
            const localVarPath = `/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(secondaryTransaction || {}) : (secondaryTransaction || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling transactionInquiry.');
            }
            const localVarPath = `/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentApi - functional programming interface
 * @export
 */
exports.PaymentApiFp = function (configuration) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {AuthenticationVerificationRequest} authenticationVerificationRequest Accepted request types: Secure3dAuthenticationVerificationRequest and UnionPayAuthenticationVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationVerificationRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationVerificationRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options) {
            const localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentApiAxiosParamCreator(configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentApi - factory interface
 * @export
 */
exports.PaymentApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {AuthenticationVerificationRequest} authenticationVerificationRequest Accepted request types: Secure3dAuthenticationVerificationRequest and UnionPayAuthenticationVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationVerificationRequest, messageSignature, region, options) {
            return exports.PaymentApiFp(configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationVerificationRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options) {
            return exports.PaymentApiFp(configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
            return exports.PaymentApiFp(configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
            return exports.PaymentApiFp(configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(axios, basePath);
        },
    };
};
/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
class PaymentApi extends BaseAPI {
    /**
     * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
     * @summary Update a 3DSecure or UnionPay payment and continue processing.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {AuthenticationVerificationRequest} authenticationVerificationRequest Accepted request types: Secure3dAuthenticationVerificationRequest and UnionPayAuthenticationVerificationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationVerificationRequest, messageSignature, region, options) {
        return exports.PaymentApiFp(this.configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationVerificationRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
    /**
     * Use this to originate a financial transaction like a sale, preauthorization, or credit.
     * @summary Generate a primary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options) {
        return exports.PaymentApiFp(this.configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options)(this.axios, this.basePath);
    }
    /**
     * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
     * @summary Perform a secondary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options) {
        return exports.PaymentApiFp(this.configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * Use this query to get the current state of an existing transaction.
     * @summary Retrieve the state of a transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options) {
        return exports.PaymentApiFp(this.configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
}
exports.PaymentApi = PaymentApi;
/**
 * PaymentSchedulesApi - axios parameter creator
 * @export
 */
exports.PaymentSchedulesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling cancelPaymentSchedule.');
            }
            const localVarPath = `/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'paymentSchedulesRequest' is not null or undefined
            if (paymentSchedulesRequest === null || paymentSchedulesRequest === undefined) {
                throw new RequiredError('paymentSchedulesRequest', 'Required parameter paymentSchedulesRequest was null or undefined when calling createPaymentSchedule.');
            }
            const localVarPath = `/payment-schedules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PaymentSchedulesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentSchedulesRequest || {}) : (paymentSchedulesRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling inquiryPaymentSchedule.');
            }
            const localVarPath = `/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId', 'Required parameter orderId was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'paymentSchedulesRequest' is not null or undefined
            if (paymentSchedulesRequest === null || paymentSchedulesRequest === undefined) {
                throw new RequiredError('paymentSchedulesRequest', 'Required parameter paymentSchedulesRequest was null or undefined when calling updatePaymentSchedule.');
            }
            const localVarPath = `/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PaymentSchedulesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentSchedulesRequest || {}) : (paymentSchedulesRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentSchedulesApi - functional programming interface
 * @export
 */
exports.PaymentSchedulesApiFp = function (configuration) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.PaymentSchedulesApiAxiosParamCreator(configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentSchedulesApi - factory interface
 * @export
 */
exports.PaymentSchedulesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            return exports.PaymentSchedulesApiFp(configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options) {
            return exports.PaymentSchedulesApiFp(configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
            return exports.PaymentSchedulesApiFp(configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options) {
            return exports.PaymentSchedulesApiFp(configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};
/**
 * PaymentSchedulesApi - object-oriented interface
 * @export
 * @class PaymentSchedulesApi
 * @extends {BaseAPI}
 */
class PaymentSchedulesApi extends BaseAPI {
    /**
     * Use this to cancel an existing gateway payment schedule.
     * @summary Cancel a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * Use this to create a gateway payment schedule.
     * @summary Create gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
    /**
     * Use this to view an existing gateway payment schedule.
     * @summary View a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }
    /**
     * Use this to update a gateway payment schedule.
     * @summary Update a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options) {
        return exports.PaymentSchedulesApiFp(this.configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
}
exports.PaymentSchedulesApi = PaymentSchedulesApi;
/**
 * PaymentTokenApi - axios parameter creator
 * @export
 */
exports.PaymentTokenApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'paymentTokenizationRequest' is not null or undefined
            if (paymentTokenizationRequest === null || paymentTokenizationRequest === undefined) {
                throw new RequiredError('paymentTokenizationRequest', 'Required parameter paymentTokenizationRequest was null or undefined when calling createPaymentToken.');
            }
            const localVarPath = `/payment-tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PaymentTokenizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentTokenizationRequest || {}) : (paymentTokenizationRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId', 'Required parameter tokenId was null or undefined when calling deletePaymentToken.');
            }
            const localVarPath = `/payment-tokens/{token-id}`
                .replace(`{${"token-id"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentTokenApi - functional programming interface
 * @export
 */
exports.PaymentTokenApiFp = function (configuration) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options) {
            const localVarAxiosArgs = exports.PaymentTokenApiAxiosParamCreator(configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
            const localVarAxiosArgs = exports.PaymentTokenApiAxiosParamCreator(configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentTokenApi - factory interface
 * @export
 */
exports.PaymentTokenApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options) {
            return exports.PaymentTokenApiFp(configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options)(axios, basePath);
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
            return exports.PaymentTokenApiFp(configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(axios, basePath);
        },
    };
};
/**
 * PaymentTokenApi - object-oriented interface
 * @export
 * @class PaymentTokenApi
 * @extends {BaseAPI}
 */
class PaymentTokenApi extends BaseAPI {
    /**
     * Use this to create a payment token from a payment card.
     * @summary Create a payment token from a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options) {
        return exports.PaymentTokenApiFp(this.configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options)(this.axios, this.basePath);
    }
    /**
     * Use this to delete a payment token.
     * @summary Delete a payment token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options) {
        return exports.PaymentTokenApiFp(this.configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(this.axios, this.basePath);
    }
}
exports.PaymentTokenApi = PaymentTokenApi;
/**
 * PaymentURLApi - axios parameter creator
 * @export
 */
exports.PaymentURLApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'paymentUrlRequest' is not null or undefined
            if (paymentUrlRequest === null || paymentUrlRequest === undefined) {
                throw new RequiredError('paymentUrlRequest', 'Required parameter paymentUrlRequest was null or undefined when calling createPaymentUrl.');
            }
            const localVarPath = `/payment-url`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("PaymentUrlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(paymentUrlRequest || {}) : (paymentUrlRequest || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling deletePaymentUrl.');
            }
            const localVarPath = `/payment-url`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }
            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (paymentUrlId !== undefined) {
                localVarQueryParameter['paymentUrlId'] = paymentUrlId;
            }
            if (transactionTime !== undefined) {
                localVarQueryParameter['transactionTime'] = transactionTime;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options = {}) {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType', 'Required parameter contentType was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId', 'Required parameter clientRequestId was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey', 'Required parameter apiKey was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp', 'Required parameter timestamp was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'fromDate' is not null or undefined
            if (fromDate === null || fromDate === undefined) {
                throw new RequiredError('fromDate', 'Required parameter fromDate was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'toDate' is not null or undefined
            if (toDate === null || toDate === undefined) {
                throw new RequiredError('toDate', 'Required parameter toDate was null or undefined when calling paymentUrlDetail.');
            }
            const localVarPath = `/payment-url`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }
            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }
            if (merchantTransactionId !== undefined) {
                localVarQueryParameter['merchantTransactionId'] = merchantTransactionId;
            }
            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }
            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }
            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }
            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }
            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PaymentURLApi - functional programming interface
 * @export
 */
exports.PaymentURLApiFp = function (configuration) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options) {
            const localVarAxiosArgs = exports.PaymentURLApiAxiosParamCreator(configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options) {
            const localVarAxiosArgs = exports.PaymentURLApiAxiosParamCreator(configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options) {
            const localVarAxiosArgs = exports.PaymentURLApiAxiosParamCreator(configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options);
            return (axios = axios_1.default, basePath = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * PaymentURLApi - factory interface
 * @export
 */
exports.PaymentURLApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options) {
            return exports.PaymentURLApiFp(configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options) {
            return exports.PaymentURLApiFp(configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options)(axios, basePath);
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options) {
            return exports.PaymentURLApiFp(configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options)(axios, basePath);
        },
    };
};
/**
 * PaymentURLApi - object-oriented interface
 * @export
 * @class PaymentURLApi
 * @extends {BaseAPI}
 */
class PaymentURLApi extends BaseAPI {
    /**
     * Use this to generate an embedding payment link.
     * @summary Create a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options) {
        return exports.PaymentURLApiFp(this.configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options)(this.axios, this.basePath);
    }
    /**
     * Use this to delete an embedding payment link.
     * @summary Delete a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [paymentUrlId] The ID code from the payment URL.
     * @param {string} [transactionTime] The transaction time in seconds since epoch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options) {
        return exports.PaymentURLApiFp(this.configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options)(this.axios, this.basePath);
    }
    /**
     * Use this query to get the current state of an existing paymentURL.
     * @summary Retrieve the state of payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} fromDate The start date for payment URL in seconds since epoch.
     * @param {string} toDate The end date for payment URL search query in seconds since epoch.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
     * @param {string} [status] The status of payment URL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options) {
        return exports.PaymentURLApiFp(this.configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options)(this.axios, this.basePath);
    }
}
exports.PaymentURLApi = PaymentURLApi;
