// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Payment Gateway API Specification.
 * The documentation here is designed to provide all of the technical guidance required to consume and integrate with our APIs for payment processing. To learn more about our APIs please visit https://docs.firstdata.com/org/gateway.
 *
 * OpenAPI spec version: 6.10.1.20200226.002
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';

const BASE_PATH = "https://cert.api.firstdata.com/gateway/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *  
 * @export
 * @interface RequestArgs
 */
export interface RequestArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError" = "RequiredError";
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Encapsulates response data from the ACS.
 * @export
 * @interface ACSResponse
 */
export interface ACSResponse {
    /**
     * The ACS response to the CReq message. It can indicate the result of cardholder authentication or, in the case of an app-based model, also signal that further cardholder interaction is required to complete the authentication.
     * @type {string}
     * @memberof ACSResponse
     */
    cRes?: string;
}

/**
 * The processor address validation response for compliance.
 * @export
 * @interface AVSResponse
 */
export interface AVSResponse {
    /**
     * Response if street matches that on file.
     * @type {string}
     * @memberof AVSResponse
     */
    streetMatch?: AVSResponse.StreetMatchEnum;
    /**
     * Response if postal code matches that on file.
     * @type {string}
     * @memberof AVSResponse
     */
    postalCodeMatch?: AVSResponse.PostalCodeMatchEnum;
}

/**
 * @export
 * @namespace AVSResponse
 */
export namespace AVSResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StreetMatchEnum {
        Y = 'Y',
        N = 'N',
        NOINPUTDATA = 'NO_INPUT_DATA',
        NOTCHECKED = 'NOT_CHECKED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PostalCodeMatchEnum {
        Y = 'Y',
        N = 'N',
        NOINPUTDATA = 'NO_INPUT_DATA',
        NOTCHECKED = 'NOT_CHECKED'
    }
}

/**
 * Access token generation request.
 * @export
 * @interface AccessTokenRequest
 */
export interface AccessTokenRequest {
    /**
     * Domain name.
     * @type {string}
     * @memberof AccessTokenRequest
     */
    domain: string;
    /**
     * The token value.
     * @type {string}
     * @memberof AccessTokenRequest
     */
    token: string;
    /**
     * Indicates whether public key is requested or not.
     * @type {boolean}
     * @memberof AccessTokenRequest
     */
    publicKeyRequired: boolean;
}

/**
 * Access token generation response.
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
    /**
     * Access token for authentication.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    tokenId?: string;
    /**
     * The token status.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    status?: string;
    /**
     * Access token issued time in milliseconds.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    issuedOn?: string;
    /**
     * Access token expiration time.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    expiresInSeconds?: string;
    /**
     * Public key to encrypt data.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    publicKeyBase64?: string;
    /**
     * Encyption algorithym. One way ECDH 256 bit key.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    algorithm?: string;
    /**
     * Echoes back the value from the request header for tracking.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    clientRequestId?: string;
}

/**
 * Details related to updated account information.
 * @export
 * @interface AccountUpdaterResponse
 */
export interface AccountUpdaterResponse {
    /**
     * Account updater replacement PAN or TransArmor token.
     * @type {string}
     * @memberof AccountUpdaterResponse
     */
    updatedCard?: string;
    /**
     * Updated value of token.
     * @type {string}
     * @memberof AccountUpdaterResponse
     */
    updatedToken?: string;
    /**
     * New account number expiration date in MMYY format.
     * @type {string}
     * @memberof AccountUpdaterResponse
     */
    updatedExpirationDate?: string;
    /**
     * Status of the updated account. An account may have closed (C), the expiry date may have changed (E), the account may have changed (A), or the cardholder should be contacted (Q).
     * @type {string}
     * @memberof AccountUpdaterResponse
     */
    updatedAccountStatus?: string;
    /**
     * Code for the error encountered when updating account.
     * @type {string}
     * @memberof AccountUpdaterResponse
     */
    updatedAccountErrorCode?: string;
}

/**
 * Rate and corresponding amount being applied to purchase cards, for instance in the form of taxes or discounts.
 * @export
 * @interface AdditionalAmountRate
 */
export interface AdditionalAmountRate {
    /**
     * Amount in 3 decimal 12 bytes total digit.
     * @type {number}
     * @memberof AdditionalAmountRate
     */
    amount: number;
    /**
     * Rate in 3 decimal 12 bytes total digit.
     * @type {number}
     * @memberof AdditionalAmountRate
     */
    rate: number;
}

/**
 * Merchant supplied tracking numbers.
 * @export
 * @interface AdditionalDetails
 */
export interface AdditionalDetails {
    /**
     * Comments for the payment.
     * @type {string}
     * @memberof AdditionalDetails
     */
    comments?: string;
    /**
     * Invoice number.
     * @type {string}
     * @memberof AdditionalDetails
     */
    invoiceNumber?: string;
    /**
     * Purchase order number.
     * @type {string}
     * @memberof AdditionalDetails
     */
    purchaseOrderNumber?: string;
    /**
     * The operator ID.
     * @type {string}
     * @memberof AdditionalDetails
     */
    operatorId?: string;
    /**
     * The sales system ID.
     * @type {string}
     * @memberof AdditionalDetails
     */
    salesSystemId?: string;
    /**
     * Indicates if the particular transaction is a deferred authorization.
     * @type {boolean}
     * @memberof AdditionalDetails
     */
    ipgDeferredAuth?: boolean;
}

/**
 * Additional transaction details for transaction response.
 * @export
 * @interface AdditionalTransactionDetails
 */
export interface AdditionalTransactionDetails {
    /**
     * Comment for the payment.
     * @type {string}
     * @memberof AdditionalTransactionDetails
     */
    comments?: string;
    /**
     * Invoice number.
     * @type {string}
     * @memberof AdditionalTransactionDetails
     */
    invoiceNumber?: string;
    /**
     * Purchase order number.
     * @type {string}
     * @memberof AdditionalTransactionDetails
     */
    purchaseOrderNumber?: string;
    /**
     * The type of debit disbursement transaction.
     * @type {string}
     * @memberof AdditionalTransactionDetails
     */
    disbursementTransType?: AdditionalTransactionDetails.DisbursementTransTypeEnum;
    /**
     * The wallet provider type.
     * @type {string}
     * @memberof AdditionalTransactionDetails
     */
    walletProvider?: AdditionalTransactionDetails.WalletProviderEnum;
}

/**
 * @export
 * @namespace AdditionalTransactionDetails
 */
export namespace AdditionalTransactionDetails {
    /**
     * @export
     * @enum {string}
     */
    export enum DisbursementTransTypeEnum {
        FUNDING = 'FUNDING',
        DISBURSEMENT = 'DISBURSEMENT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum WalletProviderEnum {
        GOOGLEPAY = 'GOOGLE_PAY',
        APPLEPAY = 'APPLE_PAY',
        SAMSUNGPAY = 'SAMSUNG_PAY'
    }
}

/**
 * Model for address information.
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Company name associated with the address.
     * @type {string}
     * @memberof Address
     */
    company?: string;
    /**
     * First line of the street address.
     * @type {string}
     * @memberof Address
     */
    address1?: string;
    /**
     * Second line of the street address.
     * @type {string}
     * @memberof Address
     */
    address2?: string;
    /**
     * City or locality.
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof Address
     */
    region?: string;
    /**
     * ZIP code or postal code.
     * @type {string}
     * @memberof Address
     */
    postalCode?: string;
    /**
     * ISO-3166-1  ALPHA-2, ALPHA-3, numeric or full country name. In the case of PaySecure endpoints, pass the country code in an ISO format.
     * @type {string}
     * @memberof Address
     */
    country?: string;
}

/**
 * Additional data specific to the airline industry.
 * @export
 * @interface Airline
 */
export interface Airline {
    /**
     * The passenger name associated with the transaction.
     * @type {string}
     * @memberof Airline
     */
    passengerName?: string;
    /**
     * The airline ticket number associated with the transaction.
     * @type {string}
     * @memberof Airline
     */
    ticketNumber?: string;
    /**
     * The carrier that issued the ticket.
     * @type {string}
     * @memberof Airline
     */
    issuingCarrier?: string;
    /**
     * The carrier associated with the transaction.
     * @type {string}
     * @memberof Airline
     */
    carrierName?: string;
    /**
     * The IATA code associated with the travel agency.
     * @type {string}
     * @memberof Airline
     */
    travelAgencyIataCode?: string;
    /**
     * The business name of the travel agency.
     * @type {string}
     * @memberof Airline
     */
    travelAgencyName?: string;
    /**
     * The airline plan number associated with the transaction.
     * @type {string}
     * @memberof Airline
     */
    airlinePlanNumber?: string;
    /**
     * The invoice number used by the airline.
     * @type {string}
     * @memberof Airline
     */
    airlineInvoiceNumber?: string;
    /**
     * The reservation system used to create the ticket.
     * @type {string}
     * @memberof Airline
     */
    reservationSystem?: Airline.ReservationSystemEnum;
    /**
     * If the transaction is associated with a restricted class fare.
     * @type {boolean}
     * @memberof Airline
     */
    restricted?: boolean;
    /**
     * Array containing up to 4 items that describe the route associated with the transaction.
     * @type {Array<AirlineTravelRoute>}
     * @memberof Airline
     */
    travelRoute?: Array<AirlineTravelRoute>;
    /**
     * The number of any other tickets associated with the transaction ticket.
     * @type {string}
     * @memberof Airline
     */
    relatedTicketNumber?: string;
    /**
     * Identify the purchase of ancillary goods or services with a false value. If this element is not provided, the transaction is assumed to be a purchase of an airline ticket.
     * @type {Array<AirlineAncillaryServiceCategory>}
     * @memberof Airline
     */
    ancillaryServiceCategory?: Array<AirlineAncillaryServiceCategory>;
    /**
     * Identifies if the transaction is a ticket purchase.
     * @type {boolean}
     * @memberof Airline
     */
    ticketPurchase?: boolean;
}

/**
 * @export
 * @namespace Airline
 */
export namespace Airline {
    /**
     * @export
     * @enum {string}
     */
    export enum ReservationSystemEnum {
        START = 'START',
        TWA = 'TWA',
        DELTA = 'DELTA',
        SABRE = 'SABRE',
        COVIAAPOLLO = 'COVIA_APOLLO',
        DRBLANK = 'DR_BLANK',
        DER = 'DER',
        TUI = 'TUI'
    }
}

/**
 * 
 * @export
 * @interface AirlineAncillaryServiceCategory
 */
export interface AirlineAncillaryServiceCategory {
    /**
     * Identifies the service purchased in the transaction if not a base ticket
     * @type {string}
     * @memberof AirlineAncillaryServiceCategory
     */
    serviceCategory: AirlineAncillaryServiceCategory.ServiceCategoryEnum;
}

/**
 * @export
 * @namespace AirlineAncillaryServiceCategory
 */
export namespace AirlineAncillaryServiceCategory {
    /**
     * @export
     * @enum {string}
     */
    export enum ServiceCategoryEnum {
        BUNDLEDSERVICE = 'BUNDLED_SERVICE',
        BAGGAGEFEE = 'BAGGAGE_FEE',
        CHANGEFEE = 'CHANGE_FEE',
        CARGO = 'CARGO',
        CARBONOFFSET = 'CARBON_OFFSET',
        FREQUENTFLYER = 'FREQUENT_FLYER',
        GIFTCARD = 'GIFT_CARD',
        GROUNDTRANSPORT = 'GROUND_TRANSPORT',
        INFLIGHTENTERTAINMENT = 'IN_FLIGHT_ENTERTAINMENT',
        LOUNGE = 'LOUNGE',
        MEDICAL = 'MEDICAL',
        MEALBEVERAGE = 'MEAL_BEVERAGE',
        OTHER = 'OTHER',
        PASSENGERASSISTFEE = 'PASSENGER_ASSIST_FEE',
        PETS = 'PETS',
        SEATFEES = 'SEAT_FEES',
        STANDBY = 'STANDBY',
        SERVICEFEE = 'SERVICE_FEE',
        STORE = 'STORE',
        TRAVELSERVICE = 'TRAVEL_SERVICE',
        UNACCOMPANIEDTRAVEL = 'UNACCOMPANIED_TRAVEL',
        UPGRADES = 'UPGRADES',
        WIFI = 'WI_FI'
    }
}

/**
 * Additional information about the route.
 * @export
 * @interface AirlineTravelRoute
 */
export interface AirlineTravelRoute {
    /**
     * Date of departure.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    departureDate?: string;
    /**
     * The IATA code for the departure airport.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    origin?: string;
    /**
     * The IATA code for the destination. airport.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    destination?: string;
    /**
     * The IATA code for the carrier.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    carrierCode?: string;
    /**
     * The airline code for the service class of the ticket.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    serviceClass?: string;
    /**
     * Indicates whether the route is direct.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    stopoverType?: AirlineTravelRoute.StopoverTypeEnum;
    /**
     * The airline fare basis code.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    fareBasisCode?: string;
    /**
     * Fee charged by a country when a person leaves the country.
     * @type {number}
     * @memberof AirlineTravelRoute
     */
    departureTax?: number;
    /**
     * The airline flight number associated with the ticket.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    flightNumber?: string;
}

/**
 * @export
 * @namespace AirlineTravelRoute
 */
export namespace AirlineTravelRoute {
    /**
     * @export
     * @enum {string}
     */
    export enum StopoverTypeEnum {
        DIRECT = 'DIRECT',
        STOPOVER = 'STOPOVER'
    }
}

/**
 * The payment object for AliPay transactions. Use this to populate AliPay payment method details.
 * @export
 * @interface AliPay
 */
export interface AliPay {
    /**
     * Use this to indicate the type of machine-readable payment data for scanning.
     * @type {string}
     * @memberof AliPay
     */
    paymentDataType: AliPay.PaymentDataTypeEnum;
    /**
     * Use this to send payment-related information, such as customer identity ID.
     * @type {string}
     * @memberof AliPay
     */
    paymentData: string;
    /**
     * Use this to send an order title that shows up in the statement.
     * @type {string}
     * @memberof AliPay
     */
    orderTitle: string;
    /**
     * Use this to send order details that show up in the statement.
     * @type {string}
     * @memberof AliPay
     */
    orderDetails: string;
}

/**
 * @export
 * @namespace AliPay
 */
export namespace AliPay {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentDataTypeEnum {
        BARCODE = 'BARCODE',
        QRCODE = 'QRCODE'
    }
}

/**
 * Payment method containing AliPay information.
 * @export
 * @interface AliPayPaymentMethod
 */
export interface AliPayPaymentMethod extends PaymentMethod {
    /**
     * 
     * @type {AliPay}
     * @memberof AliPayPaymentMethod
     */
    aliPay: AliPay;
}

/**
 * Request to create sale transaction using AliPay.
 * @export
 * @interface AliPaySaleTransaction
 */
export interface AliPaySaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {AliPayPaymentMethod}
     * @memberof AliPaySaleTransaction
     */
    paymentMethod: AliPayPaymentMethod;
}

/**
 * Amount of the transaction.
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * Amount total.
     * @type {number}
     * @memberof Amount
     */
    total: number;
    /**
     * ISO 4217 currency code.
     * @type {string}
     * @memberof Amount
     */
    currency: string;
    /**
     * 
     * @type {AmountComponents}
     * @memberof Amount
     */
    components?: AmountComponents;
}

/**
 * Transaction amounts with multiple components.
 * @export
 * @interface AmountComponents
 */
export interface AmountComponents {
    /**
     * Subtotal amount.
     * @type {number}
     * @memberof AmountComponents
     */
    subtotal?: number;
    /**
     * Value-added tax amount.
     * @type {number}
     * @memberof AmountComponents
     */
    vatAmount?: number;
    /**
     * Local tax amount.
     * @type {number}
     * @memberof AmountComponents
     */
    localTax?: number;
    /**
     * Shipping amount.
     * @type {number}
     * @memberof AmountComponents
     */
    shipping?: number;
    /**
     * Cashback amount.
     * @type {number}
     * @memberof AmountComponents
     */
    cashback?: number;
    /**
     * Tip amount.
     * @type {number}
     * @memberof AmountComponents
     */
    tip?: number;
}

/**
 * Request authentication of the payment card to verify the cardholder and be eligible for liability shift. An AuthenticationRequest should not be submitted with in the same request as an AuthenticationResult. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface AuthenticationRequest
 */
export interface AuthenticationRequest {
    /**
     * Indicates what kind of authentication scheme the merchant wants to use on the card.
     * @type {string}
     * @memberof AuthenticationRequest
     */
    authenticationType: string;
}

/**
 * Submit the result of 3DS authentication managed outside of the gateway. An AuthenticationResult should not be submitted within the same request as an AuthenticationRequest. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface AuthenticationResult
 */
export interface AuthenticationResult {
    /**
     * Specifies the version of 3DS to be used where authentication was managed outside of the gateway.
     * @type {string}
     * @memberof AuthenticationResult
     */
    authenticationType: string;
}

/**
 * Provides shared fields for all AuthenticationUpdateRequest types. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface AuthenticationUpdateRequest
 */
export interface AuthenticationUpdateRequest {
    /**
     * An optional Outlet ID for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof AuthenticationUpdateRequest
     */
    storeId?: string;
    /**
     * Object name of the authentication update request.
     * @type {string}
     * @memberof AuthenticationUpdateRequest
     */
    authenticationType: string;
    /**
     * 
     * @type {Address}
     * @memberof AuthenticationUpdateRequest
     */
    billingAddress?: Address;
}

/**
 * Object contains background style properties.
 * @export
 * @interface Background
 */
export interface Background {
    /**
     * 
     * @type {TopBar}
     * @memberof Background
     */
    topBar?: TopBar;
    /**
     * 
     * @type {Body}
     * @memberof Background
     */
    body?: Body;
    /**
     * 
     * @type {Content}
     * @memberof Background
     */
    content?: Content;
    /**
     * 
     * @type {Borders}
     * @memberof Background
     */
    borders?: Borders;
}

/**
 * Object contains background color properties.
 * @export
 * @interface BackgroundColor
 */
export interface BackgroundColor {
    /**
     * 
     * @type {Header}
     * @memberof BackgroundColor
     */
    header?: Header;
    /**
     * 
     * @type {Content}
     * @memberof BackgroundColor
     */
    content?: Content;
    /**
     * 
     * @type {Footer}
     * @memberof BackgroundColor
     */
    footer?: Footer;
}

/**
 * Bancontact QR information.
 * @export
 * @interface BancontactQR
 */
export interface BancontactQR {
    /**
     * Transaction Routing Means.
     * @type {string}
     * @memberof BancontactQR
     */
    transactionRoutingMeans: BancontactQR.TransactionRoutingMeansEnum;
    /**
     * Issuer Customer Reference.
     * @type {string}
     * @memberof BancontactQR
     */
    issuerCustomerReference?: string;
}

/**
 * @export
 * @namespace BancontactQR
 */
export namespace BancontactQR {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionRoutingMeansEnum {
        QRCode = 'QR Code',
        URLIntent = 'URL Intent'
    }
}

/**
 * Contains apiTraceId and clientRequestId shared in all response types.
 * @export
 * @interface BasicResponse
 */
export interface BasicResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof BasicResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof BasicResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof BasicResponse
     */
    responseType?: ResponseType;
}

/**
 * Customer billing information.
 * @export
 * @interface Billing
 */
export interface Billing {
    /**
     * Billing name.
     * @type {string}
     * @memberof Billing
     */
    name?: string;
    /**
     * Customer ID for billing purpose.
     * @type {string}
     * @memberof Billing
     */
    customerId?: string;
    /**
     * Customer birth date.
     * @type {string}
     * @memberof Billing
     */
    birthDate?: string;
    /**
     * 
     * @type {Contact}
     * @memberof Billing
     */
    contact?: Contact;
    /**
     * 
     * @type {Address}
     * @memberof Billing
     */
    address?: Address;
}

/**
 * Customer address fields associated with billing.
 * @export
 * @interface BillingAddress
 */
export interface BillingAddress {
    /**
     * First name.
     * @type {string}
     * @memberof BillingAddress
     */
    firstName?: string;
    /**
     * Last name.
     * @type {string}
     * @memberof BillingAddress
     */
    lastName?: string;
    /**
     * Middle name.
     * @type {string}
     * @memberof BillingAddress
     */
    middleName?: string;
    /**
     * First line of street address.
     * @type {string}
     * @memberof BillingAddress
     */
    street: string;
    /**
     * Second line of street address.
     * @type {string}
     * @memberof BillingAddress
     */
    street2?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof BillingAddress
     */
    stateProvince?: string;
    /**
     * City.
     * @type {string}
     * @memberof BillingAddress
     */
    city?: string;
    /**
     * Country.
     * @type {string}
     * @memberof BillingAddress
     */
    country?: string;
    /**
     * 
     * @type {Phone}
     * @memberof BillingAddress
     */
    phone?: Phone;
    /**
     * Postal code.
     * @type {string}
     * @memberof BillingAddress
     */
    zipPostalCode?: string;
}

/**
 * Object that holds information about card that should be blocked.
 * @export
 * @interface BlockCard
 */
export interface BlockCard {
    /**
     * Use this field to send clear PAN or tokens other than TransArmor Token.
     * @type {string}
     * @memberof BlockCard
     */
    cardNumber?: string;
    /**
     * Client order ID.
     * @type {string}
     * @memberof BlockCard
     */
    orderId?: string;
    /**
     * The unique merchant transaction ID.
     * @type {string}
     * @memberof BlockCard
     */
    merchantTransactionId?: string;
}

/**
 * Object that holds information about domain that should be blocked.
 * @export
 * @interface BlockDomain
 */
export interface BlockDomain {
    /**
     * Use this field to send domain name to be blocked.
     * @type {string}
     * @memberof BlockDomain
     */
    domain?: string;
}

/**
 * Object that holds information about IP address that should be blocked.
 * @export
 * @interface BlockIPAddress
 */
export interface BlockIPAddress {
    /**
     * Use this field to send IP address to be blocked.
     * @type {string}
     * @memberof BlockIPAddress
     */
    ipAddress?: string;
    /**
     * Client order ID.
     * @type {string}
     * @memberof BlockIPAddress
     */
    orderId?: string;
}

/**
 * Object that holds information about name that should be blocked.
 * @export
 * @interface BlockName
 */
export interface BlockName {
    /**
     * Use this field to send name to be blocked.
     * @type {string}
     * @memberof BlockName
     */
    name?: string;
    /**
     * Client order ID.
     * @type {string}
     * @memberof BlockName
     */
    orderId?: string;
}

/**
 * Object that holds information about blocked card numbers.
 * @export
 * @interface BlockedCardNumber
 */
export interface BlockedCardNumber {
    /**
     * Use this field to send clear PAN or tokens other than TransArmor Token.
     * @type {string}
     * @memberof BlockedCardNumber
     */
    cardNumber?: string;
    /**
     * Token identifier.
     * @type {string}
     * @memberof BlockedCardNumber
     */
    tokenIdentifier?: string;
}

/**
 * Object that holds information about items that should be blocked.
 * @export
 * @interface BlockedItems
 */
export interface BlockedItems {
    /**
     * 
     * @type {BlockCard}
     * @memberof BlockedItems
     */
    blockCard?: BlockCard;
    /**
     * 
     * @type {BlockDomain}
     * @memberof BlockedItems
     */
    blockDomain?: BlockDomain;
    /**
     * 
     * @type {BlockName}
     * @memberof BlockedItems
     */
    blockName?: BlockName;
    /**
     * 
     * @type {BlockIPAddress}
     * @memberof BlockedItems
     */
    blockIPAddress?: BlockIPAddress;
}

/**
 * 
 * @export
 * @interface Body
 */
export interface Body {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Body
     */
    color?: string;
}

/**
 * 
 * @export
 * @interface Borders
 */
export interface Borders {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Borders
     */
    color?: string;
}

/**
 * Request to update branding style properties for store.
 * @export
 * @interface BrandingStyleConfigurationRequest
 */
export interface BrandingStyleConfigurationRequest {
    /**
     * 
     * @type {Array<StoreBrandingStyleConfiguration>}
     * @memberof BrandingStyleConfigurationRequest
     */
    stores?: Array<StoreBrandingStyleConfiguration>;
}

/**
 * 
 * @export
 * @interface BrandingStyleConfigurationResponse
 */
export interface BrandingStyleConfigurationResponse extends BasicResponse {
    /**
     * 
     * @type {Array<BrandingStyleConfigurationResult>}
     * @memberof BrandingStyleConfigurationResponse
     */
    stores?: Array<BrandingStyleConfigurationResult>;
}

/**
 * 
 * @export
 * @interface BrandingStyleConfigurationResult
 */
export interface BrandingStyleConfigurationResult {
    /**
     * An optional outlet id for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof BrandingStyleConfigurationResult
     */
    id?: string;
    /**
     * Status from branding style configuration process.
     * @type {string}
     * @memberof BrandingStyleConfigurationResult
     */
    status?: string;
}

/**
 * Object contains button style properties.
 * @export
 * @interface Button
 */
export interface Button {
    /**
     * 
     * @type {Primary}
     * @memberof Button
     */
    primary?: Primary;
    /**
     * 
     * @type {Hover}
     * @memberof Button
     */
    hover?: Hover;
}

/**
 * Additional data specific to the car rental industry.
 * @export
 * @interface CarRental
 */
export interface CarRental {
    /**
     * The car rental agreement number.
     * @type {string}
     * @memberof CarRental
     */
    agreementNumber?: string;
    /**
     * The name of the person renting the car.
     * @type {string}
     * @memberof CarRental
     */
    renterName?: string;
    /**
     * The city where the rental ends and the car is returned.
     * @type {string}
     * @memberof CarRental
     */
    returnCity?: string;
    /**
     * The date the car rental ends and the car is returned.
     * @type {string}
     * @memberof CarRental
     */
    returnDate?: string;
    /**
     * The date the car rental begins.
     * @type {string}
     * @memberof CarRental
     */
    pickupDate?: string;
    /**
     * The classification of the rental car.
     * @type {string}
     * @memberof CarRental
     */
    rentalClassId?: string;
    /**
     * Array containing information about charges other than the rental rate.
     * @type {Array<CarRentalExtraCharges>}
     * @memberof CarRental
     */
    extraCharges?: Array<CarRentalExtraCharges>;
    /**
     * Indicates if the transaction is related to a no-show charge.
     * @type {boolean}
     * @memberof CarRental
     */
    noShowIndicator?: boolean;
}

/**
 * 
 * @export
 * @interface CarRentalExtraCharges
 */
export interface CarRentalExtraCharges {
    /**
     * Additional charge item.
     * @type {string}
     * @memberof CarRentalExtraCharges
     */
    chargeItem?: CarRentalExtraCharges.ChargeItemEnum;
}

/**
 * @export
 * @namespace CarRentalExtraCharges
 */
export namespace CarRentalExtraCharges {
    /**
     * @export
     * @enum {string}
     */
    export enum ChargeItemEnum {
        EXTRAMILEAGE = 'EXTRA_MILEAGE',
        GAS = 'GAS',
        LATERETURN = 'LATE_RETURN',
        ONEWAYSERVICEFEE = 'ONE_WAY_SERVICE_FEE',
        PARKINGVIOLATION = 'PARKING_VIOLATION'
    }
}

/**
 * Properties for the payment method.
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * TransArmor token value. Either the token fields or card number field must contain a value.
     * @type {string}
     * @memberof Card
     */
    taToken?: string;
    /**
     * TransArmor token key to identify the merchant.
     * @type {string}
     * @memberof Card
     */
    taTokenKey?: string;
    /**
     * The cardholder name as it appears on the card.
     * @type {string}
     * @memberof Card
     */
    cardholderName?: string;
    /**
     * Use this field to send clear PAN or tokens other than TransArmor Token.
     * @type {string}
     * @memberof Card
     */
    cardNumber?: string;
    /**
     * Payment method expiration date. Format is MMYYYY.
     * @type {string}
     * @memberof Card
     */
    expDate?: string;
    /**
     * CVV present indicator.
     * @type {string}
     * @memberof Card
     */
    cvv?: string;
    /**
     * The company (usually a bank) that issued the card.
     * @type {string}
     * @memberof Card
     */
    issuer?: string;
    /**
     * A number that distinguishes between two plastic cards with the same card number in the event of the card being re-issued.
     * @type {string}
     * @memberof Card
     */
    cardReissuedNumber?: string;
}

/**
 * Card function. This field is required when performing transactions for Brazil merchants.
 * @export
 * @enum {string}
 */
export enum CardFunction {
    CREDIT = 'CREDIT',
    DEBIT = 'DEBIT',
    PREPAID = 'PREPAID',
    VOUCHER = 'VOUCHER',
    UNDEFINED = 'UNDEFINED'
}

/**
 * Card information.
 * @export
 * @interface CardInfo
 */
export interface CardInfo {
    /**
     * The card brand.
     * @type {string}
     * @memberof CardInfo
     */
    brand?: string;
    /**
     * The product ID of the brand.
     * @type {string}
     * @memberof CardInfo
     */
    brandProductId?: string;
    /**
     * 
     * @type {CardFunction}
     * @memberof CardInfo
     */
    cardFunction?: CardFunction;
    /**
     * Indicates whether it is a corporate or non-corporate card.
     * @type {string}
     * @memberof CardInfo
     */
    commercialCard?: CardInfo.CommercialCardEnum;
    /**
     * The country of the issuer.
     * @type {string}
     * @memberof CardInfo
     */
    issuerCountry?: string;
    /**
     * The name of the issuer.
     * @type {string}
     * @memberof CardInfo
     */
    issuerName?: string;
}

/**
 * @export
 * @namespace CardInfo
 */
export namespace CardInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum CommercialCardEnum {
        CORPORATE = 'CORPORATE',
        NONCORPORATE = 'NON_CORPORATE'
    }
}

/**
 * Request to look up card-related information such as issuer country, card function and card brand.
 * @export
 * @interface CardInfoLookupRequest
 */
export interface CardInfoLookupRequest {
    /**
     * An optional outlet id for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof CardInfoLookupRequest
     */
    storeId?: string;
    /**
     * 
     * @type {PaymentCard}
     * @memberof CardInfoLookupRequest
     */
    paymentCard: PaymentCard;
}

/**
 * Response from card info lookup request.
 * @export
 * @interface CardInfoLookupResponse
 */
export interface CardInfoLookupResponse extends BasicResponse {
    /**
     * One or more card information retrieved based on BIN.
     * @type {Array<CardInfo>}
     * @memberof CardInfoLookupResponse
     */
    cardDetails?: Array<CardInfo>;
    /**
     * Request status.
     * @type {string}
     * @memberof CardInfoLookupResponse
     */
    requestStatus?: CardInfoLookupResponse.RequestStatusEnum;
}

/**
 * @export
 * @namespace CardInfoLookupResponse
 */
export namespace CardInfoLookupResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum RequestStatusEnum {
        SUCCESS = 'SUCCESS',
        LISTEMPTY = 'LIST_EMPTY'
    }
}

/**
 * Request to verify card validity.
 * @export
 * @interface CardVerificationRequest
 */
export interface CardVerificationRequest {
    /**
     * 
     * @type {PaymentCard}
     * @memberof CardVerificationRequest
     */
    paymentCard: PaymentCard;
    /**
     * 
     * @type {Address}
     * @memberof CardVerificationRequest
     */
    billingAddress?: Address;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof CardVerificationRequest
     */
    storeId?: string;
}

/**
 * The payment object for China-domestic transactions. Use this to populate all china domestic payment method details.
 * @export
 * @interface ChinaDomestic
 */
export interface ChinaDomestic {
    /**
     * Use this to indicate the product code according to the product category list.
     * @type {string}
     * @memberof ChinaDomestic
     */
    productCode: string;
    /**
     * The quantity.
     * @type {number}
     * @memberof ChinaDomestic
     */
    productQuantity: number;
    /**
     * Rate amount in 3 decimal 12 bytes total digit.
     * @type {number}
     * @memberof ChinaDomestic
     */
    productPrice: number;
    /**
     * The product description.
     * @type {string}
     * @memberof ChinaDomestic
     */
    productDescription: string;
    /**
     * Use this to indicate the product code according to the product category list.
     * @type {string}
     * @memberof ChinaDomestic
     */
    redirectURL: string;
    /**
     * Use this to limit card functions to debit cards.
     * @type {boolean}
     * @memberof ChinaDomestic
     */
    limitCardFunctionToDebit?: boolean;
    /**
     * Use this to indicate the CUP customer ID if known.
     * @type {string}
     * @memberof ChinaDomestic
     */
    customerId?: string;
    /**
     * Use this to indicate the CUP bank ID if known.
     * @type {string}
     * @memberof ChinaDomestic
     */
    bankId?: string;
}

/**
 * Payment method containing China Domestic information.
 * @export
 * @interface ChinaDomesticPaymentMethod
 */
export interface ChinaDomesticPaymentMethod extends PaymentMethod {
    /**
     * 
     * @type {ChinaDomestic}
     * @memberof ChinaDomesticPaymentMethod
     */
    chinaDomestic: ChinaDomestic;
    /**
     * 
     * @type {string}
     * @memberof ChinaDomesticPaymentMethod
     */
    brand: ChinaDomesticPaymentMethod.BrandEnum;
}

/**
 * @export
 * @namespace ChinaDomesticPaymentMethod
 */
export namespace ChinaDomesticPaymentMethod {
    /**
     * @export
     * @enum {string}
     */
    export enum BrandEnum {
        ALIPAYDOMESTIC = 'ALIPAY_DOMESTIC',
        CUPDOMESTIC = 'CUP_DOMESTIC',
        WECHATDOMESTIC = 'WECHAT_DOMESTIC'
    }
}

/**
 * Request to create sale transaction using China PnR.
 * @export
 * @interface ChinaPnRSaleTransaction
 */
export interface ChinaPnRSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {ChinaDomesticPaymentMethod}
     * @memberof ChinaPnRSaleTransaction
     */
    paymentMethod: ChinaDomesticPaymentMethod;
}

/**
 * Object contains classic mode branding style properties.
 * @export
 * @interface ClassicMode
 */
export interface ClassicMode {
    /**
     * 
     * @type {BackgroundColor}
     * @memberof ClassicMode
     */
    backgroundColor?: BackgroundColor;
    /**
     * 
     * @type {Mobile}
     * @memberof ClassicMode
     */
    mobile?: Mobile;
    /**
     * 
     * @type {FontProperties}
     * @memberof ClassicMode
     */
    amountTitle?: FontProperties;
    /**
     * 
     * @type {FontProperties}
     * @memberof ClassicMode
     */
    superscription?: FontProperties;
    /**
     * 
     * @type {FontProperties}
     * @memberof ClassicMode
     */
    individualText?: FontProperties;
    /**
     * 
     * @type {FontProperties}
     * @memberof ClassicMode
     */
    label?: FontProperties;
    /**
     * 
     * @type {FontProperties}
     * @memberof ClassicMode
     */
    normalText?: FontProperties;
    /**
     * 
     * @type {Properties}
     * @memberof ClassicMode
     */
    buttons?: Properties;
    /**
     * 
     * @type {Properties}
     * @memberof ClassicMode
     */
    anchor?: Properties;
    /**
     * 
     * @type {Properties}
     * @memberof ClassicMode
     */
    systemMessages?: Properties;
}

/**
 * Contains clearing related response information.
 * @export
 * @interface ClearingDetails
 */
export interface ClearingDetails {
    /**
     * The array contains information about the clearing elements.
     * @type {Array<ClearingElement>}
     * @memberof ClearingDetails
     */
    clearingElements?: Array<ClearingElement>;
    /**
     * Timestamp when the clearing has been processed. The used format is \"YYYYMMDDhhmmss\".
     * @type {string}
     * @memberof ClearingDetails
     */
    batchTimeStamp?: string;
    /**
     * Start receipt number for the clearing process.
     * @type {number}
     * @memberof ClearingDetails
     */
    receiptNumberFrom?: number;
    /**
     * End receipt number for the clearing process.
     * @type {number}
     * @memberof ClearingDetails
     */
    receiptNumberTo?: number;
    /**
     * Trace number for the clearing process.
     * @type {number}
     * @memberof ClearingDetails
     */
    traceNumber?: number;
}

/**
 * Holds brand specific clearing information.
 * @export
 * @interface ClearingElement
 */
export interface ClearingElement {
    /**
     * Contains the brand of the card.
     * @type {string}
     * @memberof ClearingElement
     */
    brand?: string;
    /**
     * Holds the total clearing value computed for a specific brand.
     * @type {number}
     * @memberof ClearingElement
     */
    value?: number;
    /**
     * Specifies the amount of clearing elements for a given brand.
     * @type {number}
     * @memberof ClearingElement
     */
    count?: number;
}

/**
 * Country and language of client.
 * @export
 * @interface ClientLocale
 */
export interface ClientLocale {
    /**
     * Language used by client.
     * @type {string}
     * @memberof ClientLocale
     */
    language: string;
    /**
     * Country of the client.
     * @type {string}
     * @memberof ClientLocale
     */
    country: string;
}

/**
 * 
 * @export
 * @interface ClientRegistration
 */
export interface ClientRegistration extends FraudRegistration {
    /**
     * Defines the type of the original transaction that is being evaluated for the Fraud Score.
     * @type {string}
     * @memberof ClientRegistration
     */
    originalTransactionType?: string;
}

/**
 * Object contains combined mode branding style properties.
 * @export
 * @interface CombinedMode
 */
export interface CombinedMode {
    /**
     * 
     * @type {Logo}
     * @memberof CombinedMode
     */
    logo?: Logo;
    /**
     * 
     * @type {Background}
     * @memberof CombinedMode
     */
    background?: Background;
    /**
     * 
     * @type {Text}
     * @memberof CombinedMode
     */
    text?: Text;
    /**
     * 
     * @type {Button}
     * @memberof CombinedMode
     */
    button?: Button;
}

/**
 * The type of connect mode.
 * @export
 * @enum {string}
 */
export enum ConnectMode {
    Classic = 'Classic',
    Combined = 'Combined'
}

/**
 * Customer contact information.
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * Primary phone number.
     * @type {string}
     * @memberof Contact
     */
    phone?: string;
    /**
     * Mobile phone number.
     * @type {string}
     * @memberof Contact
     */
    mobilePhone?: string;
    /**
     * Fax number.
     * @type {string}
     * @memberof Contact
     */
    fax?: string;
    /**
     * Email address.
     * @type {string}
     * @memberof Contact
     */
    email?: string;
}

/**
 * 
 * @export
 * @interface Content
 */
export interface Content {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Content
     */
    color?: string;
}

/**
 * Object that holds information about country.
 * @export
 * @interface CountryProfile
 */
export interface CountryProfile {
    /**
     * Country profile.
     * @type {number}
     * @memberof CountryProfile
     */
    profile?: number;
}

/**
 * Use this model to create a payment token.
 * @export
 * @interface CreatePaymentToken
 */
export interface CreatePaymentToken {
    /**
     * Client-supplied payment token value. Only applicable for DataVault tokenization scheme.
     * @type {string}
     * @memberof CreatePaymentToken
     */
    value?: string;
    /**
     * If the token is reusable.
     * @type {boolean}
     * @memberof CreatePaymentToken
     */
    reusable?: boolean;
    /**
     * Decline duplicate payment info if client token is supplied.
     * @type {boolean}
     * @memberof CreatePaymentToken
     */
    declineDuplicates?: boolean;
}

/**
 * Currency conversion. Abstract class, do not use this class directly, use one of its children: Dcc, DynamicPricing.
 * @export
 * @interface CurrencyConversion
 */
export interface CurrencyConversion {
    /**
     * Type of currency conversion.
     * @type {string}
     * @memberof CurrencyConversion
     */
    conversionType: string;
    /**
     * Inquiry rate id.
     * @type {string}
     * @memberof CurrencyConversion
     */
    inquiryRateId: string;
}

/**
 * Customer model for customers registered at merchant's website.
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * Unique ID for the customer, if registered. This field is required if the parent object is present.
     * @type {string}
     * @memberof Customer
     */
    id: string;
    /**
     * The timestamp of the customers registration in the merchants platform. Format is YYYY-MM-DD.
     * @type {string}
     * @memberof Customer
     */
    startDate?: string;
    /**
     * Customer's first name.
     * @type {string}
     * @memberof Customer
     */
    firstName?: string;
    /**
     * Customer's last name.
     * @type {string}
     * @memberof Customer
     */
    lastName?: string;
    /**
     * Customer's middle name.
     * @type {string}
     * @memberof Customer
     */
    middleName?: string;
    /**
     * Customer's email address.
     * @type {string}
     * @memberof Customer
     */
    email?: string;
    /**
     * The unique ID of the current login session. Must be unique for the customer.
     * @type {string}
     * @memberof Customer
     */
    sessionId?: string;
    /**
     * The username of this customer in the merchants system. This field should contain customer-supplied data if available instead of a generated ID. This field can contain the clients email address if it is also used for authentication purposes.
     * @type {string}
     * @memberof Customer
     */
    username?: string;
    /**
     * The customers gender. Do not set this property if the customer does not specify a gender.
     * @type {string}
     * @memberof Customer
     */
    gender?: Customer.GenderEnum;
    /**
     * The customer's year of birth. Format is YYYY.
     * @type {string}
     * @memberof Customer
     */
    dateOfBirth?: string;
    /**
     * 
     * @type {CustomerAddress}
     * @memberof Customer
     */
    address?: CustomerAddress;
    /**
     * A JSON object that can carry any additional information about the customer that might be helpful for fraud detection.
     * @type {any}
     * @memberof Customer
     */
    userDefined?: any;
}

/**
 * @export
 * @namespace Customer
 */
export namespace Customer {
    /**
     * @export
     * @enum {string}
     */
    export enum GenderEnum {
        Male = 'male',
        Female = 'female',
        Other = 'other'
    }
}

/**
 * Customer address fields.
 * @export
 * @interface CustomerAddress
 */
export interface CustomerAddress extends FraudAddress {
    /**
     * 
     * @type {Phone}
     * @memberof CustomerAddress
     */
    phone?: Phone;
}

/**
 * Request to perform a DCC exchange rate inquiry.
 * @export
 * @interface DCCExchangeRateRequest
 */
export interface DCCExchangeRateRequest extends ExchangeRateRequest {
    /**
     * A bank identification number (BIN) of the card to be used for DCC.
     * @type {string}
     * @memberof DCCExchangeRateRequest
     */
    bin: string;
}

/**
 * Request to perform a dynamic pricing exchange rate inquiry.
 * @export
 * @interface Dcc
 */
export interface Dcc extends CurrencyConversion {
    /**
     * Indicates whether customer agrees with rate to be used.
     * @type {boolean}
     * @memberof Dcc
     */
    dccApplied: boolean;
}

/**
 * Decrypted Apple Pay payload.
 * @export
 * @interface DecryptedApplePay
 */
export interface DecryptedApplePay {
    /**
     * Payment card number.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    accountNumber: string;
    /**
     * Card expiration date in MMYYYY format.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    expiration: string;
    /**
     * Numeric currency code following ISO 4217 standards.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    currencyCode: string;
    /**
     * Amount total.
     * @type {number}
     * @memberof DecryptedApplePay
     */
    amount: number;
    /**
     * Name of the cardholder.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    cardholderName: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    brand: string;
    /**
     * The wallet cryptogram from the decrypted data.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    cryptogram: string;
    /**
     * The ECI indicator from the decrypted data.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    eciIndicator: string;
}

/**
 * Wallet payment method containing decrypted Apple Pay information.
 * @export
 * @interface DecryptedApplePayWalletPaymentMethod
 */
export interface DecryptedApplePayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {DecryptedApplePay}
     * @memberof DecryptedApplePayWalletPaymentMethod
     */
    decryptedApplePay: DecryptedApplePay;
}

/**
 * Decrypted Google Pay payload.
 * @export
 * @interface DecryptedGooglePay
 */
export interface DecryptedGooglePay {
    /**
     * Payment card number.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    accountNumber: string;
    /**
     * Card expiration date in MMYYYY format.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    expiration: string;
    /**
     * Numeric currency code following ISO 4217 standards.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    currencyCode: string;
    /**
     * Amount total.
     * @type {number}
     * @memberof DecryptedGooglePay
     */
    amount: number;
    /**
     * Name of the cardholder.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    cardholderName: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    brand: string;
    /**
     * The wallet cryptogram from the decrypted data.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    cryptogram: string;
    /**
     * The ECI indicator from the decrypted data.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    eciIndicator: string;
}

/**
 * Wallet payment method containing decrypted Google Pay information.
 * @export
 * @interface DecryptedGooglePayWalletPaymentMethod
 */
export interface DecryptedGooglePayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {DecryptedGooglePay}
     * @memberof DecryptedGooglePayWalletPaymentMethod
     */
    decryptedGooglePay: DecryptedGooglePay;
}

/**
 * Decrypted Samsung Pay payload.
 * @export
 * @interface DecryptedSamsungPay
 */
export interface DecryptedSamsungPay {
    /**
     * Payment card number.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    accountNumber: string;
    /**
     * Card expiration date in MMYYYY format.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    expiration: string;
    /**
     * Numeric currency code following ISO 4217 standards.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    currencyCode: string;
    /**
     * Amount total.
     * @type {number}
     * @memberof DecryptedSamsungPay
     */
    amount: number;
    /**
     * Name of the cardholder.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    cardholderName: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    brand: string;
    /**
     * The wallet cryptogram from the decrypted data.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    cryptogram: string;
    /**
     * The ECI indicator from the decrypted data.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    eciIndicator: string;
}

/**
 * Wallet payment method containing decrypted Samsung Pay information.
 * @export
 * @interface DecryptedSamsungPayWalletPaymentMethod
 */
export interface DecryptedSamsungPayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {DecryptedSamsungPay}
     * @memberof DecryptedSamsungPayWalletPaymentMethod
     */
    decryptedSamsungPay: DecryptedSamsungPay;
}

/**
 * 
 * @export
 * @interface DeleteBrandingStyleConfigurationResponse
 */
export interface DeleteBrandingStyleConfigurationResponse extends BasicResponse {
    /**
     * Store ID number.
     * @type {string}
     * @memberof DeleteBrandingStyleConfigurationResponse
     */
    storeId?: string;
    /**
     * Status from delete branding style configuration process.
     * @type {string}
     * @memberof DeleteBrandingStyleConfigurationResponse
     */
    status?: string;
}

/**
 * The device where this transaction originated.
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * Defines the type of this object.
     * @type {string}
     * @memberof Device
     */
    deviceType: Device.DeviceTypeEnum;
    /**
     * The unique ID of the device. Must be unique for the entire system (not just within a specific merchant or industry).
     * @type {string}
     * @memberof Device
     */
    deviceId: string;
    /**
     * Information about the networks associated with the device.
     * @type {Array<Items>}
     * @memberof Device
     */
    networks?: Array<Items>;
    /**
     * The GPS decimal latitude, ranging from (-90.0 to 90.0) where positive numbers indicate locations North of the equator.
     * @type {number}
     * @memberof Device
     */
    latitude?: number;
    /**
     * The GPS decimal longitude, ranging from (-180.0 to 180.0) where positive numbers indicate locations East of the IERS Reference Meridian.
     * @type {number}
     * @memberof Device
     */
    longitude?: number;
    /**
     * The device's International Mobile Equipment Identity (IMEI) as described in IETF RFC7254.
     * @type {string}
     * @memberof Device
     */
    imei?: string;
    /**
     * The device's model name.
     * @type {string}
     * @memberof Device
     */
    model?: string;
    /**
     * The device's manufacturer.
     * @type {string}
     * @memberof Device
     */
    manufacturer?: string;
    /**
     * The timezone offset from UTC to the devices timezone configuration, specified in the format +hh:mm.
     * @type {string}
     * @memberof Device
     */
    timezoneOffset?: string;
    /**
     * A flag indicating that the device has been altered to allow privileged access to users. This flag should only be set to false if a test was performed and the result was negative. Leave unset otherwise.
     * @type {boolean}
     * @memberof Device
     */
    rooted?: boolean;
    /**
     * A flag indicating that malware was detected on the mobile phone. This flag should only be set to false if a test was performed and the result was negative. Leave unset otherwise.
     * @type {boolean}
     * @memberof Device
     */
    malwareDetected?: boolean;
    /**
     * A JSON object that can carry any additional information about the device that might be helpful for fraud detection.
     * @type {any}
     * @memberof Device
     */
    userDefined?: any;
}

/**
 * @export
 * @namespace Device
 */
export namespace Device {
    /**
     * @export
     * @enum {string}
     */
    export enum DeviceTypeEnum {
        Pos = 'device/pos',
        Mobile = 'device/mobile'
    }
}

/**
 * Disbursement information. Abstract class, do not use this class directly, use one of its children: FundingTransactionType, DisbursementTransactionType.
 * @export
 * @interface Disbursement
 */
export interface Disbursement {
    /**
     * The type of disbursement.
     * @type {string}
     * @memberof Disbursement
     */
    disbursementType: string;
    /**
     * 
     * @type {SenderInfo}
     * @memberof Disbursement
     */
    senderInfo: SenderInfo;
    /**
     * 
     * @type {ReceiverInfo}
     * @memberof Disbursement
     */
    receiverInfo: ReceiverInfo;
}

/**
 * Push disbursement information.
 * @export
 * @interface DisbursementTransactionType
 */
export interface DisbursementTransactionType extends Disbursement {
}

/**
 * Document information.
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * Document type.
     * @type {string}
     * @memberof Document
     */
    type: Document.TypeEnum;
    /**
     * Document number.
     * @type {string}
     * @memberof Document
     */
    number: string;
}

/**
 * @export
 * @namespace Document
 */
export namespace Document {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        NATIONALIDENTITY = 'NATIONAL_IDENTITY',
        SINGLETAXIDENTIFICATION = 'SINGLE_TAX_IDENTIFICATION',
        SINGLECODEOFLABORIDENTIFICATION = 'SINGLE_CODE_OF_LABOR_IDENTIFICATION',
        BOOKENLISTMENT = 'BOOK_ENLISTMENT',
        CIVICNOTEBOOK = 'CIVIC_NOTEBOOK',
        PASSPORT = 'PASSPORT'
    }
}

/**
 * Request to perform a dynamic pricing exchange rate inquiry.
 * @export
 * @interface DynamicPricing
 */
export interface DynamicPricing extends CurrencyConversion {
    /**
     * The currency code to convert for dynamic pricing in ISO 4217 currency code format.
     * @type {string}
     * @memberof DynamicPricing
     */
    foreignCurrency: string;
    /**
     * Foreign amount.
     * @type {string}
     * @memberof DynamicPricing
     */
    foreignAmount: string;
}

/**
 * Request to perform a dynamic pricing exchange rate inquiry.
 * @export
 * @interface DynamicPricingExchangeRateRequest
 */
export interface DynamicPricingExchangeRateRequest extends ExchangeRateRequest {
    /**
     * The currency code to convert for dynamic pricing in either numeric or alphabetic ISO 4217 currency code format.
     * @type {string}
     * @memberof DynamicPricingExchangeRateRequest
     */
    foreignCurrency: string;
}

/**
 * Encrypted Apple Pay payload.
 * @export
 * @interface EncryptedApplePay
 */
export interface EncryptedApplePay {
    /**
     * The encrypted wallet payload.
     * @type {string}
     * @memberof EncryptedApplePay
     */
    data: string;
    /**
     * 
     * @type {EncryptedApplePayHeader}
     * @memberof EncryptedApplePay
     */
    header: EncryptedApplePayHeader;
    /**
     * Signature of the payment and header data.
     * @type {string}
     * @memberof EncryptedApplePay
     */
    signature: string;
    /**
     * Version information about the payment token.
     * @type {string}
     * @memberof EncryptedApplePay
     */
    version?: EncryptedApplePay.VersionEnum;
    /**
     * Base64-encoded value of PKPaymentRequest. Required only if applicationDataHash is present.
     * @type {string}
     * @memberof EncryptedApplePay
     */
    applicationData?: string;
    /**
     * The merchant ID assigned by the wallet provider.
     * @type {string}
     * @memberof EncryptedApplePay
     */
    merchantId: string;
}

/**
 * @export
 * @namespace EncryptedApplePay
 */
export namespace EncryptedApplePay {
    /**
     * @export
     * @enum {string}
     */
    export enum VersionEnum {
        ECV1 = 'EC_v1'
    }
}

/**
 * Additional version-dependent information used to decrypt and verify the payment.
 * @export
 * @interface EncryptedApplePayHeader
 */
export interface EncryptedApplePayHeader {
    /**
     * Merchant supplied information about the payment request. Contains Base64-encoded SHA256 hash of the applicationData property of the original PKPaymentRequest. Note - applicationData from PaymentData of PKPaymentToken Refer to Apple Pay documentation.
     * @type {string}
     * @memberof EncryptedApplePayHeader
     */
    applicationDataHash?: string;
    /**
     * Temporary key for generating shared secret from a device.
     * @type {string}
     * @memberof EncryptedApplePayHeader
     */
    ephemeralPublicKey: string;
    /**
     * Hash of the X.509 encoded public key bytes of the merchant’s certificate.
     * @type {string}
     * @memberof EncryptedApplePayHeader
     */
    publicKeyHash: string;
    /**
     * Transaction identifier, generated on the device.
     * @type {string}
     * @memberof EncryptedApplePayHeader
     */
    transactionId: string;
}

/**
 * Wallet payment method containing encrypted Apple Pay information.
 * @export
 * @interface EncryptedApplePayWalletPaymentMethod
 */
export interface EncryptedApplePayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {EncryptedApplePay}
     * @memberof EncryptedApplePayWalletPaymentMethod
     */
    encryptedApplePay: EncryptedApplePay;
}

/**
 * Encrypted Google Pay payload.
 * @export
 * @interface EncryptedGooglePay
 */
export interface EncryptedGooglePay {
    /**
     * 
     * @type {EncryptedGooglePayData}
     * @memberof EncryptedGooglePay
     */
    data: EncryptedGooglePayData;
    /**
     * Signature for verifying that the message comes from Google. The signature is created using ECDSA.
     * @type {string}
     * @memberof EncryptedGooglePay
     */
    signature: string;
    /**
     * Identifies under which encryption/signing scheme this message has been created. In this way, the protocol can evolve over time if needed. For Google Payments transactions, this should be set to ECv1.
     * @type {string}
     * @memberof EncryptedGooglePay
     */
    version: string;
}

/**
 * The encrypted wallet payload.
 * @export
 * @interface EncryptedGooglePayData
 */
export interface EncryptedGooglePayData {
    /**
     * The encrypted message containing the actual payment information as well as additional security fields.
     * @type {string}
     * @memberof EncryptedGooglePayData
     */
    encryptedMessage: string;
    /**
     * The ephemeral public key associated with the private key to encrypt the message in uncompressed point format.
     * @type {string}
     * @memberof EncryptedGooglePayData
     */
    ephemeralPublicKey: string;
    /**
     * MAC of the encryptedMessage.
     * @type {string}
     * @memberof EncryptedGooglePayData
     */
    tag: string;
}

/**
 * Wallet payment method containing encrypted Google Pay information.
 * @export
 * @interface EncryptedGooglePayWalletPaymentMethod
 */
export interface EncryptedGooglePayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {EncryptedGooglePay}
     * @memberof EncryptedGooglePayWalletPaymentMethod
     */
    encryptedGooglePay: EncryptedGooglePay;
}

/**
 * Encrypted Samsung Pay payload.
 * @export
 * @interface EncryptedSamsungPay
 */
export interface EncryptedSamsungPay {
    /**
     * The encrypted wallet payload.
     * @type {string}
     * @memberof EncryptedSamsungPay
     */
    data: string;
    /**
     * Identifies under which encryption/signing scheme this message has been created. In this way, the protocol can evolve over time if needed. For Google Payments transactions, this should be set to ECv1.
     * @type {string}
     * @memberof EncryptedSamsungPay
     */
    version?: string;
}

/**
 * Wallet payment method containing encrypted Samsung Pay information.
 * @export
 * @interface EncryptedSamsungPayWalletPaymentMethod
 */
export interface EncryptedSamsungPayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {EncryptedSamsungPay}
     * @memberof EncryptedSamsungPayWalletPaymentMethod
     */
    encryptedSamsungPay: EncryptedSamsungPay;
}

/**
 * Provides clearing response information for the specific endpoint.
 * @export
 * @interface EndpointResponse
 */
export interface EndpointResponse {
    /**
     * Specifies the identifier of an endpoint.
     * @type {string}
     * @memberof EndpointResponse
     */
    endpointID?: string;
    /**
     * Defines the clearing status of an endpoint.
     * @type {string}
     * @memberof EndpointResponse
     */
    status?: EndpointResponse.StatusEnum;
    /**
     * Defines the batch number of an endpoint clearing process.
     * @type {string}
     * @memberof EndpointResponse
     */
    batchNumber?: string;
}

/**
 * @export
 * @namespace EndpointResponse
 */
export namespace EndpointResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        APPROVED = 'APPROVED',
        DECLINED = 'DECLINED',
        FAILED = 'FAILED'
    }
}

/**
 * 
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
    /**
     * The property or attribute associated with the error.
     * @type {string}
     * @memberof ErrorDetails
     */
    field?: string;
    /**
     * Information specific to a property or attribute.
     * @type {string}
     * @memberof ErrorDetails
     */
    message?: string;
}

/**
 * Error message.
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
    /**
     * Error code.
     * @type {string}
     * @memberof ErrorMessage
     */
    code?: string;
    /**
     * Error description.
     * @type {string}
     * @memberof ErrorMessage
     */
    description?: string;
}

/**
 * Response containing an error object.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse extends BasicResponse {
    /**
     * 
     * @type {Error}
     * @memberof ErrorResponse
     */
    error?: Error;
}

/**
 * Request to perform an exchange rate inquiry. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface ExchangeRateRequest
 */
export interface ExchangeRateRequest {
    /**
     * Object name of the exchange rate request.
     * @type {string}
     * @memberof ExchangeRateRequest
     */
    requestType: string;
    /**
     * The original amount of the merchant currency for calculation.
     * @type {number}
     * @memberof ExchangeRateRequest
     */
    baseAmount: number;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof ExchangeRateRequest
     */
    storeId?: string;
}

/**
 * Exchange rate response.
 * @export
 * @interface ExchangeRateResponse
 */
export interface ExchangeRateResponse extends BasicResponse {
    /**
     * The response transaction ID.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    ipgTransactionId?: string;
    /**
     * Time of the request.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    requestTime?: string;
    /**
     * Inquiry rate ID.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    inquiryRateId?: string;
    /**
     * Foreign currency in alphabetic ISO 4217 currency code format.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    foreignCurrency?: string;
    /**
     * Foreign amount.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    foreignAmount?: string;
    /**
     * Exchange rate.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    exchangeRate?: string;
    /**
     * Dcc offered.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    dccOffered?: string;
    /**
     * Exchange rate source timestamp.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    exchangeRateSourceTimestamp?: string;
    /**
     * Expiration timestamp.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    expirationTimestamp?: string;
    /**
     * Margin rate percentage.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    marginRatePercentage?: string;
    /**
     * Exchange rate source name.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    exchangeRateSourceName?: string;
}

/**
 * Required for normal transactions except for payment with 'RECURRING' flags.
 * @export
 * @interface Expiration
 */
export interface Expiration {
    /**
     * Month of the card expiration date in MM format.
     * @type {string}
     * @memberof Expiration
     */
    month: string;
    /**
     * Year of the card expiration date in YY format.
     * @type {string}
     * @memberof Expiration
     */
    year: string;
}

/**
 * Font face property.
 * @export
 * @enum {string}
 */
export enum FontFace {
    Arial = 'arial',
    CourierNew = 'courier new',
    TimesNewRoman = 'times new roman',
    TrebuchetMs = 'trebuchet ms',
    Verdana = 'verdana'
}

/**
 * Object contains font properties.
 * @export
 * @interface FontProperties
 */
export interface FontProperties {
    /**
     * 
     * @type {FontFace}
     * @memberof FontProperties
     */
    fontFace?: FontFace;
    /**
     * Font size property.
     * @type {string}
     * @memberof FontProperties
     */
    fontSize?: string;
    /**
     * 
     * @type {FontWeight}
     * @memberof FontProperties
     */
    fontWeight?: FontWeight;
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof FontProperties
     */
    fontColor?: string;
}

/**
 * Font weight property.
 * @export
 * @enum {string}
 */
export enum FontWeight {
    Normal = 'normal',
    Bold = 'bold'
}

/**
 * 
 * @export
 * @interface Footer
 */
export interface Footer {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Footer
     */
    color?: string;
}

/**
 * Address fields.
 * @export
 * @interface FraudAddress
 */
export interface FraudAddress {
    /**
     * First line of street address.
     * @type {string}
     * @memberof FraudAddress
     */
    street: string;
    /**
     * Second line of street address.
     * @type {string}
     * @memberof FraudAddress
     */
    street2?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof FraudAddress
     */
    stateProvince?: string;
    /**
     * City.
     * @type {string}
     * @memberof FraudAddress
     */
    city?: string;
    /**
     * Country.
     * @type {string}
     * @memberof FraudAddress
     */
    country: string;
    /**
     * Postal code.
     * @type {string}
     * @memberof FraudAddress
     */
    zipPostalCode: string;
}

/**
 * The list of items included in the order.
 * @export
 * @interface FraudOrder
 */
export interface FraudOrder {
    /**
     * 
     * @type {ShipToAddress}
     * @memberof FraudOrder
     */
    shipToAddress?: ShipToAddress;
    /**
     * The list of items included in the order.
     * @type {Array<FraudOrderItems>}
     * @memberof FraudOrder
     */
    items?: Array<FraudOrderItems>;
    /**
     * A JSON object that can carry any additional information about the order that might be helpful for fraud detection.
     * @type {any}
     * @memberof FraudOrder
     */
    userDefined?: any;
}

/**
 * Product details.
 * @export
 * @interface FraudOrderItems
 */
export interface FraudOrderItems {
    /**
     * A unique ID associated with the product. Must be unique within the merchant's system.
     * @type {string}
     * @memberof FraudOrderItems
     */
    id?: string;
    /**
     * A name or short description of the product.
     * @type {string}
     * @memberof FraudOrderItems
     */
    name?: string;
    /**
     * The unit in which the product is sold (e.g. litre, kilogram, etc). Leave empty if the product is sold as a complete unit.
     * @type {string}
     * @memberof FraudOrderItems
     */
    quantity?: string;
    /**
     * The number of units sold. Set to 1 if there is only one unit of the item. Leave empty if the quantity is unknown at the time of the request.
     * @type {number}
     * @memberof FraudOrderItems
     */
    unit?: number;
    /**
     * The price per unit.
     * @type {string}
     * @memberof FraudOrderItems
     */
    unitPrice?: string;
    /**
     * The categories that this product belongs to.
     * @type {string}
     * @memberof FraudOrderItems
     */
    categories?: string;
    /**
     * The URL to the merchant's management system, for reporting and analysis.
     * @type {string}
     * @memberof FraudOrderItems
     */
    detailsUrl?: string;
    /**
     * A JSON object that can carry any additional information about the order that might be helpful for fraud detection.
     * @type {any}
     * @memberof FraudOrderItems
     */
    userDefined?: any;
}

/**
 * 
 * @export
 * @interface FraudRegistration
 */
export interface FraudRegistration {
    /**
     * Merchant reference code. Used by FirstAPI and reflected in settlement records and webhook notifications. Typically, the merchantRef field is the purchase order number or unique sequence value associated to a given transaction.
     * @type {string}
     * @memberof FraudRegistration
     */
    merchantRef?: string;
    /**
     * Type of transaction merchant wants to process.
     * @type {string}
     * @memberof FraudRegistration
     */
    transactionType: string;
    /**
     * 
     * @type {Customer}
     * @memberof FraudRegistration
     */
    customer: Customer;
    /**
     * 
     * @type {Merchant}
     * @memberof FraudRegistration
     */
    merchant: Merchant;
    /**
     * 
     * @type {FraudRegistrationDevice}
     * @memberof FraudRegistration
     */
    device?: FraudRegistrationDevice;
    /**
     * A JSON object that can carry any additional information that might be helpful for fraud detection.
     * @type {any}
     * @memberof FraudRegistration
     */
    userDefined?: any;
}

/**
 * A JSON object that holds info about the payment registration card.
 * @export
 * @interface FraudRegistrationCard
 */
export interface FraudRegistrationCard {
    /**
     * The cardholder name as it appears on the card.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    cardholderName?: string;
    /**
     * Use this field to send clear PAN or tokens other than TransArmor Token.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    cardNumber?: string;
    /**
     * Payment method expiration date. Format is MMYYYY.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    expDate?: string;
    /**
     * CVV present indicator.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    cvvPresent?: string;
    /**
     * The company (usually a bank) that issued the card.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    issuer?: string;
    /**
     * A number that distinguishes between two plastic cards with the same card number in the event of the card being re-issued.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    cardReissuedNumber?: string;
}

/**
 * The device where this transaction originated.
 * @export
 * @interface FraudRegistrationDevice
 */
export interface FraudRegistrationDevice {
    /**
     * Defines the type of this object.
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    deviceType: FraudRegistrationDevice.DeviceTypeEnum;
    /**
     * The unique ID of the device. Must be unique for the entire system (not just within a specific merchant or industry).
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    deviceId: string;
    /**
     * Information about the networks associated with the device.
     * @type {Array<FraudRegistrationDeviceItems>}
     * @memberof FraudRegistrationDevice
     */
    networks?: Array<FraudRegistrationDeviceItems>;
    /**
     * The GPS decimal latitude, ranging from (-90.0 to 90.0) where positive numbers indicate locations North of the equator.
     * @type {number}
     * @memberof FraudRegistrationDevice
     */
    latitude?: number;
    /**
     * The GPS decimal longitude, ranging from (-180.0 to 180.0) where positive numbers indicate locations East of the IERS Reference Meridian.
     * @type {number}
     * @memberof FraudRegistrationDevice
     */
    longitude?: number;
    /**
     * The device's International Mobile Equipment Identity (IMEI) as described in IETF RFC7254.
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    imei?: string;
    /**
     * The device's model name.
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    model?: string;
    /**
     * The device's manufacturer.
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    manufacturer?: string;
    /**
     * The timezone offset from UTC to the devices timezone configuration, specified in the format +hh:mm.
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    timezoneOffset?: string;
    /**
     * A flag indicating that the device has been altered to allow privileged access to users. This flag should only be set to false if a test was performed and the result was negative. Leave unset otherwise.
     * @type {boolean}
     * @memberof FraudRegistrationDevice
     */
    rooted?: boolean;
    /**
     * A flag indicating that malware was detected on the mobile phone. This flag should only be set to false if a test was performed and the result was negative. Leave unset otherwise.
     * @type {boolean}
     * @memberof FraudRegistrationDevice
     */
    malwareDetected?: boolean;
    /**
     * A JSON object that can carry any additional information about the device that might be helpful for fraud detection.
     * @type {any}
     * @memberof FraudRegistrationDevice
     */
    userDefined?: any;
}

/**
 * @export
 * @namespace FraudRegistrationDevice
 */
export namespace FraudRegistrationDevice {
    /**
     * @export
     * @enum {string}
     */
    export enum DeviceTypeEnum {
        Pos = 'device/pos',
        Mobile = 'device/mobile'
    }
}

/**
 * Network information.
 * @export
 * @interface FraudRegistrationDeviceItems
 */
export interface FraudRegistrationDeviceItems {
    /**
     * Defines the type of network associated with the device.
     * @type {string}
     * @memberof FraudRegistrationDeviceItems
     */
    networkType: FraudRegistrationDeviceItems.NetworkTypeEnum;
    /**
     * The IPv4 or IPv6 address of the device if the network assigned one.
     * @type {string}
     * @memberof FraudRegistrationDeviceItems
     */
    ip?: string;
    /**
     * The MAC address of the device that is connected to the Wi-Fi network.
     * @type {string}
     * @memberof FraudRegistrationDeviceItems
     */
    mac?: string;
    /**
     * The Wi-Fi networks Service Set Identifier (SSID).
     * @type {string}
     * @memberof FraudRegistrationDeviceItems
     */
    ssid?: string;
    /**
     * The Wi-Fi networks Basic Service Set Identifier (BSSID).
     * @type {string}
     * @memberof FraudRegistrationDeviceItems
     */
    bssid?: string;
    /**
     * A JSON object that can carry any additional information about the network that might be helpful for fraud detection.
     * @type {any}
     * @memberof FraudRegistrationDeviceItems
     */
    userDefined?: any;
}

/**
 * @export
 * @namespace FraudRegistrationDeviceItems
 */
export namespace FraudRegistrationDeviceItems {
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkTypeEnum {
        Mobile = 'network/mobile',
        Wifi = 'network/wifi'
    }
}

/**
 * Error occurred during the registration.
 * @export
 * @interface FraudRegistrationError
 */
export interface FraudRegistrationError {
    /**
     * 
     * @type {Array<ErrorMessage>}
     * @memberof FraudRegistrationError
     */
    messages?: Array<ErrorMessage>;
}

/**
 * 
 * @export
 * @interface FraudRegistrationResponse
 */
export interface FraudRegistrationResponse {
    /**
     * The value used to track the transaction.
     * @type {string}
     * @memberof FraudRegistrationResponse
     */
    correlationId?: string;
    /**
     * Status of the transaction. Valid values are 'Not Processed' and 'Scored successfully'
     * @type {string}
     * @memberof FraudRegistrationResponse
     */
    transactionStatus?: FraudRegistrationResponse.TransactionStatusEnum;
    /**
     * If status returned is \"failure\", input validation errors occurred. Please refer to the \"Errors Section\" for more info. Valid values are 'success' and 'failed'.
     * @type {string}
     * @memberof FraudRegistrationResponse
     */
    validationStatus?: string;
    /**
     * The transactionType provided in request.
     * @type {string}
     * @memberof FraudRegistrationResponse
     */
    transactionType?: string;
    /**
     * 
     * @type {FraudScore}
     * @memberof FraudRegistrationResponse
     */
    fraudScore?: FraudScore;
    /**
     * 
     * @type {FraudRegistrationError}
     * @memberof FraudRegistrationResponse
     */
    error?: FraudRegistrationError;
}

/**
 * @export
 * @namespace FraudRegistrationResponse
 */
export namespace FraudRegistrationResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStatusEnum {
        ScoredSuccessfully = 'Scored successfully',
        NotProcessed = 'Not Processed'
    }
}

/**
 * Fraud likelihood assessment consisting of a score, associated warning(s), and explanation(s) of score received.
 * @export
 * @interface FraudScore
 */
export interface FraudScore {
    /**
     * The score attributed to this request by our machine learning system, ranging from 0 (less likely to be fraud) to 1000 (more likely to be fraud).
     * @type {string}
     * @memberof FraudScore
     */
    score?: string;
    /**
     * A list of non-critical warnings raised while processing the request. Warnings included in this list will have integration and data-quality related messages.
     * @type {Array<string>}
     * @memberof FraudScore
     */
    warnings?: Array<string>;
    /**
     * Explanation of the fraud score applied consisting of a description, type of the explanation, and rule (if applicable).
     * @type {Array<any>}
     * @memberof FraudScore
     */
    explanations?: Array<any>;
    /**
     * The score attributed to this request by our machine learning system, ranging from 0 (less likely to be fraud) to 1000 (more likely to be fraud).
     * @type {string}
     * @memberof FraudScore
     */
    recommendedDecision?: string;
}

/**
 * Object that holds all fraud settings.
 * @export
 * @interface FraudSettings
 */
export interface FraudSettings {
    /**
     * 
     * @type {BlockedItems}
     * @memberof FraudSettings
     */
    blockedItems?: BlockedItems;
    /**
     * 
     * @type {Array<MaximumPurchaseAmount>}
     * @memberof FraudSettings
     */
    maximumPurchaseAmount?: Array<MaximumPurchaseAmount>;
    /**
     * 
     * @type {LockoutTime}
     * @memberof FraudSettings
     */
    lockoutTime?: LockoutTime;
    /**
     * 
     * @type {CountryProfile}
     * @memberof FraudSettings
     */
    countryProfile?: CountryProfile;
}

/**
 * Response from fraud settings request.
 * @export
 * @interface FraudSettingsResponse
 */
export interface FraudSettingsResponse extends BasicResponse {
    /**
     * The outlet ID.
     * @type {string}
     * @memberof FraudSettingsResponse
     */
    storeId?: string;
    /**
     * List of blocked card numbers.
     * @type {Array<BlockedCardNumber>}
     * @memberof FraudSettingsResponse
     */
    blockedCardNumbers?: Array<BlockedCardNumber>;
    /**
     * List of blocked fraud names.
     * @type {Array<string>}
     * @memberof FraudSettingsResponse
     */
    blockedNames?: Array<string>;
    /**
     * List of blocked fraud domain names.
     * @type {Array<string>}
     * @memberof FraudSettingsResponse
     */
    blockedDomainNames?: Array<string>;
    /**
     * List of blocked fraud IP address/Class C.
     * @type {Array<string>}
     * @memberof FraudSettingsResponse
     */
    blockedIpOrClassCAddresses?: Array<string>;
    /**
     * Maximum purchase amount limit.
     * @type {Array<MaximumPurchaseAmount>}
     * @memberof FraudSettingsResponse
     */
    maximumPurchaseAmount?: Array<MaximumPurchaseAmount>;
    /**
     * 
     * @type {LockoutTime}
     * @memberof FraudSettingsResponse
     */
    lockoutTime?: LockoutTime;
    /**
     * Country profile.
     * @type {string}
     * @memberof FraudSettingsResponse
     */
    countryProfile?: string;
}

/**
 * How often payments are sent.
 * @export
 * @interface Frequency
 */
export interface Frequency {
    /**
     * Rate of frequency.
     * @type {number}
     * @memberof Frequency
     */
    every: number;
    /**
     * Unit which defines the frequency.
     * @type {string}
     * @memberof Frequency
     */
    unit: Frequency.UnitEnum;
}

/**
 * @export
 * @namespace Frequency
 */
export namespace Frequency {
    /**
     * @export
     * @enum {string}
     */
    export enum UnitEnum {
        DAY = 'DAY',
        WEEK = 'WEEK',
        MONTH = 'MONTH',
        YEAR = 'YEAR'
    }
}

/**
 * Pull disbursement information.
 * @export
 * @interface FundingTransactionType
 */
export interface FundingTransactionType extends Disbursement {
}

/**
 * 
 * @export
 * @interface Header
 */
export interface Header {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Header
     */
    color?: string;
}

/**
 * 
 * @export
 * @interface Hover
 */
export interface Hover {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Hover
     */
    color?: string;
}

/**
 * Industry-specific information.
 * @export
 * @interface IndustrySpecificExtensions
 */
export interface IndustrySpecificExtensions {
    /**
     * 
     * @type {Airline}
     * @memberof IndustrySpecificExtensions
     */
    airline?: Airline;
    /**
     * 
     * @type {Lodging}
     * @memberof IndustrySpecificExtensions
     */
    lodging?: Lodging;
    /**
     * 
     * @type {CarRental}
     * @memberof IndustrySpecificExtensions
     */
    carRental?: CarRental;
    /**
     * 
     * @type {Mcc6012}
     * @memberof IndustrySpecificExtensions
     */
    mcc6012?: Mcc6012;
}

/**
 * 
 * @export
 * @interface InitiateClearingResponse
 */
export interface InitiateClearingResponse extends BasicResponse {
    /**
     * Request status. If it is anything other than 'SUCCESS', please refer to 400s HTTP error codes or decline. See Error object for details.
     * @type {string}
     * @memberof InitiateClearingResponse
     */
    requestStatus?: InitiateClearingResponse.RequestStatusEnum;
    /**
     * 
     * @type {ClearingDetails}
     * @memberof InitiateClearingResponse
     */
    clearingDetails?: ClearingDetails;
    /**
     * The array holds response information of the involved endpoints.
     * @type {Array<EndpointResponse>}
     * @memberof InitiateClearingResponse
     */
    endpointResponses?: Array<EndpointResponse>;
}

/**
 * @export
 * @namespace InitiateClearingResponse
 */
export namespace InitiateClearingResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum RequestStatusEnum {
        SUCCESS = 'SUCCESS',
        PROCESSINGFAILED = 'PROCESSING_FAILED',
        FAILURE = 'FAILURE'
    }
}

/**
 * Indicates that the total sum payable is divided for payment at successive fixed times.
 * @export
 * @interface InstallmentOptions
 */
export interface InstallmentOptions {
    /**
     * Number of installments for a sale transaction if the customer pays the total amount in multiple transactions.
     * @type {number}
     * @memberof InstallmentOptions
     */
    numberOfInstallments?: number;
    /**
     * Indicates whether the installment interest amount has been applied.
     * @type {boolean}
     * @memberof InstallmentOptions
     */
    installmentsInterest?: boolean;
    /**
     * The number of months the first installment payment will be delayed.
     * @type {number}
     * @memberof InstallmentOptions
     */
    installmentDelayMonths?: number;
    /**
     * The type of recurring payment.
     * @type {string}
     * @memberof InstallmentOptions
     */
    recurringType?: InstallmentOptions.RecurringTypeEnum;
    /**
     * Indicates if the merchant supports merchant advice code (MAC) in order to receive table 55 code for a declined recurring transaction.
     * @type {boolean}
     * @memberof InstallmentOptions
     */
    merchantAdviceCodeSupported?: boolean;
}

/**
 * @export
 * @namespace InstallmentOptions
 */
export namespace InstallmentOptions {
    /**
     * @export
     * @enum {string}
     */
    export enum RecurringTypeEnum {
        FIRST = 'FIRST',
        REPEAT = 'REPEAT',
        STANDINGINSTRUCTION = 'STANDING_INSTRUCTION'
    }
}

/**
 * The issuers response to the payment request. This field should be filled in when the message has already passed through the issuer (e.g. post-authorization).
 * @export
 * @interface IssuerResponse
 */
export interface IssuerResponse {
    /**
     * The verification response code, as sent by the verification system.
     * @type {string}
     * @memberof IssuerResponse
     */
    code: string;
    /**
     * The interpretation of the response code. Valid values are \"approved\" - The verification was conducted and is approved. \"declined\" - The verification was conducted and is not approved. \"disabled\" - The verification was not conducted because it was not requested or disabled in the verification. \"unknown\" - The verification was attempted but it failed due to some system error (e.g. timeout).
     * @type {string}
     * @memberof IssuerResponse
     */
    status?: IssuerResponse.StatusEnum;
    /**
     * An identifier of the system/specification from which the code was received, and how the status was derived.
     * @type {string}
     * @memberof IssuerResponse
     */
    scheme: string;
}

/**
 * @export
 * @namespace IssuerResponse
 */
export namespace IssuerResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        Approved = 'approved',
        Declined = 'declined',
        Disabled = 'disabled',
        Unknown = 'unknown'
    }
}

/**
 * Network information.
 * @export
 * @interface Items
 */
export interface Items {
    /**
     * Defines the type of network associated with the device.
     * @type {string}
     * @memberof Items
     */
    networkType: Items.NetworkTypeEnum;
    /**
     * The IPv4 or IPv6 address of the device if the network assigned one.
     * @type {string}
     * @memberof Items
     */
    ip?: string;
    /**
     * The devices primary phone number. This value should be supplied directly without any transformation (e.g. removal of spaces, hyphens or parentheses). If this data is available in segregated fields, it should be concatenated using a blank space (\" \") as a separator.
     * @type {string}
     * @memberof Items
     */
    phoneNumber?: string;
    /**
     * The network carrier name.
     * @type {string}
     * @memberof Items
     */
    carrierName?: string;
    /**
     * The Mobile Country Code (MCC) as described in the ITUs E.212 specification.
     * @type {string}
     * @memberof Items
     */
    mobileCountryCode?: string;
    /**
     * The Mobile Network Code (MNC) as described in the ITUs E.212 specification.
     * @type {string}
     * @memberof Items
     */
    mobileNetworkCode?: string;
    /**
     * The Mobile Subscription Identification Number code (MSIN) as described in the ITUs E.212 specification.
     * @type {string}
     * @memberof Items
     */
    subscriptionIdentificationNumber?: string;
    /**
     * The Location Area Code (LAC) is a 16-bit identifier for a region that is covered by a set of network antennas.
     * @type {string}
     * @memberof Items
     */
    locationAreaCode?: string;
    /**
     * The Cell ID (CID) is identifier for a specific Base Transceiver Station (BTS) within a specific Location Area Code (LAC).
     * @type {string}
     * @memberof Items
     */
    cellId?: string;
    /**
     * An identifier of the network standard used.
     * @type {string}
     * @memberof Items
     */
    standard?: string;
    /**
     * The MAC address of the device that is connected to the Wi-Fi network.
     * @type {string}
     * @memberof Items
     */
    mac?: string;
    /**
     * The Wi-Fi networks Service Set Identifier (SSID).
     * @type {string}
     * @memberof Items
     */
    ssid?: string;
    /**
     * The Wi-Fi networks Basic Service Set Identifier (BSSID).
     * @type {string}
     * @memberof Items
     */
    bssid?: string;
    /**
     * A JSON object that can carry any additional information about the network that might be helpful for fraud detection.
     * @type {any}
     * @memberof Items
     */
    userDefined?: any;
}

/**
 * @export
 * @namespace Items
 */
export namespace Items {
    /**
     * @export
     * @enum {string}
     */
    export enum NetworkTypeEnum {
        Mobile = 'network/mobile',
        Wifi = 'network/wifi'
    }
}

/**
 * The specific location (e.g. store or station) where the transaction takes place.
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * The unique ID of this location.
     * @type {string}
     * @memberof Location
     */
    locationId?: string;
    /**
     * 
     * @type {FraudAddress}
     * @memberof Location
     */
    merchantAddress?: FraudAddress;
    /**
     * Free-text field to describe a hierarchy the merchant would like to provide.
     * @type {string}
     * @memberof Location
     */
    hierarchy?: string;
    /**
     * The timezone offset from UTC to the merchants timezone configuration, specified in the format +hh:mm.
     * @type {string}
     * @memberof Location
     */
    timezoneOffset?: string;
    /**
     * A JSON object that can carry any additional information about the location that might be helpful for fraud detection.
     * @type {any}
     * @memberof Location
     */
    userDefined?: any;
}

/**
 * Object that holds information about lockout times.
 * @export
 * @interface LockoutTime
 */
export interface LockoutTime {
    /**
     * Auto-lockout time.
     * @type {number}
     * @memberof LockoutTime
     */
    autoLockoutTime?: number;
    /**
     * Duplicate lockout time.
     * @type {number}
     * @memberof LockoutTime
     */
    duplicateLockoutTime?: number;
}

/**
 * Additional data specific to the lodging/hotel industry.
 * @export
 * @interface Lodging
 */
export interface Lodging {
    /**
     * Date of arrival.
     * @type {string}
     * @memberof Lodging
     */
    arrivalDate?: string;
    /**
     * Date of departure.
     * @type {string}
     * @memberof Lodging
     */
    departureDate?: string;
    /**
     * Portfolio number.
     * @type {string}
     * @memberof Lodging
     */
    folioNumber?: string;
    /**
     * Information about charges other than base lodging.
     * @type {Array<LodgingExtraCharges>}
     * @memberof Lodging
     */
    extraCharges?: Array<LodgingExtraCharges>;
    /**
     * Indicates if the transaction is associated with a delayed or no-show penalty.
     * @type {boolean}
     * @memberof Lodging
     */
    noShowIndicator?: boolean;
}

/**
 * 
 * @export
 * @interface LodgingExtraCharges
 */
export interface LodgingExtraCharges {
    /**
     * 
     * @type {string}
     * @memberof LodgingExtraCharges
     */
    chargeItem?: LodgingExtraCharges.ChargeItemEnum;
}

/**
 * @export
 * @namespace LodgingExtraCharges
 */
export namespace LodgingExtraCharges {
    /**
     * @export
     * @enum {string}
     */
    export enum ChargeItemEnum {
        GIFTSHOP = 'GIFT_SHOP',
        LAUNDRY = 'LAUNDRY',
        MINIBAR = 'MINI_BAR',
        RESTAURANT = 'RESTAURANT',
        TELEPHONE = 'TELEPHONE',
        OTHER = 'OTHER'
    }
}

/**
 * Object contains logo data.
 * @export
 * @interface Logo
 */
export interface Logo {
    /**
     * Define position of logo.
     * @type {string}
     * @memberof Logo
     */
    position: Logo.PositionEnum;
    /**
     * The filename of the uploaded logo.
     * @type {string}
     * @memberof Logo
     */
    filename: string;
    /**
     * Base64 image data.
     * @type {string}
     * @memberof Logo
     */
    data: string;
}

/**
 * @export
 * @namespace Logo
 */
export namespace Logo {
    /**
     * @export
     * @enum {string}
     */
    export enum PositionEnum {
        TOP = 'TOP',
        BOTTOM = 'BOTTOM'
    }
}

/**
 * The loyalty program information associated with this payment.
 * @export
 * @interface Loyalty
 */
export interface Loyalty {
    /**
     * A unique ID associated with the loyalty program account. Must be unique within the merchants system. Depending on loyalty programs the account might also serve as a credit/bank account. If this is the case the ID must be not be the PAN.
     * @type {string}
     * @memberof Loyalty
     */
    id?: string;
    /**
     * A string that identifies the program in which the customer is enrolled if the merchant supports several programs or levels.
     * @type {string}
     * @memberof Loyalty
     */
    program?: string;
    /**
     * The balance of the loyalty program account in a program specific currency (e.g. points).
     * @type {number}
     * @memberof Loyalty
     */
    balance?: number;
}

/**
 * Object that holds information about maximum purchase amount limit.
 * @export
 * @interface MaximumPurchaseAmount
 */
export interface MaximumPurchaseAmount {
    /**
     * Currency in alphabetic ISO 4217 currency code format.
     * @type {string}
     * @memberof MaximumPurchaseAmount
     */
    currency: string;
    /**
     * Maximum purchase amount limit.
     * @type {string}
     * @memberof MaximumPurchaseAmount
     */
    maxAmount: string;
}

/**
 * The group MCC (Merchant Category Code) 6012
 * @export
 * @interface Mcc6012
 */
export interface Mcc6012 {
    /**
     * The date of birth of the cardholder (YYYYMMDD).
     * @type {string}
     * @memberof Mcc6012
     */
    dateOfBirth?: string;
    /**
     * The first six digits of the primary account number.
     * @type {string}
     * @memberof Mcc6012
     */
    accountFirst6?: string;
    /**
     * The last four digits of the primary account number.
     * @type {string}
     * @memberof Mcc6012
     */
    accountLast4?: string;
    /**
     * The account number where the primary account number is not a card.
     * @type {string}
     * @memberof Mcc6012
     */
    accountNum?: string;
    /**
     * The postal code of the cardholder.
     * @type {string}
     * @memberof Mcc6012
     */
    postCode?: string;
    /**
     * Surname or last name of the card holder.
     * @type {string}
     * @memberof Mcc6012
     */
    surname?: string;
}

/**
 * The merchant where this transaction occurred.
 * @export
 * @interface Merchant
 */
export interface Merchant {
    /**
     * The 4-digit Merchant Category Code. The merchant might be associated with multiple MCCs. In that case the MCC provided here will be the one that better describes the current transaction.
     * @type {string}
     * @memberof Merchant
     */
    mcc?: string;
    /**
     * The unique ID of this merchant. Must be unique for the entire system (not just within a specific industry).
     * @type {string}
     * @memberof Merchant
     */
    merchantUniqueId: string;
    /**
     * 
     * @type {Location}
     * @memberof Merchant
     */
    location?: Location;
    /**
     * A JSON object that can carry any additional information about the merchant that might be helpful for fraud detection.
     * @type {any}
     * @memberof Merchant
     */
    userDefined?: any;
}

/**
 * Info about the payment method.
 * @export
 * @interface Method
 */
export interface Method {
    /**
     * Unique ID for the payment method type.
     * @type {string}
     * @memberof Method
     */
    methodType: Method.MethodTypeEnum;
    /**
     * The unique ID of this payment method if it was previously registered with a registration/method or if it is currently being registered. Must be unique for the entire system (not just within a specific merchant or industry). Mandatory if being used inside a registration/method.
     * @type {string}
     * @memberof Method
     */
    methodId?: string;
    /**
     * The address that should be used to send billing information for this payment method.
     * @type {string}
     * @memberof Method
     */
    methodAlias?: string;
    /**
     * 
     * @type {Card}
     * @memberof Method
     */
    card: Card;
    /**
     * The wallet provider. This field should be normalized before sending through the API.
     * @type {string}
     * @memberof Method
     */
    provider?: string;
    /**
     * A JSON object that can carry any additional information about the method that might be helpful for fraud detection.
     * @type {any}
     * @memberof Method
     */
    userDefined?: any;
}

/**
 * @export
 * @namespace Method
 */
export namespace Method {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodTypeEnum {
        Card = 'method/card',
        Wallet = 'method/wallet'
    }
}

/**
 * Object contains configurable style properties for mobile.
 * @export
 * @interface Mobile
 */
export interface Mobile {
    /**
     * 
     * @type {MobileHeaderArea}
     * @memberof Mobile
     */
    headerArea?: MobileHeaderArea;
    /**
     * check if logo should be shown
     * @type {boolean}
     * @memberof Mobile
     */
    showLogo?: boolean;
}

/**
 * 
 * @export
 * @interface MobileHeaderArea
 */
export interface MobileHeaderArea {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof MobileHeaderArea
     */
    color?: string;
}

/**
 * Error information.
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Uniquely identifies an error condition. Client applications need to read and handle errors based on this.
     * @type {string}
     * @memberof ModelError
     */
    code?: string;
    /**
     * A generic description of the error condition.
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
    /**
     * Detailed information about message format errors.
     * @type {Array<ErrorDetails>}
     * @memberof ModelError
     */
    details?: Array<ErrorDetails>;
}

/**
 * Use this model to provide order related details.
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * Client Order ID if supplied by client.
     * @type {string}
     * @memberof Order
     */
    orderId?: string;
    /**
     * 
     * @type {Billing}
     * @memberof Order
     */
    billing?: Billing;
    /**
     * 
     * @type {Shipping}
     * @memberof Order
     */
    shipping?: Shipping;
    /**
     * 
     * @type {IndustrySpecificExtensions}
     * @memberof Order
     */
    industrySpecificExtensions?: IndustrySpecificExtensions;
    /**
     * 
     * @type {PurchaseCards}
     * @memberof Order
     */
    purchaseCard?: PurchaseCards;
    /**
     * 
     * @type {InstallmentOptions}
     * @memberof Order
     */
    installmentOptions?: InstallmentOptions;
    /**
     * 
     * @type {SoftDescriptor}
     * @memberof Order
     */
    softDescriptor?: SoftDescriptor;
    /**
     * 
     * @type {AdditionalDetails}
     * @memberof Order
     */
    additionalDetails?: AdditionalDetails;
    /**
     * 
     * @type {BancontactQR}
     * @memberof Order
     */
    bancontactQR?: BancontactQR;
}

/**
 * Order response with error field included.
 * @export
 * @interface OrderErrorResponse
 */
export interface OrderErrorResponse extends OrderResponse {
    /**
     * 
     * @type {Error}
     * @memberof OrderErrorResponse
     */
    error?: Error;
}

/**
 * Common object for primary and secondary payment request responses.
 * @export
 * @interface OrderResponse
 */
export interface OrderResponse extends BasicResponse {
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof OrderResponse
     */
    orderId?: string;
    /**
     * 
     * @type {Billing}
     * @memberof OrderResponse
     */
    billing?: Billing;
    /**
     * 
     * @type {Shipping}
     * @memberof OrderResponse
     */
    shipping?: Shipping;
    /**
     * Required for some payment methods (for example, Klarna).
     * @type {Array<TransactionResponse>}
     * @memberof OrderResponse
     */
    transactions?: Array<TransactionResponse>;
    /**
     * 
     * @type {AdditionalDetails}
     * @memberof OrderResponse
     */
    additionalDetails?: AdditionalDetails;
}

/**
 * The payment object for PayPal transactions.
 * @export
 * @interface PayPal
 */
export interface PayPal {
    /**
     * Email address of the recipient.
     * @type {string}
     * @memberof PayPal
     */
    recipientEmail: string;
}

/**
 * Payment method containing PayPal information.
 * @export
 * @interface PayPalPaymentMethod
 */
export interface PayPalPaymentMethod extends PaymentMethod {
    /**
     * 
     * @type {PayPal}
     * @memberof PayPalPaymentMethod
     */
    payPal: PayPal;
}

/**
 * Payment information for the transaction.
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * Defines the type of the payment.
     * @type {string}
     * @memberof Payment
     */
    paymentType: Payment.PaymentTypeEnum;
    /**
     * 
     * @type {Method}
     * @memberof Payment
     */
    method: Method;
    /**
     * Indicates if the cards Personal Identification Number was supplied.
     * @type {boolean}
     * @memberof Payment
     */
    pinPresent: boolean;
    /**
     * The method in which the card information entered the system.
     * @type {string}
     * @memberof Payment
     */
    entryMethod: Payment.EntryMethodEnum;
    /**
     * 
     * @type {IssuerResponse}
     * @memberof Payment
     */
    issuerResponse?: IssuerResponse;
    /**
     * The actual approved amount. This field should be filled in when the message has already passed through the issuer (e.g. post-authorization). For transaction/authorization this amount refers to the amount that was locked on the card-holders account.
     * @type {string}
     * @memberof Payment
     */
    issuerApprovedAmount?: string;
    /**
     * The payment methods account balance if available. This field should be filled in when the message has already passed through the issuer (e.g. post-authorization).
     * @type {string}
     * @memberof Payment
     */
    issuerCardBalance?: string;
    /**
     * 
     * @type {VerificationAvs}
     * @memberof Payment
     */
    verificationAvs?: VerificationAvs;
    /**
     * 
     * @type {Verification3ds}
     * @memberof Payment
     */
    verification3ds?: Verification3ds;
    /**
     * 
     * @type {VerificationCvv}
     * @memberof Payment
     */
    verificationCvv?: VerificationCvv;
    /**
     * A JSON object that carries any additional information that might be helpful for fraud detection.
     * @type {any}
     * @memberof Payment
     */
    userDefined?: any;
}

/**
 * @export
 * @namespace Payment
 */
export namespace Payment {
    /**
     * @export
     * @enum {string}
     */
    export enum PaymentTypeEnum {
        Card = 'payment/card',
        Wallet = 'payment/wallet'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum EntryMethodEnum {
        Manual = 'manual',
        Stripe = 'stripe',
        Ocr = 'ocr',
        Emv = 'emv',
        Nfc = 'nfc',
        Remote = 'remote',
        PinPresent = 'pin_present'
    }
}

/**
 * Payment card model.
 * @export
 * @interface PaymentCard
 */
export interface PaymentCard {
    /**
     * Payment card number.
     * @type {string}
     * @memberof PaymentCard
     */
    number: string;
    /**
     * 
     * @type {Expiration}
     * @memberof PaymentCard
     */
    expiryDate?: Expiration;
    /**
     * Card verification value/number.
     * @type {string}
     * @memberof PaymentCard
     */
    securityCode?: string;
    /**
     * 
     * @type {CardFunction}
     * @memberof PaymentCard
     */
    cardFunction?: CardFunction;
    /**
     * Name of the cardholder.
     * @type {string}
     * @memberof PaymentCard
     */
    cardholderName?: string;
    /**
     * The payment card BIN.
     * @type {string}
     * @memberof PaymentCard
     */
    bin?: string;
    /**
     * The last 4 numbers of a payment card.
     * @type {string}
     * @memberof PaymentCard
     */
    last4?: string;
    /**
     * Required only if using dual branded card.
     * @type {string}
     * @memberof PaymentCard
     */
    brand?: string;
}

/**
 * Request to create credit transaction using payment card.
 * @export
 * @interface PaymentCardCreditTransaction
 */
export interface PaymentCardCreditTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardCreditTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentCardCreditTransaction
     */
    currencyConversion?: CurrencyConversion;
}

/**
 * Request to create disbursement transaction using a payment card.
 * @export
 * @interface PaymentCardDisbursementTransaction
 */
export interface PaymentCardDisbursementTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {Disbursement}
     * @memberof PaymentCardDisbursementTransaction
     */
    disbursement: Disbursement;
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardDisbursementTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentCardDisbursementTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentCardDisbursementTransaction
     */
    createToken?: CreatePaymentToken;
}

/**
 * Request to create forced ticket primary transaction.
 * @export
 * @interface PaymentCardForcedTicketTransaction
 */
export interface PaymentCardForcedTicketTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardForcedTicketTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * Stores the six-digit reference number you have received as the result of a successful external authorization (e.g. by phone). The gateway needs this number for uniquely mapping a ForcedTicket transaction to a previously performed external authorization.
     * @type {string}
     * @memberof PaymentCardForcedTicketTransaction
     */
    referenceNumber: string;
}

/**
 * Request to create payer auth primary transaction.
 * @export
 * @interface PaymentCardPayerAuthTransaction
 */
export interface PaymentCardPayerAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardPayerAuthTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentCardPayerAuthTransaction
     */
    currencyConversion?: CurrencyConversion;
}

/**
 * Payment method containing payment card information.
 * @export
 * @interface PaymentCardPaymentMethod
 */
export interface PaymentCardPaymentMethod extends PaymentMethod {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentCardPaymentMethod
     */
    paymentCard: PaymentCard;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof PaymentCardPaymentMethod
     */
    paymentFacilitator?: PaymentFacilitator;
}

/**
 * Used to generate payment tokens during payment.
 * @export
 * @interface PaymentCardPaymentTokenizationRequest
 */
export interface PaymentCardPaymentTokenizationRequest extends PaymentTokenizationRequest {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentCardPaymentTokenizationRequest
     */
    paymentCard: PaymentCard;
}

/**
 * Request to create pre-auth transaction using credit card.
 * @export
 * @interface PaymentCardPreAuthTransaction
 */
export interface PaymentCardPreAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardPreAuthTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentCardPreAuthTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentCardPreAuthTransaction
     */
    createToken?: CreatePaymentToken;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PaymentCardPreAuthTransaction
     */
    splitShipment?: SplitShipment;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentCardPreAuthTransaction
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentCardPreAuthTransaction
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentCardPreAuthTransaction
     */
    authenticationResult?: AuthenticationResult;
}

/**
 * Request to create sale transaction using payment card.
 * @export
 * @interface PaymentCardSaleTransaction
 */
export interface PaymentCardSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardSaleTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentCardSaleTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentCardSaleTransaction
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentCardSaleTransaction
     */
    createToken?: CreatePaymentToken;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentCardSaleTransaction
     */
    currencyConversion?: CurrencyConversion;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentCardSaleTransaction
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentCardSaleTransaction
     */
    authenticationResult?: AuthenticationResult;
}

/**
 * Information from the payment device including the blob data and its mode of entry.
 * @export
 * @interface PaymentDevice
 */
export interface PaymentDevice {
    /**
     * The data format.
     * @type {string}
     * @memberof PaymentDevice
     */
    deviceType: PaymentDevice.DeviceTypeEnum;
    /**
     * Data from device containing, at a minimum, a transaction-unique key serial number (KSN) and track 2 card data.
     * @type {string}
     * @memberof PaymentDevice
     */
    data: string;
    /**
     * Card verification value/number.
     * @type {string}
     * @memberof PaymentDevice
     */
    securityCode?: string;
    /**
     * Name of cardholder.
     * @type {string}
     * @memberof PaymentDevice
     */
    cardholderName?: string;
    /**
     * 
     * @type {CardFunction}
     * @memberof PaymentDevice
     */
    cardFunction?: CardFunction;
    /**
     * The card brand.
     * @type {string}
     * @memberof PaymentDevice
     */
    brand?: string;
}

/**
 * @export
 * @namespace PaymentDevice
 */
export namespace PaymentDevice {
    /**
     * @export
     * @enum {string}
     */
    export enum DeviceTypeEnum {
        SWIPE = 'SWIPE'
    }
}

/**
 * Request to create credit transaction using decrypted card details from payment device. The transaction origin will be fixed as PHONE when data is manually entered into the device and as RETAIL when data is entered into the device via swipe.
 * @export
 * @interface PaymentDeviceCreditTransaction
 */
export interface PaymentDeviceCreditTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDeviceCreditTransaction
     */
    paymentMethod: PaymentDevicePaymentMethod;
}

/**
 * Request to create disbursement transaction using decrypted card details from payment device. The transaction origin will be fixed as PHONE when data is manually entered into the device and as RETAIL when data is entered into the device via swipe.
 * @export
 * @interface PaymentDeviceDisbursementTransaction
 */
export interface PaymentDeviceDisbursementTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDeviceDisbursementTransaction
     */
    paymentMethod: PaymentDevicePaymentMethod;
    /**
     * 
     * @type {Disbursement}
     * @memberof PaymentDeviceDisbursementTransaction
     */
    disbursement: Disbursement;
}

/**
 * Payment method containing payment device information.
 * @export
 * @interface PaymentDevicePaymentMethod
 */
export interface PaymentDevicePaymentMethod extends PaymentMethod {
    /**
     * 
     * @type {PaymentDevice}
     * @memberof PaymentDevicePaymentMethod
     */
    paymentDevice: PaymentDevice;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof PaymentDevicePaymentMethod
     */
    paymentFacilitator?: PaymentFacilitator;
}

/**
 * Used to generate payment tokens during payment using a payment device.
 * @export
 * @interface PaymentDevicePaymentTokenizationRequest
 */
export interface PaymentDevicePaymentTokenizationRequest extends PaymentTokenizationRequest {
    /**
     * 
     * @type {PaymentDevice}
     * @memberof PaymentDevicePaymentTokenizationRequest
     */
    paymentDevice: PaymentDevice;
}

/**
 * Request to create pre-auth transaction using decrypted card details from payment device. The transaction origin will be fixed as PHONE when data is manually entered into the device and as RETAIL when data is entered into the device via swipe.
 * @export
 * @interface PaymentDevicePreAuthTransaction
 */
export interface PaymentDevicePreAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDevicePreAuthTransaction
     */
    paymentMethod: PaymentDevicePaymentMethod;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentDevicePreAuthTransaction
     */
    createToken?: CreatePaymentToken;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentDevicePreAuthTransaction
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentDevicePreAuthTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PaymentDevicePreAuthTransaction
     */
    splitShipment?: SplitShipment;
}

/**
 * Request to create sale transaction using decrypted card details from payment device. The transaction origin will be fixed as PHONE when data is manually entered into the device and as RETAIL when data is entered into the device via swipe.
 * @export
 * @interface PaymentDeviceSaleTransaction
 */
export interface PaymentDeviceSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDeviceSaleTransaction
     */
    paymentMethod: PaymentDevicePaymentMethod;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentDeviceSaleTransaction
     */
    createToken?: CreatePaymentToken;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentDeviceSaleTransaction
     */
    storedCredentials?: StoredCredential;
}

/**
 * Payment facilitator details provided by the merchant.
 * @export
 * @interface PaymentFacilitator
 */
export interface PaymentFacilitator {
    /**
     * External merchant ID of the payment facilitator.
     * @type {string}
     * @memberof PaymentFacilitator
     */
    externalMerchantId: string;
    /**
     * Payment facilitator ID supplied during boarding.
     * @type {string}
     * @memberof PaymentFacilitator
     */
    paymentFacilitatorId: string;
    /**
     * Independent sales organization (ISO) ID provided by Mastercard.
     * @type {string}
     * @memberof PaymentFacilitator
     */
    saleOrganizationId?: string;
    /**
     * Payment facilitator name.
     * @type {string}
     * @memberof PaymentFacilitator
     */
    name: string;
    /**
     * 
     * @type {SubMerchantData}
     * @memberof PaymentFacilitator
     */
    subMerchantData?: SubMerchantData;
}

/**
 * Various payment methods the Gateway supports. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
}

/**
 * Provides details of the payment method used.
 * @export
 * @interface PaymentMethodDetails
 */
export interface PaymentMethodDetails {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentMethodDetails
     */
    paymentCard?: PaymentCard;
    /**
     * 
     * @type {PaymentMethodType}
     * @memberof PaymentMethodDetails
     */
    paymentMethodType?: PaymentMethodType;
}

/**
 * Request to create a new payment schedule using a payment method.
 * @export
 * @interface PaymentMethodPaymentSchedulesRequest
 */
export interface PaymentMethodPaymentSchedulesRequest extends PaymentSchedulesRequest {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentMethodPaymentSchedulesRequest
     */
    paymentMethod: PaymentCardPaymentMethod;
}

/**
 * Type of payment method.
 * @export
 * @enum {string}
 */
export enum PaymentMethodType {
    ALIPAY = 'ALIPAY',
    ALIPAYPAYSECUREUS = 'ALIPAY_PAYSECURE_US',
    ALIPAYDOMESTIC = 'ALIPAY_DOMESTIC',
    APM = 'APM',
    CUPDOMESTIC = 'CUP_DOMESTIC',
    DEBITDE = 'DEBITDE',
    EMI = 'EMI',
    GIROPAY = 'GIROPAY',
    IDEAL = 'IDEAL',
    INDIAWALLET = 'INDIAWALLET',
    KLARNA = 'KLARNA',
    KPS = 'KPS',
    NETBANKING = 'NETBANKING',
    PAYMENTCARD = 'PAYMENT_CARD',
    PAYMENTTOKEN = 'PAYMENT_TOKEN',
    PAYPAL = 'PAYPAL',
    SEPA = 'SEPA',
    SOFORT = 'SOFORT',
    WALLET = 'WALLET',
    WECHATDOMESTIC = 'WECHAT_DOMESTIC'
}

/**
 * 
 * @export
 * @interface PaymentRegistration
 */
export interface PaymentRegistration extends FraudRegistration {
    /**
     * Defines the type of the original transaction that is being evaluated for the Fraud Score.
     * @type {string}
     * @memberof PaymentRegistration
     */
    originalTransactionType?: string;
    /**
     * 
     * @type {IssuerResponse}
     * @memberof PaymentRegistration
     */
    issuerResponse?: IssuerResponse;
    /**
     * 
     * @type {VerificationAvs}
     * @memberof PaymentRegistration
     */
    verificationAvs?: VerificationAvs;
    /**
     * 
     * @type {Verification3ds}
     * @memberof PaymentRegistration
     */
    verification3ds?: Verification3ds;
    /**
     * 
     * @type {VerificationCvv}
     * @memberof PaymentRegistration
     */
    verificationCvv?: VerificationCvv;
    /**
     * 
     * @type {RegistrationMethod}
     * @memberof PaymentRegistration
     */
    registrationMethod?: RegistrationMethod;
}

/**
 * Payment schedules response with error field included.
 * @export
 * @interface PaymentSchedulesErrorResponse
 */
export interface PaymentSchedulesErrorResponse extends PaymentSchedulesResponse {
    /**
     * 
     * @type {Error}
     * @memberof PaymentSchedulesErrorResponse
     */
    error?: Error;
}

/**
 * @export
 * @namespace PaymentSchedulesErrorResponse
 */
export namespace PaymentSchedulesErrorResponse {
}

/**
 * Request to create a gateway schedule. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface PaymentSchedulesRequest
 */
export interface PaymentSchedulesRequest {
    /**
     * Object name of the payment schedules request.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    requestType: string;
    /**
     * Store ID number.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    storeId?: string;
    /**
     * Date of mandate signature.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    startDate: string;
    /**
     * Number of times the recurring payment will process.
     * @type {number}
     * @memberof PaymentSchedulesRequest
     */
    numberOfPayments?: number;
    /**
     * Number of failures that can be encountered before re-tries cease.
     * @type {number}
     * @memberof PaymentSchedulesRequest
     */
    maximumFailures?: number;
    /**
     * Invoice number.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    invoiceNumber?: string;
    /**
     * Purchase order number.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    purchaseOrderNumber?: string;
    /**
     * 
     * @type {TransactionOrigin}
     * @memberof PaymentSchedulesRequest
     */
    transactionOrigin?: TransactionOrigin;
    /**
     * Dynamic merchant name for the cardholder's statement.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    dynamicMerchantName?: string;
    /**
     * 
     * @type {Frequency}
     * @memberof PaymentSchedulesRequest
     */
    frequency: Frequency;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentSchedulesRequest
     */
    transactionAmount: Amount;
    /**
     * 
     * @type {ClientLocale}
     * @memberof PaymentSchedulesRequest
     */
    clientLocale?: ClientLocale;
    /**
     * Client order ID if supplied by client.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    orderId?: string;
    /**
     * 
     * @type {Billing}
     * @memberof PaymentSchedulesRequest
     */
    billing?: Billing;
    /**
     * 
     * @type {Shipping}
     * @memberof PaymentSchedulesRequest
     */
    shipping?: Shipping;
    /**
     * User supplied comments.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    comments?: string;
}

/**
 * Response from the gateway scheduler creation call.
 * @export
 * @interface PaymentSchedulesResponse
 */
export interface PaymentSchedulesResponse extends BasicResponse {
    /**
     * Result of requested operation. If it's anything other than 'SUCCESS', please refer to 400s HTTP error codes or decline. See Error object for details.
     * @type {string}
     * @memberof PaymentSchedulesResponse
     */
    requestStatus?: PaymentSchedulesResponse.RequestStatusEnum;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentSchedulesResponse
     */
    orderId?: string;
    /**
     * 
     * @type {TransactionResponse}
     * @memberof PaymentSchedulesResponse
     */
    transactionResponse?: TransactionResponse;
}

/**
 * @export
 * @namespace PaymentSchedulesResponse
 */
export namespace PaymentSchedulesResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum RequestStatusEnum {
        SUCCESS = 'SUCCESS',
        VALIDATIONFAILED = 'VALIDATION_FAILED',
        PROCESSINGFAILED = 'PROCESSING_FAILED',
        FAILURE = 'FAILURE',
        DECLINED = 'DECLINED'
    }
}

/**
 * Request to create credit transaction using payment token.
 * @export
 * @interface PaymentTokenCreditTransaction
 */
export interface PaymentTokenCreditTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenCreditTransaction
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentTokenCreditTransaction
     */
    currencyConversion?: CurrencyConversion;
}

/**
 * Response details for payment token creation.
 * @export
 * @interface PaymentTokenDetails
 */
export interface PaymentTokenDetails extends CreatePaymentToken {
    /**
     * The last 4 numbers of a payment card.
     * @type {string}
     * @memberof PaymentTokenDetails
     */
    last4?: string;
    /**
     * Card brand, only for tokenization with payment.
     * @type {string}
     * @memberof PaymentTokenDetails
     */
    brand?: string;
    /**
     * If the account the token was created from has been verified.
     * @type {boolean}
     * @memberof PaymentTokenDetails
     */
    accountVerification?: boolean;
    /**
     * Inidcates the type of tokenization source.
     * @type {string}
     * @memberof PaymentTokenDetails
     */
    type?: string;
}

/**
 * Request to create disbursement transaction using a payment token.
 * @export
 * @interface PaymentTokenDisbursementTransaction
 */
export interface PaymentTokenDisbursementTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {Disbursement}
     * @memberof PaymentTokenDisbursementTransaction
     */
    disbursement: Disbursement;
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenDisbursementTransaction
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentTokenDisbursementTransaction
     */
    storedCredentials?: StoredCredential;
}

/**
 * Payment method containing payment tokenization information.
 * @export
 * @interface PaymentTokenPaymentMethod
 */
export interface PaymentTokenPaymentMethod extends PaymentMethod {
    /**
     * 
     * @type {UsePaymentToken}
     * @memberof PaymentTokenPaymentMethod
     */
    paymentToken: UsePaymentToken;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof PaymentTokenPaymentMethod
     */
    paymentFacilitator?: PaymentFacilitator;
}

/**
 * Request to create pre-auth transaction using payment token.
 * @export
 * @interface PaymentTokenPreAuthTransaction
 */
export interface PaymentTokenPreAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenPreAuthTransaction
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentTokenPreAuthTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PaymentTokenPreAuthTransaction
     */
    splitShipment?: SplitShipment;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentTokenPreAuthTransaction
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentTokenPreAuthTransaction
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentTokenPreAuthTransaction
     */
    authenticationResult?: AuthenticationResult;
}

/**
 * Request to create sale transaction using payment token.
 * @export
 * @interface PaymentTokenSaleTransaction
 */
export interface PaymentTokenSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenSaleTransaction
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentTokenSaleTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentTokenSaleTransaction
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentTokenSaleTransaction
     */
    currencyConversion?: CurrencyConversion;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentTokenSaleTransaction
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentTokenSaleTransaction
     */
    authenticationResult?: AuthenticationResult;
}

/**
 * Payment tokenization response with error field included.
 * @export
 * @interface PaymentTokenizationErrorResponse
 */
export interface PaymentTokenizationErrorResponse extends PaymentTokenizationResponse {
    /**
     * 
     * @type {Error}
     * @memberof PaymentTokenizationErrorResponse
     */
    error?: Error;
}

/**
 * @export
 * @namespace PaymentTokenizationErrorResponse
 */
export namespace PaymentTokenizationErrorResponse {
}

/**
 * Used to generate payment tokens. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface PaymentTokenizationRequest
 */
export interface PaymentTokenizationRequest {
    /**
     * Object name of tokenization request.
     * @type {string}
     * @memberof PaymentTokenizationRequest
     */
    requestType: string;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof PaymentTokenizationRequest
     */
    storeId?: string;
    /**
     * 
     * @type {Address}
     * @memberof PaymentTokenizationRequest
     */
    billingAddress?: Address;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentTokenizationRequest
     */
    createToken: CreatePaymentToken;
    /**
     * If the account should be verified prior to token creation.
     * @type {boolean}
     * @memberof PaymentTokenizationRequest
     */
    accountVerification?: boolean;
}

/**
 * 
 * @export
 * @interface PaymentTokenizationResponse
 */
export interface PaymentTokenizationResponse extends BasicResponse {
    /**
     * The status of the request.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    requestStatus?: PaymentTokenizationResponse.RequestStatusEnum;
    /**
     * Time of the request.
     * @type {number}
     * @memberof PaymentTokenizationResponse
     */
    requestTime?: number;
    /**
     * Card brand.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    brand?: string;
    /**
     * Country of the card issued.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    country?: string;
    /**
     * 
     * @type {PaymentTokenDetails}
     * @memberof PaymentTokenizationResponse
     */
    paymentToken?: PaymentTokenDetails;
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentTokenizationResponse
     */
    paymentCard?: PaymentCard;
    /**
     * 
     * @type {ProcessorData}
     * @memberof PaymentTokenizationResponse
     */
    processor?: ProcessorData;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    orderId?: string;
}

/**
 * @export
 * @namespace PaymentTokenizationResponse
 */
export namespace PaymentTokenizationResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum RequestStatusEnum {
        DELETED = 'DELETED',
        FAILED = 'FAILED',
        SUCCESS = 'SUCCESS',
        APPROVED = 'APPROVED',
        WAITING = 'WAITING',
        VALIDATIONFAILED = 'VALIDATION_FAILED',
        DECLINED = 'DECLINED'
    }
}

/**
 * Detailed information about a payment URL.
 * @export
 * @interface PaymentUrlDetail
 */
export interface PaymentUrlDetail {
    /**
     * URL for embedded payment link.
     * @type {string}
     * @memberof PaymentUrlDetail
     */
    paymentUrl?: string;
    /**
     * The unique merchant transaction ID from the request, if supplied.
     * @type {string}
     * @memberof PaymentUrlDetail
     */
    merchantTransactionId?: string;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentUrlDetail
     */
    orderId?: string;
    /**
     * The transaction time in seconds since epoch.
     * @type {number}
     * @memberof PaymentUrlDetail
     */
    requestTime?: number;
    /**
     * 
     * @type {PaymentUrlStatus}
     * @memberof PaymentUrlDetail
     */
    status?: PaymentUrlStatus;
}

/**
 * Response from an embedded payment link request.
 * @export
 * @interface PaymentUrlDetailResponse
 */
export interface PaymentUrlDetailResponse extends BasicResponse {
    /**
     * Array of payment URL details.
     * @type {Array<PaymentUrlDetail>}
     * @memberof PaymentUrlDetailResponse
     */
    paymentUrlDetails?: Array<PaymentUrlDetail>;
}

/**
 * Payment URL response with error field included.
 * @export
 * @interface PaymentUrlErrorResponse
 */
export interface PaymentUrlErrorResponse extends PaymentUrlResponse {
    /**
     * 
     * @type {Error}
     * @memberof PaymentUrlErrorResponse
     */
    error?: Error;
}

/**
 * @export
 * @namespace PaymentUrlErrorResponse
 */
export namespace PaymentUrlErrorResponse {
}

/**
 * Request to generate an embedded payment link.
 * @export
 * @interface PaymentUrlRequest
 */
export interface PaymentUrlRequest {
    /**
     * An optional Outlet ID for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    storeId?: string;
    /**
     * 
     * @type {ClientLocale}
     * @memberof PaymentUrlRequest
     */
    clientLocale?: ClientLocale;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentUrlRequest
     */
    transactionAmount: Amount;
    /**
     * 
     * @type {TransactionType}
     * @memberof PaymentUrlRequest
     */
    transactionType: TransactionType;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    orderId?: string;
    /**
     * 
     * @type {Billing}
     * @memberof PaymentUrlRequest
     */
    billing?: Billing;
    /**
     * 
     * @type {Shipping}
     * @memberof PaymentUrlRequest
     */
    shipping?: Shipping;
    /**
     * URL for notifying merchant of payment result.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    transactionNotificationURL?: string;
    /**
     * Time until payment URL expires.
     * @type {number}
     * @memberof PaymentUrlRequest
     */
    expiration?: number;
    /**
     * If 3D secure should be applied.
     * @type {boolean}
     * @memberof PaymentUrlRequest
     */
    authenticateTransaction?: boolean;
    /**
     * Dynamic merchant name for the cardholder's statement.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    dynamicMerchantName?: string;
    /**
     * Invoice number.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    invoiceNumber?: string;
    /**
     * Purchase order number.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    purchaseOrderNumber?: string;
    /**
     * The text to be displayed to the payer on the hosted payment page.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    hostedPaymentPageText?: string;
    /**
     * IPv4 or IPv6 network address.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    ip?: string;
}

/**
 * Response from an embedded payment link request.
 * @export
 * @interface PaymentUrlResponse
 */
export interface PaymentUrlResponse extends BasicResponse {
    /**
     * Request status. If it is anything other than 'SUCCESS', please refer to 400s HTTP error codes or decline. See Error object for details.
     * @type {string}
     * @memberof PaymentUrlResponse
     */
    requestStatus?: PaymentUrlResponse.RequestStatusEnum;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentUrlResponse
     */
    orderId?: string;
    /**
     * URL for embedded payment link.
     * @type {string}
     * @memberof PaymentUrlResponse
     */
    paymentUrl?: string;
    /**
     * ID code from the transaction.
     * @type {string}
     * @memberof PaymentUrlResponse
     */
    transactionId?: string;
}

/**
 * @export
 * @namespace PaymentUrlResponse
 */
export namespace PaymentUrlResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum RequestStatusEnum {
        SUCCESS = 'SUCCESS',
        VALIDATIONFAILED = 'VALIDATION_FAILED',
        PROCESSINGFAILED = 'PROCESSING_FAILED',
        FAILURE = 'FAILURE'
    }
}

/**
 * The status of payment URL.
 * @export
 * @enum {string}
 */
export enum PaymentUrlStatus {
    Created = 'Created',
    Used = 'Used',
    Expired = 'Expired',
    Cancelled = 'Cancelled'
}

/**
 * Request to create credit transaction using PayPal.
 * @export
 * @interface PaypalCreditTransaction
 */
export interface PaypalCreditTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PayPalPaymentMethod}
     * @memberof PaypalCreditTransaction
     */
    paymentMethod: PayPalPaymentMethod;
}

/**
 * Phone number.
 * @export
 * @interface Phone
 */
export interface Phone {
    /**
     * Type of phone.
     * @type {string}
     * @memberof Phone
     */
    type?: string;
    /**
     * Free form phone number.
     * @type {string}
     * @memberof Phone
     */
    number?: string;
}

/**
 * Request to perform post auth transaction.
 * @export
 * @interface PostAuthTransaction
 */
export interface PostAuthTransaction extends SecondaryTransaction {
    /**
     * 
     * @type {Amount}
     * @memberof PostAuthTransaction
     */
    transactionAmount: Amount;
    /**
     * 
     * @type {TransactionOrigin}
     * @memberof PostAuthTransaction
     */
    transactionOrigin?: TransactionOrigin;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PostAuthTransaction
     */
    splitShipment?: SplitShipment;
    /**
     * 
     * @type {SoftDescriptor}
     * @memberof PostAuthTransaction
     */
    softDescriptor?: SoftDescriptor;
}

/**
 * 
 * @export
 * @interface Primary
 */
export interface Primary {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Primary
     */
    color?: string;
}

/**
 * Provides shared fields for all PrimaryTransaction request types. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface PrimaryTransaction
 */
export interface PrimaryTransaction {
    /**
     * Object name of the primary transaction request.
     * @type {string}
     * @memberof PrimaryTransaction
     */
    requestType: string;
    /**
     * 
     * @type {Amount}
     * @memberof PrimaryTransaction
     */
    transactionAmount: Amount;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof PrimaryTransaction
     */
    storeId?: string;
    /**
     * The unique merchant transaction ID from the request header, if supplied.
     * @type {string}
     * @memberof PrimaryTransaction
     */
    merchantTransactionId?: string;
    /**
     * 
     * @type {TransactionOrigin}
     * @memberof PrimaryTransaction
     */
    transactionOrigin?: TransactionOrigin;
    /**
     * 
     * @type {Order}
     * @memberof PrimaryTransaction
     */
    order?: Order;
}

/**
 * Model for processor data.
 * @export
 * @interface ProcessorData
 */
export interface ProcessorData {
    /**
     * Reference transaction ID.
     * @type {string}
     * @memberof ProcessorData
     */
    referenceNumber?: string;
    /**
     * Code returned to confirm transaction.
     * @type {string}
     * @memberof ProcessorData
     */
    authorizationCode?: string;
    /**
     * Response code from endpoints.
     * @type {string}
     * @memberof ProcessorData
     */
    responseCode?: string;
    /**
     * Network used for transaction.
     * @type {string}
     * @memberof ProcessorData
     */
    network?: string;
    /**
     * Raw response code from issuer.
     * @type {string}
     * @memberof ProcessorData
     */
    associationResponseCode?: string;
    /**
     * Message returned from endpoints.
     * @type {string}
     * @memberof ProcessorData
     */
    responseMessage?: string;
    /**
     * 
     * @type {AVSResponse}
     * @memberof ProcessorData
     */
    avsResponse?: AVSResponse;
    /**
     * Code returned for CVV.
     * @type {string}
     * @memberof ProcessorData
     */
    securityCodeResponse?: ProcessorData.SecurityCodeResponseEnum;
    /**
     * Code to map merchant advice code to ISO specification.
     * @type {string}
     * @memberof ProcessorData
     */
    merchantAdviceCodeIndicator?: string;
    /**
     * Indicates whether the transaction was routed through the payment card's own network or through a different network.
     * @type {string}
     * @memberof ProcessorData
     */
    responseIndicator?: string;
    /**
     * Receipt number from debit network provider.
     * @type {string}
     * @memberof ProcessorData
     */
    debitReceiptNumber?: string;
}

/**
 * @export
 * @namespace ProcessorData
 */
export namespace ProcessorData {
    /**
     * @export
     * @enum {string}
     */
    export enum SecurityCodeResponseEnum {
        MATCHED = 'MATCHED',
        NOTMATCHED = 'NOT_MATCHED',
        NOTPROCESSED = 'NOT_PROCESSED',
        NOTPRESENT = 'NOT_PRESENT',
        NOTCERTIFIED = 'NOT_CERTIFIED',
        NOTCHECKED = 'NOT_CHECKED'
    }
}

/**
 * Object contains font and color properties.
 * @export
 * @interface Properties
 */
export interface Properties {
    /**
     * 
     * @type {FontFace}
     * @memberof Properties
     */
    fontFace?: FontFace;
    /**
     * Font size property.
     * @type {string}
     * @memberof Properties
     */
    fontSize?: string;
    /**
     * 
     * @type {FontWeight}
     * @memberof Properties
     */
    fontWeight?: FontWeight;
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Properties
     */
    fontColor?: string;
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Properties
     */
    color?: string;
}

/**
 * Purchase card details.
 * @export
 * @interface PurchaseCards
 */
export interface PurchaseCards {
    /**
     * 
     * @type {PurchaseCardsLevel2}
     * @memberof PurchaseCards
     */
    level2?: PurchaseCardsLevel2;
    /**
     * 
     * @type {PurchaseCardsLevel3}
     * @memberof PurchaseCards
     */
    level3?: PurchaseCardsLevel3;
}

/**
 * Level 2 data for monitoring and controlling corporate expenditures.
 * @export
 * @interface PurchaseCardsLevel2
 */
export interface PurchaseCardsLevel2 {
    /**
     * Customer code/customer reference ID.
     * @type {string}
     * @memberof PurchaseCardsLevel2
     */
    customerReferenceID?: string;
    /**
     * Purchase identifier/merchant-related data.
     * @type {string}
     * @memberof PurchaseCardsLevel2
     */
    supplierInvoiceNumber?: string;
    /**
     * Merchant VAT registration/single business reference number/merchant tax ID or corporation VAT number.
     * @type {string}
     * @memberof PurchaseCardsLevel2
     */
    supplierVATRegistrationNumber?: string;
    /**
     * 
     * @type {AdditionalAmountRate}
     * @memberof PurchaseCardsLevel2
     */
    totalDiscountAmountAndRate?: AdditionalAmountRate;
    /**
     * 
     * @type {AdditionalAmountRate}
     * @memberof PurchaseCardsLevel2
     */
    vatShippingAmountAndRate?: AdditionalAmountRate;
}

/**
 * Level 3 data for monitoring and controlling corporate expenditures.
 * @export
 * @interface PurchaseCardsLevel3
 */
export interface PurchaseCardsLevel3 {
    /**
     * Line items of monitoring and controlling corporate expenditures data.
     * @type {Array<PurchaseCardsLevel3LineItems>}
     * @memberof PurchaseCardsLevel3
     */
    lineItems: Array<PurchaseCardsLevel3LineItems>;
}

/**
 * 
 * @export
 * @interface PurchaseCardsLevel3LineItems
 */
export interface PurchaseCardsLevel3LineItems {
    /**
     * The commodity code used to classify the item purchased.
     * @type {string}
     * @memberof PurchaseCardsLevel3LineItems
     */
    commodityCode?: string;
    /**
     * Merchant product identifier/the Universal Product Code (UPC) of the item purchased.
     * @type {string}
     * @memberof PurchaseCardsLevel3LineItems
     */
    productCode?: string;
    /**
     * The description.
     * @type {string}
     * @memberof PurchaseCardsLevel3LineItems
     */
    description?: string;
    /**
     * The quantity.
     * @type {number}
     * @memberof PurchaseCardsLevel3LineItems
     */
    quantity?: number;
    /**
     * The unit of measure.
     * @type {string}
     * @memberof PurchaseCardsLevel3LineItems
     */
    unitMeasure?: string;
    /**
     * Rate amount in 3 decimal 12 bytes total digit.
     * @type {number}
     * @memberof PurchaseCardsLevel3LineItems
     */
    unitPrice?: number;
    /**
     * 
     * @type {AdditionalAmountRate}
     * @memberof PurchaseCardsLevel3LineItems
     */
    vatAmountAndRate?: AdditionalAmountRate;
    /**
     * 
     * @type {AdditionalAmountRate}
     * @memberof PurchaseCardsLevel3LineItems
     */
    discountAmountAndRate?: AdditionalAmountRate;
    /**
     * Rate amount in 3 decimal 12 bytes total digit.
     * @type {number}
     * @memberof PurchaseCardsLevel3LineItems
     */
    lineItemTotal?: number;
}

/**
 * Receiver information for a funding transaction.
 * @export
 * @interface ReceiverInfo
 */
export interface ReceiverInfo {
    /**
     * Receiver name.
     * @type {string}
     * @memberof ReceiverInfo
     */
    name: string;
    /**
     * Receiver street address.
     * @type {string}
     * @memberof ReceiverInfo
     */
    streetAddress: string;
    /**
     * Receiver city.
     * @type {string}
     * @memberof ReceiverInfo
     */
    city: string;
    /**
     * Receiver state.
     * @type {string}
     * @memberof ReceiverInfo
     */
    stateCode: string;
    /**
     * Receiver country code.
     * @type {string}
     * @memberof ReceiverInfo
     */
    countryCode: string;
    /**
     * Receiver postal code.
     * @type {string}
     * @memberof ReceiverInfo
     */
    postalCode: string;
    /**
     * Receiver phone number.
     * @type {string}
     * @memberof ReceiverInfo
     */
    phoneNumber: string;
    /**
     * Receiver reference number.
     * @type {string}
     * @memberof ReceiverInfo
     */
    referenceNumber: string;
    /**
     * Receiver account number.
     * @type {string}
     * @memberof ReceiverInfo
     */
    accountNumber?: string;
}

/**
 * Details about existing gateway schedule.
 * @export
 * @interface RecurringPaymentDetails
 */
export interface RecurringPaymentDetails {
    /**
     * Store ID number.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    storeId?: string;
    /**
     * Purchase order number.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    purchaseOrderNumber?: string;
    /**
     * Invoice number.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    invoiceNumber?: string;
    /**
     * Date recurring payment was created.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    creationDate?: string;
    /**
     * Date of mandate signature.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    startDate?: string;
    /**
     * Date of next transaction process attempt.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    nextAttemptDate?: string;
    /**
     * 
     * @type {Amount}
     * @memberof RecurringPaymentDetails
     */
    transactionAmount?: Amount;
    /**
     * 
     * @type {PaymentMethodDetails}
     * @memberof RecurringPaymentDetails
     */
    paymentMethodDetails?: PaymentMethodDetails;
    /**
     * 
     * @type {Frequency}
     * @memberof RecurringPaymentDetails
     */
    frequency?: Frequency;
    /**
     * Number of times the recurring payment will process.
     * @type {number}
     * @memberof RecurringPaymentDetails
     */
    numberOfPayments?: number;
    /**
     * Times the recurring payment has already run.
     * @type {number}
     * @memberof RecurringPaymentDetails
     */
    runCount?: number;
    /**
     * State of the recurring payment.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    state?: RecurringPaymentDetails.StateEnum;
    /**
     * User supplied comments.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    comments?: string;
}

/**
 * @export
 * @namespace RecurringPaymentDetails
 */
export namespace RecurringPaymentDetails {
    /**
     * @export
     * @enum {string}
     */
    export enum StateEnum {
        Installed = 'Installed',
        Inactivated = 'Inactivated',
        Cancelled = 'Cancelled'
    }
}

/**
 * Order response containing recurring payment details.
 * @export
 * @interface RecurringPaymentDetailsResponse
 */
export interface RecurringPaymentDetailsResponse extends OrderResponse {
    /**
     * 
     * @type {RecurringPaymentDetails}
     * @memberof RecurringPaymentDetailsResponse
     */
    recurringPaymentDetails?: RecurringPaymentDetails;
}

/**
 * Request to create a new payment schedule using a referenced order ID.
 * @export
 * @interface ReferencedOrderPaymentSchedulesRequest
 */
export interface ReferencedOrderPaymentSchedulesRequest extends PaymentSchedulesRequest {
    /**
     * Order ID used to create recurring payment from existing transaction.
     * @type {string}
     * @memberof ReferencedOrderPaymentSchedulesRequest
     */
    referencedOrderId: string;
}

/**
 * Used to generate payment tokens with an existing order ID.
 * @export
 * @interface ReferencedOrderPaymentTokenizationRequest
 */
export interface ReferencedOrderPaymentTokenizationRequest extends PaymentTokenizationRequest {
    /**
     * Retrieves the payment instrument information from an existing order.
     * @type {string}
     * @memberof ReferencedOrderPaymentTokenizationRequest
     */
    referencedOrderId: string;
}

/**
 * A JSON object that holds info about the payment registration method.
 * @export
 * @interface RegistrationMethod
 */
export interface RegistrationMethod {
    /**
     * Unique ID for the payment method type.
     * @type {string}
     * @memberof RegistrationMethod
     */
    methodType: RegistrationMethod.MethodTypeEnum;
    /**
     * The unique ID of this payment method if it was previously registered with a registration/method or if it is currently being registered. Must be unique for the entire system (not just within a specific merchant or industry). Mandatory if being used inside a registration/method.
     * @type {string}
     * @memberof RegistrationMethod
     */
    methodId?: string;
    /**
     * A JSON object that carries any additional information that might be helpful for fraud detection.
     * @type {any}
     * @memberof RegistrationMethod
     */
    userDefined?: any;
    /**
     * The address that should be used to send billing information for this payment method.
     * @type {string}
     * @memberof RegistrationMethod
     */
    billingPhoneNumber?: string;
    /**
     * The address that should be used to send billing information for this payment method.
     * @type {string}
     * @memberof RegistrationMethod
     */
    methodAlias?: string;
    /**
     * 
     * @type {FraudRegistrationCard}
     * @memberof RegistrationMethod
     */
    card: FraudRegistrationCard;
    /**
     * 
     * @type {FraudAddress}
     * @memberof RegistrationMethod
     */
    methodAddress?: FraudAddress;
}

/**
 * @export
 * @namespace RegistrationMethod
 */
export namespace RegistrationMethod {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodTypeEnum {
        Card = 'method/card',
        Wallet = 'method/wallet'
    }
}

/**
 * Response from remove fraud blocked items request.
 * @export
 * @interface RemoveFraudBlockedItemsResponse
 */
export interface RemoveFraudBlockedItemsResponse extends BasicResponse {
    /**
     * Status from delete fraud blocked items operation.
     * @type {string}
     * @memberof RemoveFraudBlockedItemsResponse
     */
    status?: string;
}

/**
 * Amount component details, used in responses.
 * @export
 * @interface ResponseAmountComponents
 */
export interface ResponseAmountComponents extends AmountComponents {
    /**
     * Amount added for proccessing or handling fees.
     * @type {number}
     * @memberof ResponseAmountComponents
     */
    convenienceFee?: number;
}

/**
 * The type of the response.
 * @export
 * @enum {string}
 */
export enum ResponseType {
    BadRequest = 'BadRequest',
    Unauthenticated = 'Unauthenticated',
    Unauthorized = 'Unauthorized',
    NotFound = 'NotFound',
    GatewayDeclined = 'GatewayDeclined',
    EndpointDeclined = 'EndpointDeclined',
    ServerError = 'ServerError',
    EndpointCommunicationError = 'EndpointCommunicationError',
    UnsupportedMediaType = 'UnsupportedMediaType'
}

/**
 * Request to perform return transaction.
 * @export
 * @interface ReturnTransaction
 */
export interface ReturnTransaction extends SecondaryTransaction {
    /**
     * 
     * @type {Amount}
     * @memberof ReturnTransaction
     */
    transactionAmount: Amount;
    /**
     * 
     * @type {SoftDescriptor}
     * @memberof ReturnTransaction
     */
    softDescriptor?: SoftDescriptor;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof ReturnTransaction
     */
    currencyConversion?: CurrencyConversion;
}

/**
 * Fraud detect request payload.
 * @export
 * @interface ScoreOnlyRequest
 */
export interface ScoreOnlyRequest {
    /**
     * Merchant reference code. Used by FirstAPI and reflected in settlement records and Webhook notifications. Typically, the merchantRef field is the purchase order number or unique sequence value associated to a given transaction.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    merchantRef?: string;
    /**
     * Type of transaction merchant wants to process.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    transactionType: string;
    /**
     * Defines the type of the original transaction that is being evaluated for the Fraud Score.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    originalTransactionType: ScoreOnlyRequest.OriginalTransactionTypeEnum;
    /**
     * The unique ID of this transaction. Must be unique for the entire system (not just within a specific merchant or industry). Subsequent requests related to the same transaction must have the same transactionId (e.g. transaction/deposit or transaction/authorization-reversal). This field is used for matching transactions with settlement and chargeback information. If there is no such ID available you may wish to compose one from fields available in both systems. Consider including backend, issuer, merchant id, date and time, amount, etc. as necessary.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    originalTransactionId: string;
    /**
     * The amount processed for the original transaction.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    amount: string;
    /**
     * The currency of the original transaction.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    currencyCode: string;
    /**
     * 
     * @type {Customer}
     * @memberof ScoreOnlyRequest
     */
    customer?: Customer;
    /**
     * 
     * @type {BillingAddress}
     * @memberof ScoreOnlyRequest
     */
    billingAddress?: BillingAddress;
    /**
     * 
     * @type {Device}
     * @memberof ScoreOnlyRequest
     */
    device?: Device;
    /**
     * 
     * @type {Loyalty}
     * @memberof ScoreOnlyRequest
     */
    loyalty?: Loyalty;
    /**
     * 
     * @type {Payment}
     * @memberof ScoreOnlyRequest
     */
    payment: Payment;
    /**
     * 
     * @type {Merchant}
     * @memberof ScoreOnlyRequest
     */
    merchant: Merchant;
    /**
     * 
     * @type {FraudOrder}
     * @memberof ScoreOnlyRequest
     */
    order?: FraudOrder;
    /**
     * A JSON object that can carry any additional information that might be helpful for fraud detection.
     * @type {any}
     * @memberof ScoreOnlyRequest
     */
    userDefined?: any;
}

/**
 * @export
 * @namespace ScoreOnlyRequest
 */
export namespace ScoreOnlyRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum OriginalTransactionTypeEnum {
        Authorization = 'transaction/authorization',
        AuthorizationReversal = 'transaction/authorization-reversal',
        Deposit = 'transaction/deposit',
        DepositReversal = 'transaction/deposit-reversal',
        Purchase = 'transaction/purchase',
        PurchaseReversal = 'transaction/purchase-reversal',
        RefundAuthorization = 'transaction/refund-authorization',
        RefundDeposit = 'transaction/refund-deposit',
        Verification = 'transaction/verification',
        BalanceInquiry = 'transaction/balance-inquiry'
    }
}

/**
 * Fraud detect response.
 * @export
 * @interface ScoreOnlyResponse
 */
export interface ScoreOnlyResponse {
    /**
     * Unique trace ID for issue triage.
     * @type {string}
     * @memberof ScoreOnlyResponse
     */
    apiTraceId?: string;
    /**
     * Please refer to \"Errors Section\" for more info.
     * @type {string}
     * @memberof ScoreOnlyResponse
     */
    transactionStatus?: ScoreOnlyResponse.TransactionStatusEnum;
    /**
     * If status returned is \"failure\", input validation errors occurred. Please refer to the \"Errors Section\" for more info. Valid values are 'success' and 'failure'.
     * @type {string}
     * @memberof ScoreOnlyResponse
     */
    validationStatus?: string;
    /**
     * The transactionType provided in request.
     * @type {string}
     * @memberof ScoreOnlyResponse
     */
    transactionType?: string;
    /**
     * 
     * @type {ScoreOnlyResponseFraudScore}
     * @memberof ScoreOnlyResponse
     */
    fraudScore?: ScoreOnlyResponseFraudScore;
    /**
     * The action that should be taken for the request that was sent.
     * @type {string}
     * @memberof ScoreOnlyResponse
     */
    recommendedDecision?: string;
}

/**
 * @export
 * @namespace ScoreOnlyResponse
 */
export namespace ScoreOnlyResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStatusEnum {
        ScoredSuccessfully = 'Scored successfully',
        NotProcessed = 'Not Processed'
    }
}

/**
 * Fraud likelihood assessment consisting of a score, associated warning(s), and explanation(s) of score received.
 * @export
 * @interface ScoreOnlyResponseFraudScore
 */
export interface ScoreOnlyResponseFraudScore {
    /**
     * The score attributed to this request by our machine learning system, ranging from 0 (less likely to be fraud) to 1000 (more likely to be fraud).
     * @type {string}
     * @memberof ScoreOnlyResponseFraudScore
     */
    score?: string;
    /**
     * A list of non-critical warnings raised while processing the request. Warnings included in this list will have integration and data-quality related messages.
     * @type {Array<string>}
     * @memberof ScoreOnlyResponseFraudScore
     */
    warnings?: Array<string>;
    /**
     * Explanation of the fraud score applied consisting of a description, type of the explanation, and rule (if applicable).
     * @type {Array<ScoreOnlyResponseFraudScoreExplanations>}
     * @memberof ScoreOnlyResponseFraudScore
     */
    explanations?: Array<ScoreOnlyResponseFraudScoreExplanations>;
}

/**
 * 
 * @export
 * @interface ScoreOnlyResponseFraudScoreExplanations
 */
export interface ScoreOnlyResponseFraudScoreExplanations {
    /**
     * Description of the fraud score explanation.
     * @type {string}
     * @memberof ScoreOnlyResponseFraudScoreExplanations
     */
    description?: string;
    /**
     * ID of the rule being triggered.
     * @type {string}
     * @memberof ScoreOnlyResponseFraudScoreExplanations
     */
    rule?: string;
    /**
     * Type of the explanation (model or rule).
     * @type {string}
     * @memberof ScoreOnlyResponseFraudScoreExplanations
     */
    type?: string;
}

/**
 * Model for secondary financial transactions. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface SecondaryTransaction
 */
export interface SecondaryTransaction {
    /**
     * Object name of the secondary transaction request.
     * @type {string}
     * @memberof SecondaryTransaction
     */
    requestType: string;
    /**
     * An optional outlet ID for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof SecondaryTransaction
     */
    storeId?: string;
    /**
     * Comment for the secondary transaction.
     * @type {string}
     * @memberof SecondaryTransaction
     */
    comments?: string;
    /**
     * 
     * @type {Order}
     * @memberof SecondaryTransaction
     */
    order?: Order;
}

/**
 * Request authentication of the payment card using the 3DS 1.0 URL redirect scheme.
 * @export
 * @interface Secure3D10AuthenticationRequest
 */
export interface Secure3D10AuthenticationRequest extends AuthenticationRequest {
}

/**
 * Submit the result of the authentication managed outside of the gateway for a 3-D Secure 1.0 scheme. For more convenient usage without implementing 3-D Secure yourself see \"authenticationRequest\" section.
 * @export
 * @interface Secure3D10AuthenticationResult
 */
export interface Secure3D10AuthenticationResult extends AuthenticationResult {
    /**
     * Card enrollment result from the Verification Response (VeRes).
     * @type {string}
     * @memberof Secure3D10AuthenticationResult
     */
    verificationResponse?: Secure3D10AuthenticationResult.VerificationResponseEnum;
    /**
     * Result of authentication attempt from Payer Authentication Response (PaRes).
     * @type {string}
     * @memberof Secure3D10AuthenticationResult
     */
    authenticationAttemptResult?: Secure3D10AuthenticationResult.AuthenticationAttemptResultEnum;
    /**
     * The Cardholder Authentication Verification Value (CAVV) is a cryptographic value derived by the issuer during payment authentication that can provide evidence of the results of payment authentication during an online purchase.
     * @type {string}
     * @memberof Secure3D10AuthenticationResult
     */
    cavv?: string;
    /**
     * The transaction identifier (XID) is a unique tracking number set by the merchant.
     * @type {string}
     * @memberof Secure3D10AuthenticationResult
     */
    xid?: string;
}

/**
 * @export
 * @namespace Secure3D10AuthenticationResult
 */
export namespace Secure3D10AuthenticationResult {
    /**
     * @export
     * @enum {string}
     */
    export enum VerificationResponseEnum {
        Y = 'Y',
        N = 'N',
        U = 'U'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AuthenticationAttemptResultEnum {
        Y = 'Y',
        N = 'N',
        U = 'U',
        A = 'A'
    }
}

/**
 * Authentication update request specific to 3DSecure 1.0 transactions.
 * @export
 * @interface Secure3D10AuthenticationUpdateRequest
 */
export interface Secure3D10AuthenticationUpdateRequest extends AuthenticationUpdateRequest {
    /**
     * A formatted message providing results of the issuer’s cardholder authentication.
     * @type {string}
     * @memberof Secure3D10AuthenticationUpdateRequest
     */
    payerAuthenticationResponse: string;
    /**
     * Formatted string encoding transaction time, order ID, and return URL data.
     * @type {string}
     * @memberof Secure3D10AuthenticationUpdateRequest
     */
    merchantData: string;
    /**
     * Card security code if required by merchant.
     * @type {string}
     * @memberof Secure3D10AuthenticationUpdateRequest
     */
    securityCode?: string;
}

/**
 * Request authentication of the payment card using the 3DS 2.1 URL redirect scheme.
 * @export
 * @interface Secure3D21AuthenticationRequest
 */
export interface Secure3D21AuthenticationRequest extends AuthenticationRequest {
    /**
     * The result of the authentication will be sent to this URL. If not provided, a term URL will be dynamically generated.
     * @type {string}
     * @memberof Secure3D21AuthenticationRequest
     */
    termURL?: string;
    /**
     * The 3DS method iframe and transaction ID will be sent here.
     * @type {string}
     * @memberof Secure3D21AuthenticationRequest
     */
    methodNotificationURL?: string;
    /**
     * Indicates whether or not a challenge should be performed. 01 = No preference (You have no preference whether a challenge should be performed. This is the default value) 02 = No challenge requested (You prefer that no challenge should be performed) 03 = Challenge requested: 3DS Requestor Preference (You prefer that a challenge should be performed) 04 = Challenge requested: Mandate (There are local or regional mandates that mean that a challenge must be performed) 
     * @type {string}
     * @memberof Secure3D21AuthenticationRequest
     */
    challengeIndicator?: Secure3D21AuthenticationRequest.ChallengeIndicatorEnum;
    /**
     * Defines the size of the challenge window displayed to customers during authentication. 01 = 250 x 400 02 = 390 x 400 03 = 500 x 600 04 = 600 x 400 05 = Full screen 
     * @type {string}
     * @memberof Secure3D21AuthenticationRequest
     */
    challengeWindowSize?: Secure3D21AuthenticationRequest.ChallengeWindowSizeEnum;
}

/**
 * @export
 * @namespace Secure3D21AuthenticationRequest
 */
export namespace Secure3D21AuthenticationRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ChallengeIndicatorEnum {
        _01 = '01',
        _02 = '02',
        _03 = '03',
        _04 = '04'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ChallengeWindowSizeEnum {
        _01 = '01',
        _02 = '02',
        _03 = '03',
        _04 = '04',
        _05 = '05'
    }
}

/**
 * Submit the result of the authentication managed outside of the gateway for a 3-D Secure 2.1 scheme. For more convenient usage without implementing 3-D Secure yourself see \"authenticationRequest\" section.
 * @export
 * @interface Secure3D21AuthenticationResult
 */
export interface Secure3D21AuthenticationResult extends AuthenticationResult {
    /**
     * The Cardholder Authentication Verification Value (CAVV) is a cryptographic value derived by the issuer during payment authentication that can provide evidence of the results of payment authentication during an online purchase.
     * @type {string}
     * @memberof Secure3D21AuthenticationResult
     */
    cavv?: string;
    /**
     * The transaction identifier (XID) is a unique tracking number set by the merchant.
     * @type {string}
     * @memberof Secure3D21AuthenticationResult
     */
    xid?: string;
    /**
     * The response transaction UUID. Only applicable to MasterCard.
     * @type {string}
     * @memberof Secure3D21AuthenticationResult
     */
    transactionId?: string;
    /**
     * The result of authentication attempt returned by the 3D Secure authentication process (PaRes).
     * @type {string}
     * @memberof Secure3D21AuthenticationResult
     */
    authenticationResponse?: Secure3D21AuthenticationResult.AuthenticationResponseEnum;
    /**
     * The transaction status as returned by the 3D Secure authentication process.
     * @type {string}
     * @memberof Secure3D21AuthenticationResult
     */
    transactionStatus?: Secure3D21AuthenticationResult.TransactionStatusEnum;
}

/**
 * @export
 * @namespace Secure3D21AuthenticationResult
 */
export namespace Secure3D21AuthenticationResult {
    /**
     * @export
     * @enum {string}
     */
    export enum AuthenticationResponseEnum {
        A = 'A',
        N = 'N',
        U = 'U',
        Y = 'Y',
        C = 'C',
        R = 'R'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStatusEnum {
        A = 'A',
        N = 'N',
        U = 'U',
        Y = 'Y',
        C = 'C',
        R = 'R'
    }
}

/**
 * Authentication update request specific to 3DSecure 2.1 transactions.
 * @export
 * @interface Secure3D21AuthenticationUpdateRequest
 */
export interface Secure3D21AuthenticationUpdateRequest extends AuthenticationUpdateRequest {
    /**
     * Indicates how the merchant received the 3DS method.
     * @type {string}
     * @memberof Secure3D21AuthenticationUpdateRequest
     */
    methodNotificationStatus?: Secure3D21AuthenticationUpdateRequest.MethodNotificationStatusEnum;
    /**
     * 
     * @type {ACSResponse}
     * @memberof Secure3D21AuthenticationUpdateRequest
     */
    acsResponse?: ACSResponse;
}

/**
 * @export
 * @namespace Secure3D21AuthenticationUpdateRequest
 */
export namespace Secure3D21AuthenticationUpdateRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodNotificationStatusEnum {
        RECEIVED = 'RECEIVED',
        EXPECTEDBUTNOTRECEIVED = 'EXPECTED_BUT_NOT_RECEIVED',
        NOTEXPECTED = 'NOT_EXPECTED'
    }
}

/**
 * Encapsulates 3DS authentication details in transaction responses.
 * @export
 * @interface Secure3DAuthenticationResponse
 */
export interface Secure3DAuthenticationResponse {
    /**
     * The type of authentication.
     * @type {string}
     * @memberof Secure3DAuthenticationResponse
     */
    type?: Secure3DAuthenticationResponse.TypeEnum;
    /**
     * The version of 3DS used to authenticate.
     * @type {string}
     * @memberof Secure3DAuthenticationResponse
     */
    version?: Secure3DAuthenticationResponse.VersionEnum;
    /**
     * 
     * @type {Secure3DAuthenticationResponseParams}
     * @memberof Secure3DAuthenticationResponse
     */
    params?: Secure3DAuthenticationResponseParams;
    /**
     * 
     * @type {Secure3DAuthenticationResponseSecure3dMethod}
     * @memberof Secure3DAuthenticationResponse
     */
    secure3dMethod?: Secure3DAuthenticationResponseSecure3dMethod;
}

/**
 * @export
 * @namespace Secure3DAuthenticationResponse
 */
export namespace Secure3DAuthenticationResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        _3DSECURE = '3D_SECURE'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum VersionEnum {
        _10 = '1.0',
        _21 = '2.1'
    }
}

/**
 * Additional parameters for authentication redirect.
 * @export
 * @interface Secure3DAuthenticationResponseParams
 */
export interface Secure3DAuthenticationResponseParams {
    /**
     * Message sent from merchant server to authenticate the cardholder.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    payerAuthenticationRequest?: string;
    /**
     * Terminal URL for processing request.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    termURL?: string;
    /**
     * Formatted string encoding transaction time, order ID, and return URL data.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    merchantData?: string;
    /**
     * The URL for the authentication redirect for the merchant.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    acsURL?: string;
    /**
     * The CReq message initiates cardholder interaction in a 3DS 2.1 challenge flow and carries authentication data from the cardholder.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    cReq?: string;
    /**
     * Customer web browser session data.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    sessionData?: string;
}

/**
 * Encapsulates the 3DS method form and unique transaction identifier.
 * @export
 * @interface Secure3DAuthenticationResponseSecure3dMethod
 */
export interface Secure3DAuthenticationResponseSecure3dMethod {
    /**
     * An iframe to be hidden in the browser used to collect browser data for the issuers. This information adds to the overall consumer profile and helps in identifying potentially fraudulent transactions.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseSecure3dMethod
     */
    methodForm?: string;
    /**
     * A unique transaction identifier supplied by the ACS.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseSecure3dMethod
     */
    secure3dTransId?: string;
}

/**
 * Contains 3DSecure response code.
 * @export
 * @interface Secure3dResponse
 */
export interface Secure3dResponse {
    /**
     * Code received after successful payer-auth verification.
     * @type {string}
     * @memberof Secure3dResponse
     */
    responseCode3dSecure?: string;
}

/**
 * Sender information for a disbursement transaction.
 * @export
 * @interface SenderInfo
 */
export interface SenderInfo {
    /**
     * Sender name.
     * @type {string}
     * @memberof SenderInfo
     */
    name: string;
    /**
     * Sender street address.
     * @type {string}
     * @memberof SenderInfo
     */
    streetAddress: string;
    /**
     * Sender city.
     * @type {string}
     * @memberof SenderInfo
     */
    city: string;
    /**
     * Sender state.
     * @type {string}
     * @memberof SenderInfo
     */
    stateCode: string;
    /**
     * Sender country code.
     * @type {string}
     * @memberof SenderInfo
     */
    countryCode: string;
    /**
     * Sender postal code.
     * @type {string}
     * @memberof SenderInfo
     */
    postalCode: string;
    /**
     * Sender phone number.
     * @type {string}
     * @memberof SenderInfo
     */
    phoneNumber: string;
    /**
     * Sender date of birth (YYYYMMDD).
     * @type {string}
     * @memberof SenderInfo
     */
    birthDate?: string;
    /**
     * Sender reference number.
     * @type {string}
     * @memberof SenderInfo
     */
    referenceNumber: string;
    /**
     * Sender account number.
     * @type {string}
     * @memberof SenderInfo
     */
    accountNumber: string;
}

/**
 * The payment object for SEPA Local Payment.
 * @export
 * @interface Sepa
 */
export interface Sepa {
    /**
     * Bank account in IBAN format.
     * @type {string}
     * @memberof Sepa
     */
    iban: string;
    /**
     * The name of the payer.
     * @type {string}
     * @memberof Sepa
     */
    name: string;
    /**
     * Country of residence of the payer using the ISO 3166 standard.
     * @type {string}
     * @memberof Sepa
     */
    country: string;
    /**
     * The email address of the payer.
     * @type {string}
     * @memberof Sepa
     */
    email?: string;
    /**
     * 
     * @type {SepaMandate}
     * @memberof Sepa
     */
    mandate: SepaMandate;
}

/**
 * Model for the SEPA Mandate information.
 * @export
 * @interface SepaMandate
 */
export interface SepaMandate {
    /**
     * Existing mandate reference, managed by merchant. Must match [A-Za-z0-9:?/+(),. -]{1,35} and not start with two slashes (\"//\"). Also known as the mandate ID.
     * @type {string}
     * @memberof SepaMandate
     */
    reference: string;
    /**
     * Valid URL pointing to the SEPA mandate (PDF / HTML format recommended).
     * @type {string}
     * @memberof SepaMandate
     */
    url: string;
    /**
     * Date of mandate signature.
     * @type {string}
     * @memberof SepaMandate
     */
    signatureDate: string;
    /**
     * Sequence type of the direct debit. This defaults to 'SINGLE' if not provided.
     * @type {string}
     * @memberof SepaMandate
     */
    type: SepaMandate.TypeEnum;
}

/**
 * @export
 * @namespace SepaMandate
 */
export namespace SepaMandate {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        SINGLE = 'SINGLE',
        FIRSTCOLLECTION = 'FIRST_COLLECTION',
        RECURRINGCOLLECTION = 'RECURRING_COLLECTION',
        FINALCOLLECTION = 'FINAL_COLLECTION'
    }
}

/**
 * Payment method containing sepa information.
 * @export
 * @interface SepaPaymentMethod
 */
export interface SepaPaymentMethod extends PaymentMethod {
    /**
     * 
     * @type {Sepa}
     * @memberof SepaPaymentMethod
     */
    sepa: Sepa;
}

/**
 * Request to create sale transaction using sepa.
 * @export
 * @interface SepaSaleTransaction
 */
export interface SepaSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {SepaPaymentMethod}
     * @memberof SepaSaleTransaction
     */
    paymentMethod: SepaPaymentMethod;
}

/**
 * Request to create or update success/fail URLs for store.
 * @export
 * @interface SharedSecretConfigurationRequest
 */
export interface SharedSecretConfigurationRequest {
    /**
     * Shared secret/password for Connect.
     * @type {string}
     * @memberof SharedSecretConfigurationRequest
     */
    sharedSecret: string;
}

/**
 * Response from a shared secret configuration request.
 * @export
 * @interface SharedSecretConfigurationResponse
 */
export interface SharedSecretConfigurationResponse extends BasicResponse {
    /**
     * An optional outlet ID for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof SharedSecretConfigurationResponse
     */
    storeId?: string;
    /**
     * Shared secret/password for Connect.
     * @type {string}
     * @memberof SharedSecretConfigurationResponse
     */
    sharedSecret?: string;
    /**
     * The message/status received after updating shared secret service config.
     * @type {string}
     * @memberof SharedSecretConfigurationResponse
     */
    responseMessage?: string;
    /**
     * Response timestamp.
     * @type {number}
     * @memberof SharedSecretConfigurationResponse
     */
    responseTimestamp?: number;
}

/**
 * The address where the items in this order should be shipped to.
 * @export
 * @interface ShipToAddress
 */
export interface ShipToAddress {
    /**
     * Free-form phone number associated with the ship-to address.
     * @type {string}
     * @memberof ShipToAddress
     */
    phone?: string;
    /**
     * First line of street address.
     * @type {string}
     * @memberof ShipToAddress
     */
    address1?: string;
    /**
     * Second line of street address.
     * @type {string}
     * @memberof ShipToAddress
     */
    address2?: string;
    /**
     * City.
     * @type {string}
     * @memberof ShipToAddress
     */
    city?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof ShipToAddress
     */
    state?: string;
    /**
     * Postal Code, free form.
     * @type {string}
     * @memberof ShipToAddress
     */
    zip?: string;
    /**
     * Country.
     * @type {string}
     * @memberof ShipToAddress
     */
    country?: string;
}

/**
 * Shipping information.
 * @export
 * @interface Shipping
 */
export interface Shipping {
    /**
     * Name of customer for shipping.
     * @type {string}
     * @memberof Shipping
     */
    name?: string;
    /**
     * 
     * @type {Contact}
     * @memberof Shipping
     */
    contact?: Contact;
    /**
     * 
     * @type {Address}
     * @memberof Shipping
     */
    address?: Address;
}

/**
 * Identifying information about a merchant which appears on buyer's credit/debit card statements.
 * @export
 * @interface SoftDescriptor
 */
export interface SoftDescriptor {
    /**
     * Store \"doing-business-as\" name.
     * @type {string}
     * @memberof SoftDescriptor
     */
    dynamicMerchantName: string;
    /**
     * The 4-digit merchant category code (MCC). The merchant might be associated with multiple MCCs. In that case the MCC provided here will be the one that better describes the current transaction.
     * @type {string}
     * @memberof SoftDescriptor
     */
    mcc?: string;
}

/**
 * Split-shipment related information, in order to reuse the same authorization.
 * @export
 * @interface SplitShipment
 */
export interface SplitShipment {
    /**
     * Total count of the shipment, can be set at preauth or the first postauth.
     * @type {number}
     * @memberof SplitShipment
     */
    totalCount?: number;
    /**
     * Indicates whether the transaction is the final shipment.
     * @type {boolean}
     * @memberof SplitShipment
     */
    finalShipment?: boolean;
}

/**
 * 
 * @export
 * @interface StoreBrandingStyleConfiguration
 */
export interface StoreBrandingStyleConfiguration {
    /**
     * An optional outlet id for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof StoreBrandingStyleConfiguration
     */
    id: string;
    /**
     * 
     * @type {CombinedMode}
     * @memberof StoreBrandingStyleConfiguration
     */
    combined?: CombinedMode;
    /**
     * 
     * @type {ClassicMode}
     * @memberof StoreBrandingStyleConfiguration
     */
    classic?: ClassicMode;
}

/**
 * Object for fraud settings.
 * @export
 * @interface StoreFraudSettings
 */
export interface StoreFraudSettings {
    /**
     * The outlet identificator.
     * @type {string}
     * @memberof StoreFraudSettings
     */
    id: string;
    /**
     * 
     * @type {FraudSettings}
     * @memberof StoreFraudSettings
     */
    fraudSettings: FraudSettings;
}

/**
 * Object that holds result from update fraud settings request.
 * @export
 * @interface StoreFraudSettingsResult
 */
export interface StoreFraudSettingsResult {
    /**
     * An outlet identificator.
     * @type {string}
     * @memberof StoreFraudSettingsResult
     */
    id?: string;
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof StoreFraudSettingsResult
     */
    blockedCardIdentifier?: TokenIdentifier;
    /**
     * Status from fraud settings.
     * @type {string}
     * @memberof StoreFraudSettingsResult
     */
    status?: string;
}

/**
 * 
 * @export
 * @interface StoreUrlConfiguration
 */
export interface StoreUrlConfiguration {
    /**
     * An optional outlet id for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof StoreUrlConfiguration
     */
    id: string;
    /**
     * Transaction notification URL for Connect.
     * @type {string}
     * @memberof StoreUrlConfiguration
     */
    transactionNotificationUrl?: string;
    /**
     * Recurring transaction notification URL for recurring payments.
     * @type {string}
     * @memberof StoreUrlConfiguration
     */
    recurringTransactionNotificationUrl?: string;
    /**
     * Response success URL for Connect.
     * @type {string}
     * @memberof StoreUrlConfiguration
     */
    responseSuccessUrl?: string;
    /**
     * Response failure URL for Connect.
     * @type {string}
     * @memberof StoreUrlConfiguration
     */
    responseFailureUrl?: string;
    /**
     * Skip connect result page when transaction is approved.
     * @type {boolean}
     * @memberof StoreUrlConfiguration
     */
    skipResultPageForSuccess?: boolean;
    /**
     * Skip connect result page when transaction is not approved.
     * @type {boolean}
     * @memberof StoreUrlConfiguration
     */
    skipResultPageForFailure?: boolean;
    /**
     * Overwrite URLs in database by those from request.
     * @type {boolean}
     * @memberof StoreUrlConfiguration
     */
    overwriteUrlAllowed?: boolean;
}

/**
 * Request to create or update notification and success/failure URLs for store.
 * @export
 * @interface StoreUrlConfigurationRequest
 */
export interface StoreUrlConfigurationRequest {
    /**
     * 
     * @type {Array<StoreUrlConfiguration>}
     * @memberof StoreUrlConfigurationRequest
     */
    stores?: Array<StoreUrlConfiguration>;
}

/**
 * Response from a store url configuration request.
 * @export
 * @interface StoreUrlConfigurationResponse
 */
export interface StoreUrlConfigurationResponse extends BasicResponse {
    /**
     * 
     * @type {Array<StoreUrlConfigurationResult>}
     * @memberof StoreUrlConfigurationResponse
     */
    stores?: Array<StoreUrlConfigurationResult>;
}

/**
 * 
 * @export
 * @interface StoreUrlConfigurationResult
 */
export interface StoreUrlConfigurationResult {
    /**
     * An optional outlet id for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof StoreUrlConfigurationResult
     */
    id?: string;
    /**
     * Status from store url configuration process.
     * @type {string}
     * @memberof StoreUrlConfigurationResult
     */
    status?: string;
}

/**
 * Object for sending stored credentials.
 * @export
 * @interface StoredCredential
 */
export interface StoredCredential {
    /**
     * Indicates if the transaction is first or subsequent. Valid values are 'FIRST' and 'SUBSEQUENT'.
     * @type {string}
     * @memberof StoredCredential
     */
    sequence: StoredCredential.SequenceEnum;
    /**
     * Indicates if the transaction is scheduled or part of an installment.
     * @type {boolean}
     * @memberof StoredCredential
     */
    scheduled: boolean;
    /**
     * The transaction ID received from schemes for the initial transaction. May be required if sequence is 'SUBSEQUENT'.
     * @type {string}
     * @memberof StoredCredential
     */
    referencedSchemeTransactionId?: string;
    /**
     * Indicates whether it is a merchant-initiated or explicitly consented to by card holder. Valid values are 'MERCHANT' and 'CARDHOLDER'.
     * @type {string}
     * @memberof StoredCredential
     */
    initiator?: StoredCredential.InitiatorEnum;
}

/**
 * @export
 * @namespace StoredCredential
 */
export namespace StoredCredential {
    /**
     * @export
     * @enum {string}
     */
    export enum SequenceEnum {
        FIRST = 'FIRST',
        SUBSEQUENT = 'SUBSEQUENT'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum InitiatorEnum {
        MERCHANT = 'MERCHANT',
        CARDHOLDER = 'CARDHOLDER'
    }
}

/**
 * Once sub-merchant element is given, the transaction is considered to be a sub-merchant transaction.
 * @export
 * @interface SubMerchantData
 */
export interface SubMerchantData {
    /**
     * Merchant category code.
     * @type {string}
     * @memberof SubMerchantData
     */
    mcc: string;
    /**
     * Store legal name.
     * @type {string}
     * @memberof SubMerchantData
     */
    legalName?: string;
    /**
     * Timezone.
     * @type {string}
     * @memberof SubMerchantData
     */
    timezone?: string;
    /**
     * 
     * @type {Address}
     * @memberof SubMerchantData
     */
    address?: Address;
    /**
     * 
     * @type {Document}
     * @memberof SubMerchantData
     */
    document?: Document;
    /**
     * Sub-merchant ID.
     * @type {string}
     * @memberof SubMerchantData
     */
    merchantId?: string;
}

/**
 * Sub-merchant split object for SettlementSplit.
 * @export
 * @interface SubMerchantSplit
 */
export interface SubMerchantSplit {
    /**
     * ID of merchant for tracking.
     * @type {string}
     * @memberof SubMerchantSplit
     */
    merchantID: string;
    /**
     * The amount each sub-merchant receives.
     * @type {number}
     * @memberof SubMerchantSplit
     */
    amount: number;
}

/**
 * Object contains text style properties.
 * @export
 * @interface Text
 */
export interface Text {
    /**
     * 
     * @type {Primary}
     * @memberof Text
     */
    primary?: Primary;
    /**
     * 
     * @type {Title}
     * @memberof Text
     */
    title?: Title;
}

/**
 * 
 * @export
 * @interface Title
 */
export interface Title {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Title
     */
    color?: string;
}

/**
 * Token identifier object.
 * @export
 * @interface TokenIdentifier
 */
export interface TokenIdentifier {
    /**
     * Token identifier.
     * @type {string}
     * @memberof TokenIdentifier
     */
    tokenIdentifier?: string;
}

/**
 * 
 * @export
 * @interface TopBar
 */
export interface TopBar {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof TopBar
     */
    color?: string;
}

/**
 * Transaction response with error field included.
 * @export
 * @interface TransactionErrorResponse
 */
export interface TransactionErrorResponse extends TransactionResponse {
    /**
     * 
     * @type {Error}
     * @memberof TransactionErrorResponse
     */
    error?: Error;
}

/**
 * @export
 * @namespace TransactionErrorResponse
 */
export namespace TransactionErrorResponse {
}

/**
 * The source of the transaction. The possible values are ECOM (if the order was received via email or Internet), MAIL, PHONE and RETAIL (face to face).
 * @export
 * @enum {string}
 */
export enum TransactionOrigin {
    ECOM = 'ECOM',
    MAIL = 'MAIL',
    PHONE = 'PHONE',
    RETAIL = 'RETAIL'
}

/**
 * Common object for primary and secondary payment request responses.
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse extends BasicResponse {
    /**
     * The response transaction ID.
     * @type {string}
     * @memberof TransactionResponse
     */
    ipgTransactionId?: string;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof TransactionResponse
     */
    orderId?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof TransactionResponse
     */
    transactionType?: TransactionType;
    /**
     * 
     * @type {PaymentTokenDetails}
     * @memberof TransactionResponse
     */
    paymentToken?: PaymentTokenDetails;
    /**
     * 
     * @type {TransactionOrigin}
     * @memberof TransactionResponse
     */
    transactionOrigin?: TransactionOrigin;
    /**
     * 
     * @type {PaymentMethodDetails}
     * @memberof TransactionResponse
     */
    paymentMethodDetails?: PaymentMethodDetails;
    /**
     * Country of the card issuer.
     * @type {string}
     * @memberof TransactionResponse
     */
    country?: string;
    /**
     * The terminal that is processing the transaction.
     * @type {string}
     * @memberof TransactionResponse
     */
    terminalId?: string;
    /**
     * The unique merchant transaction ID from the request header, if supplied.
     * @type {string}
     * @memberof TransactionResponse
     */
    merchantTransactionId?: string;
    /**
     * The transaction time in seconds since epoch.
     * @type {number}
     * @memberof TransactionResponse
     */
    transactionTime?: number;
    /**
     * 
     * @type {Amount}
     * @memberof TransactionResponse
     */
    approvedAmount?: Amount;
    /**
     * The status of the transaction. APPROVED/WAITING are returned by the endpoints.  VALIDATION_FAILED/DECLINED are errors. See ErrorResponse object for details.
     * @type {string}
     * @memberof TransactionResponse
     */
    transactionStatus?: TransactionResponse.TransactionStatusEnum;
    /**
     * The state of the transaction.
     * @type {string}
     * @memberof TransactionResponse
     */
    transactionState?: TransactionResponse.TransactionStateEnum;
    /**
     * 
     * @type {Secure3dResponse}
     * @memberof TransactionResponse
     */
    secure3dResponse?: Secure3dResponse;
    /**
     * The endpoint redirection URL.
     * @type {string}
     * @memberof TransactionResponse
     */
    redirectURL?: string;
    /**
     * 
     * @type {Secure3DAuthenticationResponse}
     * @memberof TransactionResponse
     */
    authenticationResponse?: Secure3DAuthenticationResponse;
    /**
     * The transaction ID received from schemes for the initial transaction of card on file flows.
     * @type {string}
     * @memberof TransactionResponse
     */
    schemeTransactionId?: string;
    /**
     * 
     * @type {ProcessorData}
     * @memberof TransactionResponse
     */
    processor?: ProcessorData;
    /**
     * 
     * @type {AdditionalTransactionDetails}
     * @memberof TransactionResponse
     */
    additionalDetails?: AdditionalTransactionDetails;
    /**
     * 
     * @type {AccountUpdaterResponse}
     * @memberof TransactionResponse
     */
    accountUpdaterResponse?: AccountUpdaterResponse;
}

/**
 * @export
 * @namespace TransactionResponse
 */
export namespace TransactionResponse {
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStatusEnum {
        APPROVED = 'APPROVED',
        WAITING = 'WAITING',
        VALIDATIONFAILED = 'VALIDATION_FAILED',
        PROCESSINGFAILED = 'PROCESSING_FAILED',
        DECLINED = 'DECLINED'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TransactionStateEnum {
        AUTHORIZED = 'AUTHORIZED',
        CAPTURED = 'CAPTURED',
        DECLINED = 'DECLINED',
        CHECKED = 'CHECKED',
        COMPLETEDGET = 'COMPLETED_GET',
        INITIALIZED = 'INITIALIZED',
        PENDING = 'PENDING',
        READY = 'READY',
        TEMPLATE = 'TEMPLATE',
        SETTLED = 'SETTLED',
        VOIDED = 'VOIDED',
        WAITING = 'WAITING'
    }
}

/**
 * Type of transaction to perform. Primary transaction types in requests include 'SALE', 'PREAUTH', 'CREDIT' and 'FORCED_TICKET'.
 * @export
 * @enum {string}
 */
export enum TransactionType {
    SALE = 'SALE',
    PREAUTH = 'PREAUTH',
    CREDIT = 'CREDIT',
    FORCEDTICKET = 'FORCED_TICKET',
    VOID = 'VOID',
    RETURN = 'RETURN',
    POSTAUTH = 'POSTAUTH',
    PAYERAUTH = 'PAYER_AUTH',
    DISBURSEMENT = 'DISBURSEMENT'
}

/**
 * Request authentication of the payment card using the UnionPay SMS scheme.
 * @export
 * @interface UnionPayAuthenticationRequest
 */
export interface UnionPayAuthenticationRequest extends AuthenticationRequest {
    /**
     * Mobile number for SMS verification.
     * @type {string}
     * @memberof UnionPayAuthenticationRequest
     */
    smsPhoneNumber: string;
}

/**
 * Authentication update request specific to UnionPay transactions.
 * @export
 * @interface UnionPayAuthenticationUpdateRequest
 */
export interface UnionPayAuthenticationUpdateRequest extends AuthenticationUpdateRequest {
    /**
     * Customer mobile number for SMS verification.
     * @type {string}
     * @memberof UnionPayAuthenticationUpdateRequest
     */
    smsVerificationCode: string;
    /**
     * Card security code if required by merchant.
     * @type {string}
     * @memberof UnionPayAuthenticationUpdateRequest
     */
    securityCode?: string;
}

/**
 * Provide an information for fraud settings management.
 * @export
 * @interface UpdateFraudSettingsRequest
 */
export interface UpdateFraudSettingsRequest {
    /**
     * 
     * @type {Array<StoreFraudSettings>}
     * @memberof UpdateFraudSettingsRequest
     */
    stores?: Array<StoreFraudSettings>;
}

/**
 * Response from update fraud settings request.
 * @export
 * @interface UpdateFraudSettingsResponse
 */
export interface UpdateFraudSettingsResponse extends BasicResponse {
    /**
     * 
     * @type {Array<StoreFraudSettingsResult>}
     * @memberof UpdateFraudSettingsResponse
     */
    stores?: Array<StoreFraudSettingsResult>;
}

/**
 * Payment token usage details.
 * @export
 * @interface UsePaymentToken
 */
export interface UsePaymentToken {
    /**
     * Client-supplied payment token value.
     * @type {string}
     * @memberof UsePaymentToken
     */
    value: string;
    /**
     * The ID of a same store (or) sibling store in a hierarchy for which the token was originally created.
     * @type {string}
     * @memberof UsePaymentToken
     */
    tokenOriginStoreId?: string;
    /**
     * 
     * @type {CardFunction}
     * @memberof UsePaymentToken
     */
    _function?: CardFunction;
    /**
     * Card verification value/number.
     * @type {string}
     * @memberof UsePaymentToken
     */
    securityCode?: string;
    /**
     * 
     * @type {Expiration}
     * @memberof UsePaymentToken
     */
    expiryDate?: Expiration;
}

/**
 * The result of the 3DS (3D Secure) check.
 * @export
 * @interface Verification3ds
 */
export interface Verification3ds {
    /**
     * 3DS response code.
     * @type {string}
     * @memberof Verification3ds
     */
    code: string;
    /**
     * Interpretation of the response code.
     * @type {string}
     * @memberof Verification3ds
     */
    status?: string;
    /**
     * Identifier of the scheme.
     * @type {string}
     * @memberof Verification3ds
     */
    scheme: string;
}

/**
 * The result of the AVS (Address Verification System) check.
 * @export
 * @interface VerificationAvs
 */
export interface VerificationAvs {
    /**
     * AVS response code.
     * @type {string}
     * @memberof VerificationAvs
     */
    code: string;
    /**
     * Interpretation of the response code.
     * @type {string}
     * @memberof VerificationAvs
     */
    status?: string;
    /**
     * Identifier of the scheme.
     * @type {string}
     * @memberof VerificationAvs
     */
    scheme: string;
}

/**
 * The result of the CVV (Card Verification Value, or Card Security Code) check.
 * @export
 * @interface VerificationCvv
 */
export interface VerificationCvv {
    /**
     * CVV response code.
     * @type {string}
     * @memberof VerificationCvv
     */
    code: string;
    /**
     * Interpretation of the response code.
     * @type {string}
     * @memberof VerificationCvv
     */
    status?: string;
    /**
     * Identifier of the scheme.
     * @type {string}
     * @memberof VerificationCvv
     */
    scheme: string;
}

/**
 * Request to perform void transaction.
 * @export
 * @interface VoidTransaction
 */
export interface VoidTransaction extends SecondaryTransaction {
}

/**
 * Various wallet payment methods the gateway supports. Abstract class, do not use this class directly, use one of its children: EncryptedApplePayWalletPaymentMethod, EncryptedGooglePayWalletPaymentMethod, EncryptedSamsungPayWalletPaymentMethod, DecryptedApplePayWalletPaymentMethod, DecryptedGooglePayWalletPaymentMethod, DecryptedSamsungPayWalletPaymentMethod.
 * @export
 * @interface WalletPaymentMethod
 */
export interface WalletPaymentMethod {
    /**
     * Type of wallet.
     * @type {string}
     * @memberof WalletPaymentMethod
     */
    walletType: string;
}

/**
 * Request to create preAuth primary transaction using digital wallet.
 * @export
 * @interface WalletPreAuthTransaction
 */
export interface WalletPreAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {WalletPaymentMethod}
     * @memberof WalletPreAuthTransaction
     */
    walletPaymentMethod: WalletPaymentMethod;
    /**
     * 
     * @type {SplitShipment}
     * @memberof WalletPreAuthTransaction
     */
    splitShipment?: SplitShipment;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof WalletPreAuthTransaction
     */
    paymentFacilitator?: PaymentFacilitator;
}

/**
 * Request to create sale primary transaction using digital wallet.
 * @export
 * @interface WalletSaleTransaction
 */
export interface WalletSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {WalletPaymentMethod}
     * @memberof WalletSaleTransaction
     */
    walletPaymentMethod: WalletPaymentMethod;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof WalletSaleTransaction
     */
    paymentFacilitator?: PaymentFacilitator;
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccessTokenRequest} accessTokenRequest Access token request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accessTokenRequest: AccessTokenRequest, messageSignature?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'accessTokenRequest' is not null or undefined
            if (accessTokenRequest === null || accessTokenRequest === undefined) {
                throw new RequiredError('accessTokenRequest','Required parameter accessTokenRequest was null or undefined when calling authenticationAccessTokensPost.');
            }
            const localVarPath = `/authentication/access-tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AccessTokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(accessTokenRequest || {}) : (accessTokenRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccessTokenRequest} accessTokenRequest Access token request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accessTokenRequest: AccessTokenRequest, messageSignature?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse> {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccessTokenRequest} accessTokenRequest Access token request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accessTokenRequest: AccessTokenRequest, messageSignature?: string, options?: any) {
            return AuthenticationApiFp(configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options)(axios, basePath);
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
     * @summary Generate an access token for user authentication.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccessTokenRequest} accessTokenRequest Access token request
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authenticationAccessTokensPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accessTokenRequest: AccessTokenRequest, messageSignature?: string, options?: any): AxiosPromise<AccessTokenResponse>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
     * @summary Generate an access token for user authentication.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccessTokenRequest} accessTokenRequest Access token request
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationAccessTokensPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accessTokenRequest: AccessTokenRequest, messageSignature?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options)(this.axios, this.basePath);
    }

}

/**
 * CardInfoLookupApi - axios parameter creator
 * @export
 */
export const CardInfoLookupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardInfoLookupRequest: CardInfoLookupRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'cardInfoLookupRequest' is not null or undefined
            if (cardInfoLookupRequest === null || cardInfoLookupRequest === undefined) {
                throw new RequiredError('cardInfoLookupRequest','Required parameter cardInfoLookupRequest was null or undefined when calling cardInfoLookup.');
            }
            const localVarPath = `/card-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardInfoLookupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cardInfoLookupRequest || {}) : (cardInfoLookupRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardInfoLookupApi - functional programming interface
 * @export
 */
export const CardInfoLookupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardInfoLookupRequest: CardInfoLookupRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardInfoLookupResponse> {
            const localVarAxiosArgs = CardInfoLookupApiAxiosParamCreator(configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * CardInfoLookupApi - factory interface
 * @export
 */
export const CardInfoLookupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardInfoLookupRequest: CardInfoLookupRequest, messageSignature?: string, region?: string, options?: any) {
            return CardInfoLookupApiFp(configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * CardInfoLookupApi - interface
 * @export
 * @interface CardInfoLookupApi
 */
export interface CardInfoLookupApiInterface {
    /**
     * Use this to look up card related information such as issuer country, card function and card brand.
     * @summary Card information lookup.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardInfoLookupApiInterface
     */
    cardInfoLookup(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardInfoLookupRequest: CardInfoLookupRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<CardInfoLookupResponse>;

}

/**
 * CardInfoLookupApi - object-oriented interface
 * @export
 * @class CardInfoLookupApi
 * @extends {BaseAPI}
 */
export class CardInfoLookupApi extends BaseAPI implements CardInfoLookupApiInterface {
    /**
     * Use this to look up card related information such as issuer country, card function and card brand.
     * @summary Card information lookup.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardInfoLookupApi
     */
    public cardInfoLookup(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardInfoLookupRequest: CardInfoLookupRequest, messageSignature?: string, region?: string, options?: any) {
        return CardInfoLookupApiFp(this.configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

}

/**
 * CardVerificationApi - axios parameter creator
 * @export
 */
export const CardVerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to perform card verification for a payment card.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardVerificationRequest: CardVerificationRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'cardVerificationRequest' is not null or undefined
            if (cardVerificationRequest === null || cardVerificationRequest === undefined) {
                throw new RequiredError('cardVerificationRequest','Required parameter cardVerificationRequest was null or undefined when calling verifyCard.');
            }
            const localVarPath = `/card-verification`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CardVerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cardVerificationRequest || {}) : (cardVerificationRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardVerificationApi - functional programming interface
 * @export
 */
export const CardVerificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to perform card verification for a payment card.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardVerificationRequest: CardVerificationRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = CardVerificationApiAxiosParamCreator(configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * CardVerificationApi - factory interface
 * @export
 */
export const CardVerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to perform card verification for a payment card.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardVerificationRequest: CardVerificationRequest, messageSignature?: string, region?: string, options?: any) {
            return CardVerificationApiFp(configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * CardVerificationApi - interface
 * @export
 * @interface CardVerificationApi
 */
export interface CardVerificationApiInterface {
    /**
     * Use this to perform card verification for a payment card.
     * @summary Verify a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardVerificationApiInterface
     */
    verifyCard(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardVerificationRequest: CardVerificationRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<TransactionResponse>;

}

/**
 * CardVerificationApi - object-oriented interface
 * @export
 * @class CardVerificationApi
 * @extends {BaseAPI}
 */
export class CardVerificationApi extends BaseAPI implements CardVerificationApiInterface {
    /**
     * Use this to perform card verification for a payment card.
     * @summary Verify a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CardVerificationApi
     */
    public verifyCard(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardVerificationRequest: CardVerificationRequest, messageSignature?: string, region?: string, options?: any) {
        return CardVerificationApiFp(this.configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

}

/**
 * CurrencyConversionApi - axios parameter creator
 * @export
 */
export const CurrencyConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, exchangeRateRequest: ExchangeRateRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'exchangeRateRequest' is not null or undefined
            if (exchangeRateRequest === null || exchangeRateRequest === undefined) {
                throw new RequiredError('exchangeRateRequest','Required parameter exchangeRateRequest was null or undefined when calling getExchangeRate.');
            }
            const localVarPath = `/exchange-rates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExchangeRateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(exchangeRateRequest || {}) : (exchangeRateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyConversionApi - functional programming interface
 * @export
 */
export const CurrencyConversionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, exchangeRateRequest: ExchangeRateRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeRateResponse> {
            const localVarAxiosArgs = CurrencyConversionApiAxiosParamCreator(configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * CurrencyConversionApi - factory interface
 * @export
 */
export const CurrencyConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, exchangeRateRequest: ExchangeRateRequest, messageSignature?: string, region?: string, options?: any) {
            return CurrencyConversionApiFp(configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * CurrencyConversionApi - interface
 * @export
 * @interface CurrencyConversionApi
 */
export interface CurrencyConversionApiInterface {
    /**
     * Sale, return and lookup exchange rate with dynamic currency conversion option.
     * @summary Generate dynamic currency conversion transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyConversionApiInterface
     */
    getExchangeRate(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, exchangeRateRequest: ExchangeRateRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<ExchangeRateResponse>;

}

/**
 * CurrencyConversionApi - object-oriented interface
 * @export
 * @class CurrencyConversionApi
 * @extends {BaseAPI}
 */
export class CurrencyConversionApi extends BaseAPI implements CurrencyConversionApiInterface {
    /**
     * Sale, return and lookup exchange rate with dynamic currency conversion option.
     * @summary Generate dynamic currency conversion transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyConversionApi
     */
    public getExchangeRate(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, exchangeRateRequest: ExchangeRateRequest, messageSignature?: string, region?: string, options?: any) {
        return CurrencyConversionApiFp(this.configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

}

/**
 * FraudDetectApi - axios parameter creator
 * @export
 */
export const FraudDetectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, clientRegistration: ClientRegistration, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'clientRegistration' is not null or undefined
            if (clientRegistration === null || clientRegistration === undefined) {
                throw new RequiredError('clientRegistration','Required parameter clientRegistration was null or undefined when calling fraudClientRegistrationPost.');
            }
            const localVarPath = `/fraud/client-registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClientRegistration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(clientRegistration || {}) : (clientRegistration || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentRegistration: PaymentRegistration, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'paymentRegistration' is not null or undefined
            if (paymentRegistration === null || paymentRegistration === undefined) {
                throw new RequiredError('paymentRegistration','Required parameter paymentRegistration was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            const localVarPath = `/fraud/payment-registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentRegistration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentRegistration || {}) : (paymentRegistration || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, scoreOnlyRequest: ScoreOnlyRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'scoreOnlyRequest' is not null or undefined
            if (scoreOnlyRequest === null || scoreOnlyRequest === undefined) {
                throw new RequiredError('scoreOnlyRequest','Required parameter scoreOnlyRequest was null or undefined when calling scoreOnly.');
            }
            const localVarPath = `/fraud/score-only`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ScoreOnlyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(scoreOnlyRequest || {}) : (scoreOnlyRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FraudDetectApi - functional programming interface
 * @export
 */
export const FraudDetectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, clientRegistration: ClientRegistration, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FraudRegistrationResponse> {
            const localVarAxiosArgs = FraudDetectApiAxiosParamCreator(configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentRegistration: PaymentRegistration, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FraudRegistrationResponse> {
            const localVarAxiosArgs = FraudDetectApiAxiosParamCreator(configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, scoreOnlyRequest: ScoreOnlyRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreOnlyResponse> {
            const localVarAxiosArgs = FraudDetectApiAxiosParamCreator(configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * FraudDetectApi - factory interface
 * @export
 */
export const FraudDetectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, clientRegistration: ClientRegistration, messageSignature?: string, region?: string, options?: any) {
            return FraudDetectApiFp(configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentRegistration: PaymentRegistration, messageSignature?: string, region?: string, options?: any) {
            return FraudDetectApiFp(configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, scoreOnlyRequest: ScoreOnlyRequest, messageSignature?: string, region?: string, options?: any) {
            return FraudDetectApiFp(configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * FraudDetectApi - interface
 * @export
 * @interface FraudDetectApi
 */
export interface FraudDetectApiInterface {
    /**
     * Use this to register client for fraud detect transaction.
     * @summary Client registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ClientRegistration} clientRegistration 
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApiInterface
     */
    fraudClientRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, clientRegistration: ClientRegistration, messageSignature?: string, region?: string, options?: any): AxiosPromise<FraudRegistrationResponse>;

    /**
     * Use this to register payment for fraud detect transaction.
     * @summary Payment registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentRegistration} paymentRegistration 
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApiInterface
     */
    fraudPaymentRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentRegistration: PaymentRegistration, messageSignature?: string, region?: string, options?: any): AxiosPromise<FraudRegistrationResponse>;

    /**
     * Use this to obtain a fraud score for a transaction.
     * @summary Score a transaction for fraud.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApiInterface
     */
    scoreOnly(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, scoreOnlyRequest: ScoreOnlyRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<ScoreOnlyResponse>;

}

/**
 * FraudDetectApi - object-oriented interface
 * @export
 * @class FraudDetectApi
 * @extends {BaseAPI}
 */
export class FraudDetectApi extends BaseAPI implements FraudDetectApiInterface {
    /**
     * Use this to register client for fraud detect transaction.
     * @summary Client registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ClientRegistration} clientRegistration 
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    public fraudClientRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, clientRegistration: ClientRegistration, messageSignature?: string, region?: string, options?: any) {
        return FraudDetectApiFp(this.configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to register payment for fraud detect transaction.
     * @summary Payment registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentRegistration} paymentRegistration 
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    public fraudPaymentRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentRegistration: PaymentRegistration, messageSignature?: string, region?: string, options?: any) {
        return FraudDetectApiFp(this.configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to obtain a fraud score for a transaction.
     * @summary Score a transaction for fraud.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    public scoreOnly(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, scoreOnlyRequest: ScoreOnlyRequest, messageSignature?: string, region?: string, options?: any) {
        return FraudDetectApiFp(this.configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

}

/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling orderInquiry.');
            }
            const localVarPath = `/orders/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new RequiredError('secondaryTransaction','Required parameter secondaryTransaction was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            const localVarPath = `/orders/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(secondaryTransaction || {}) : (secondaryTransaction || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
            return OrderApiFp(configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, options?: any) {
            return OrderApiFp(configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * OrderApi - interface
 * @export
 * @interface OrderApi
 */
export interface OrderApiInterface {
    /**
     * Use this query to get the current state of an existing order.
     * @summary Retrieve the state of an order.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    orderInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): AxiosPromise<OrderResponse>;

    /**
     * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
     * @summary Perform return or postAuth secondary transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    submitSecondaryTransactionFromOrder(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, options?: any): AxiosPromise<TransactionResponse>;

}

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI implements OrderApiInterface {
    /**
     * Use this query to get the current state of an existing order.
     * @summary Retrieve the state of an order.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
        return OrderApiFp(this.configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
     * @summary Perform return or postAuth secondary transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public submitSecondaryTransactionFromOrder(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, options?: any) {
        return OrderApiFp(this.configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options)(this.axios, this.basePath);
    }

}

/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, authenticationUpdateRequest: AuthenticationUpdateRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'authenticationUpdateRequest' is not null or undefined
            if (authenticationUpdateRequest === null || authenticationUpdateRequest === undefined) {
                throw new RequiredError('authenticationUpdateRequest','Required parameter authenticationUpdateRequest was null or undefined when calling finalizeSecureTransaction.');
            }
            const localVarPath = `/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AuthenticationUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authenticationUpdateRequest || {}) : (authenticationUpdateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, primaryTransaction: PrimaryTransaction, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'primaryTransaction' is not null or undefined
            if (primaryTransaction === null || primaryTransaction === undefined) {
                throw new RequiredError('primaryTransaction','Required parameter primaryTransaction was null or undefined when calling submitPrimaryTransaction.');
            }
            const localVarPath = `/payments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PrimaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(primaryTransaction || {}) : (primaryTransaction || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new RequiredError('secondaryTransaction','Required parameter secondaryTransaction was null or undefined when calling submitSecondaryTransaction.');
            }
            const localVarPath = `/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(secondaryTransaction || {}) : (secondaryTransaction || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, messageSignature?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling transactionInquiry.');
            }
            const localVarPath = `/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, authenticationUpdateRequest: AuthenticationUpdateRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = PaymentApiAxiosParamCreator(configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, primaryTransaction: PrimaryTransaction, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = PaymentApiAxiosParamCreator(configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = PaymentApiAxiosParamCreator(configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = PaymentApiAxiosParamCreator(configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, authenticationUpdateRequest: AuthenticationUpdateRequest, messageSignature?: string, region?: string, options?: any) {
            return PaymentApiFp(configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, primaryTransaction: PrimaryTransaction, messageSignature?: string, region?: string, options?: any) {
            return PaymentApiFp(configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, storeId?: string, options?: any) {
            return PaymentApiFp(configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
            return PaymentApiFp(configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(axios, basePath);
        },
    };
};

/**
 * PaymentApi - interface
 * @export
 * @interface PaymentApi
 */
export interface PaymentApiInterface {
    /**
     * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
     * @summary Update a 3DSecure or UnionPay payment and continue processing.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    finalizeSecureTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, authenticationUpdateRequest: AuthenticationUpdateRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<TransactionResponse>;

    /**
     * Use this to originate a financial transaction like a sale, preauthorization, or credit.
     * @summary Generate a primary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    submitPrimaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, primaryTransaction: PrimaryTransaction, messageSignature?: string, region?: string, options?: any): AxiosPromise<TransactionResponse>;

    /**
     * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
     * @summary Perform a secondary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    submitSecondaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, storeId?: string, options?: any): AxiosPromise<TransactionResponse>;

    /**
     * Use this query to get the current state of an existing transaction.
     * @summary Retrieve the state of a transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    transactionInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): AxiosPromise<TransactionResponse>;

}

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI implements PaymentApiInterface {
    /**
     * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
     * @summary Update a 3DSecure or UnionPay payment and continue processing.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public finalizeSecureTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, authenticationUpdateRequest: AuthenticationUpdateRequest, messageSignature?: string, region?: string, options?: any) {
        return PaymentApiFp(this.configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to originate a financial transaction like a sale, preauthorization, or credit.
     * @summary Generate a primary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public submitPrimaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, primaryTransaction: PrimaryTransaction, messageSignature?: string, region?: string, options?: any) {
        return PaymentApiFp(this.configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
     * @summary Perform a secondary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, and ReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public submitSecondaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, storeId?: string, options?: any) {
        return PaymentApiFp(this.configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Use this query to get the current state of an existing transaction.
     * @summary Retrieve the state of a transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public transactionInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
        return PaymentApiFp(this.configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }

}

/**
 * PaymentSchedulesApi - axios parameter creator
 * @export
 */
export const PaymentSchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling cancelPaymentSchedule.');
            }
            const localVarPath = `/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'paymentSchedulesRequest' is not null or undefined
            if (paymentSchedulesRequest === null || paymentSchedulesRequest === undefined) {
                throw new RequiredError('paymentSchedulesRequest','Required parameter paymentSchedulesRequest was null or undefined when calling createPaymentSchedule.');
            }
            const localVarPath = `/payment-schedules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentSchedulesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentSchedulesRequest || {}) : (paymentSchedulesRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling inquiryPaymentSchedule.');
            }
            const localVarPath = `/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'paymentSchedulesRequest' is not null or undefined
            if (paymentSchedulesRequest === null || paymentSchedulesRequest === undefined) {
                throw new RequiredError('paymentSchedulesRequest','Required parameter paymentSchedulesRequest was null or undefined when calling updatePaymentSchedule.');
            }
            const localVarPath = `/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentSchedulesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentSchedulesRequest || {}) : (paymentSchedulesRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentSchedulesApi - functional programming interface
 * @export
 */
export const PaymentSchedulesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSchedulesResponse> {
            const localVarAxiosArgs = PaymentSchedulesApiAxiosParamCreator(configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSchedulesResponse> {
            const localVarAxiosArgs = PaymentSchedulesApiAxiosParamCreator(configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringPaymentDetailsResponse> {
            const localVarAxiosArgs = PaymentSchedulesApiAxiosParamCreator(configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSchedulesResponse> {
            const localVarAxiosArgs = PaymentSchedulesApiAxiosParamCreator(configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * PaymentSchedulesApi - factory interface
 * @export
 */
export const PaymentSchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
            return PaymentSchedulesApiFp(configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any) {
            return PaymentSchedulesApiFp(configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
            return PaymentSchedulesApiFp(configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any) {
            return PaymentSchedulesApiFp(configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * PaymentSchedulesApi - interface
 * @export
 * @interface PaymentSchedulesApi
 */
export interface PaymentSchedulesApiInterface {
    /**
     * Use this to cancel an existing gateway payment schedule.
     * @summary Cancel a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApiInterface
     */
    cancelPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): AxiosPromise<PaymentSchedulesResponse>;

    /**
     * Use this to create a gateway payment schedule.
     * @summary Create gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApiInterface
     */
    createPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<PaymentSchedulesResponse>;

    /**
     * Use this to view an existing gateway payment schedule.
     * @summary View a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApiInterface
     */
    inquiryPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): AxiosPromise<RecurringPaymentDetailsResponse>;

    /**
     * Use this to update a gateway payment schedule.
     * @summary Update a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApiInterface
     */
    updatePaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<PaymentSchedulesResponse>;

}

/**
 * PaymentSchedulesApi - object-oriented interface
 * @export
 * @class PaymentSchedulesApi
 * @extends {BaseAPI}
 */
export class PaymentSchedulesApi extends BaseAPI implements PaymentSchedulesApiInterface {
    /**
     * Use this to cancel an existing gateway payment schedule.
     * @summary Cancel a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    public cancelPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
        return PaymentSchedulesApiFp(this.configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Use this to create a gateway payment schedule.
     * @summary Create gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    public createPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any) {
        return PaymentSchedulesApiFp(this.configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to view an existing gateway payment schedule.
     * @summary View a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    public inquiryPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
        return PaymentSchedulesApiFp(this.configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Use this to update a gateway payment schedule.
     * @summary Update a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    public updatePaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any) {
        return PaymentSchedulesApiFp(this.configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

}

/**
 * PaymentTokenApi - axios parameter creator
 * @export
 */
export const PaymentTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentTokenizationRequest: PaymentTokenizationRequest, messageSignature?: string, authorization?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'paymentTokenizationRequest' is not null or undefined
            if (paymentTokenizationRequest === null || paymentTokenizationRequest === undefined) {
                throw new RequiredError('paymentTokenizationRequest','Required parameter paymentTokenizationRequest was null or undefined when calling createPaymentToken.');
            }
            const localVarPath = `/payment-tokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentTokenizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentTokenizationRequest || {}) : (paymentTokenizationRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling deletePaymentToken.');
            }
            const localVarPath = `/payment-tokens/{token-id}`
                .replace(`{${"token-id"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payment card details associated with token.
         * @summary Get payment card details associated with token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTokenDetails(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling getPaymentTokenDetails.');
            }
            const localVarPath = `/payment-tokens/{token-id}`
                .replace(`{${"token-id"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTokenApi - functional programming interface
 * @export
 */
export const PaymentTokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentTokenizationRequest: PaymentTokenizationRequest, messageSignature?: string, authorization?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTokenizationResponse> {
            const localVarAxiosArgs = PaymentTokenApiAxiosParamCreator(configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTokenizationResponse> {
            const localVarAxiosArgs = PaymentTokenApiAxiosParamCreator(configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Get payment card details associated with token.
         * @summary Get payment card details associated with token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTokenDetails(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTokenizationResponse> {
            const localVarAxiosArgs = PaymentTokenApiAxiosParamCreator(configuration).getPaymentTokenDetails(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * PaymentTokenApi - factory interface
 * @export
 */
export const PaymentTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentTokenizationRequest: PaymentTokenizationRequest, messageSignature?: string, authorization?: string, region?: string, options?: any) {
            return PaymentTokenApiFp(configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options)(axios, basePath);
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any) {
            return PaymentTokenApiFp(configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(axios, basePath);
        },
        /**
         * Get payment card details associated with token.
         * @summary Get payment card details associated with token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTokenDetails(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any) {
            return PaymentTokenApiFp(configuration).getPaymentTokenDetails(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(axios, basePath);
        },
    };
};

/**
 * PaymentTokenApi - interface
 * @export
 * @interface PaymentTokenApi
 */
export interface PaymentTokenApiInterface {
    /**
     * Use this to create a payment token from a payment card.
     * @summary Create a payment token from a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApiInterface
     */
    createPaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentTokenizationRequest: PaymentTokenizationRequest, messageSignature?: string, authorization?: string, region?: string, options?: any): AxiosPromise<PaymentTokenizationResponse>;

    /**
     * Use this to delete a payment token.
     * @summary Delete a payment token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApiInterface
     */
    deletePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any): AxiosPromise<PaymentTokenizationResponse>;

    /**
     * Get payment card details associated with token.
     * @summary Get payment card details associated with token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApiInterface
     */
    getPaymentTokenDetails(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any): AxiosPromise<PaymentTokenizationResponse>;

}

/**
 * PaymentTokenApi - object-oriented interface
 * @export
 * @class PaymentTokenApi
 * @extends {BaseAPI}
 */
export class PaymentTokenApi extends BaseAPI implements PaymentTokenApiInterface {
    /**
     * Use this to create a payment token from a payment card.
     * @summary Create a payment token from a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    public createPaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentTokenizationRequest: PaymentTokenizationRequest, messageSignature?: string, authorization?: string, region?: string, options?: any) {
        return PaymentTokenApiFp(this.configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to delete a payment token.
     * @summary Delete a payment token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    public deletePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any) {
        return PaymentTokenApiFp(this.configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Get payment card details associated with token.
     * @summary Get payment card details associated with token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format &#39;Bearer {access-token}&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    public getPaymentTokenDetails(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any) {
        return PaymentTokenApiFp(this.configuration).getPaymentTokenDetails(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(this.axios, this.basePath);
    }

}

/**
 * PaymentURLApi - axios parameter creator
 * @export
 */
export const PaymentURLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentUrlRequest: PaymentUrlRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'paymentUrlRequest' is not null or undefined
            if (paymentUrlRequest === null || paymentUrlRequest === undefined) {
                throw new RequiredError('paymentUrlRequest','Required parameter paymentUrlRequest was null or undefined when calling createPaymentUrl.');
            }
            const localVarPath = `/payment-url`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PaymentUrlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentUrlRequest || {}) : (paymentUrlRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, messageSignature?: string, region?: string, storeId?: string, transactionId?: string, orderId?: string, paymentUrlId?: string, transactionTime?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling deletePaymentUrl.');
            }
            const localVarPath = `/payment-url`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (paymentUrlId !== undefined) {
                localVarQueryParameter['paymentUrlId'] = paymentUrlId;
            }

            if (transactionTime !== undefined) {
                localVarQueryParameter['transactionTime'] = transactionTime;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, fromDate: string, toDate: string, messageSignature?: string, region?: string, storeId?: string, orderId?: string, merchantTransactionId?: string, status?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'fromDate' is not null or undefined
            if (fromDate === null || fromDate === undefined) {
                throw new RequiredError('fromDate','Required parameter fromDate was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'toDate' is not null or undefined
            if (toDate === null || toDate === undefined) {
                throw new RequiredError('toDate','Required parameter toDate was null or undefined when calling paymentUrlDetail.');
            }
            const localVarPath = `/payment-url`;
            const localVarUrlObj = url.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (merchantTransactionId !== undefined) {
                localVarQueryParameter['merchantTransactionId'] = merchantTransactionId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(timestamp);
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentURLApi - functional programming interface
 * @export
 */
export const PaymentURLApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentUrlRequest: PaymentUrlRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUrlResponse> {
            const localVarAxiosArgs = PaymentURLApiAxiosParamCreator(configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, messageSignature?: string, region?: string, storeId?: string, transactionId?: string, orderId?: string, paymentUrlId?: string, transactionTime?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUrlResponse> {
            const localVarAxiosArgs = PaymentURLApiAxiosParamCreator(configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, fromDate: string, toDate: string, messageSignature?: string, region?: string, storeId?: string, orderId?: string, merchantTransactionId?: string, status?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUrlDetailResponse> {
            const localVarAxiosArgs = PaymentURLApiAxiosParamCreator(configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = Object.assign(localVarAxiosArgs.options, {url: basePath + localVarAxiosArgs.url})
                return axios.request(axiosRequestArgs);                
            };
        },
    }
};

/**
 * PaymentURLApi - factory interface
 * @export
 */
export const PaymentURLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentUrlRequest: PaymentUrlRequest, messageSignature?: string, region?: string, options?: any) {
            return PaymentURLApiFp(configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, messageSignature?: string, region?: string, storeId?: string, transactionId?: string, orderId?: string, paymentUrlId?: string, transactionTime?: string, options?: any) {
            return PaymentURLApiFp(configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options)(axios, basePath);
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, fromDate: string, toDate: string, messageSignature?: string, region?: string, storeId?: string, orderId?: string, merchantTransactionId?: string, status?: string, options?: any) {
            return PaymentURLApiFp(configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options)(axios, basePath);
        },
    };
};

/**
 * PaymentURLApi - interface
 * @export
 * @interface PaymentURLApi
 */
export interface PaymentURLApiInterface {
    /**
     * Use this to generate an embedding payment link.
     * @summary Create a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApiInterface
     */
    createPaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentUrlRequest: PaymentUrlRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<PaymentUrlResponse>;

    /**
     * Use this to delete an embedding payment link.
     * @summary Delete a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [paymentUrlId] The ID code from the payment URL.
     * @param {string} [transactionTime] The transaction time in seconds since epoch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApiInterface
     */
    deletePaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, messageSignature?: string, region?: string, storeId?: string, transactionId?: string, orderId?: string, paymentUrlId?: string, transactionTime?: string, options?: any): AxiosPromise<PaymentUrlResponse>;

    /**
     * Use this query to get the current state of an existing paymentURL.
     * @summary Retrieve the state of payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} fromDate The start date for payment URL in seconds since epoch.
     * @param {string} toDate The end date for payment URL search query in seconds since epoch.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
     * @param {string} [status] The status of payment URL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApiInterface
     */
    paymentUrlDetail(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, fromDate: string, toDate: string, messageSignature?: string, region?: string, storeId?: string, orderId?: string, merchantTransactionId?: string, status?: string, options?: any): AxiosPromise<PaymentUrlDetailResponse>;

}

/**
 * PaymentURLApi - object-oriented interface
 * @export
 * @class PaymentURLApi
 * @extends {BaseAPI}
 */
export class PaymentURLApi extends BaseAPI implements PaymentURLApiInterface {
    /**
     * Use this to generate an embedding payment link.
     * @summary Create a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    public createPaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentUrlRequest: PaymentUrlRequest, messageSignature?: string, region?: string, options?: any) {
        return PaymentURLApiFp(this.configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to delete an embedding payment link.
     * @summary Delete a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [paymentUrlId] The ID code from the payment URL.
     * @param {string} [transactionTime] The transaction time in seconds since epoch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    public deletePaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, messageSignature?: string, region?: string, storeId?: string, transactionId?: string, orderId?: string, paymentUrlId?: string, transactionTime?: string, options?: any) {
        return PaymentURLApiFp(this.configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options)(this.axios, this.basePath);
    }

    /**
     * Use this query to get the current state of an existing paymentURL.
     * @summary Retrieve the state of payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} fromDate The start date for payment URL in seconds since epoch.
     * @param {string} toDate The end date for payment URL search query in seconds since epoch.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
     * @param {string} [status] The status of payment URL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    public paymentUrlDetail(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, fromDate: string, toDate: string, messageSignature?: string, region?: string, storeId?: string, orderId?: string, merchantTransactionId?: string, status?: string, options?: any) {
        return PaymentURLApiFp(this.configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options)(this.axios, this.basePath);
    }

}

