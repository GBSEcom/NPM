// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * Payment Gateway API Specification.
 * The documentation here is designed to provide all of the technical guidance required to consume and integrate with our APIs for payment processing. To learn more about our APIs please visit https://docs.firstdata.com/org/gateway.
 *
 * The version of the OpenAPI document: 6.13.0.20200810.001
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Encapsulates response data from the ACS.
 * @export
 * @interface ACSResponse
 */
export interface ACSResponse {
    /**
     * The ACS response to the CReq message. It can indicate the result of cardholder authentication or, in the case of an app-based model, also signal that further cardholder interaction is required to complete the authentication.
     * @type {string}
     * @memberof ACSResponse
     */
    cRes?: string;
}
/**
 * The processor address validation response for compliance.
 * @export
 * @interface AVSResponse
 */
export interface AVSResponse {
    /**
     * Response if street matches that on file.
     * @type {string}
     * @memberof AVSResponse
     */
    streetMatch?: AVSResponseStreetMatchEnum;
    /**
     * Response if postal code matches that on file.
     * @type {string}
     * @memberof AVSResponse
     */
    postalCodeMatch?: AVSResponsePostalCodeMatchEnum;
    /**
     * The raw address verification response code returned by issuer. Please refer to response codes section in developer portal for more info.
     * @type {string}
     * @memberof AVSResponse
     */
    associationAvsResponse?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AVSResponseStreetMatchEnum {
    Y = 'Y',
    N = 'N',
    NOINPUTDATA = 'NO_INPUT_DATA',
    NOTCHECKED = 'NOT_CHECKED'
}
/**
    * @export
    * @enum {string}
    */
export enum AVSResponsePostalCodeMatchEnum {
    Y = 'Y',
    N = 'N',
    NOINPUTDATA = 'NO_INPUT_DATA',
    NOTCHECKED = 'NOT_CHECKED'
}

/**
 * Access token generation request.
 * @export
 * @interface AccessTokenRequest
 */
export interface AccessTokenRequest {
    /**
     * Domain name.
     * @type {string}
     * @memberof AccessTokenRequest
     */
    domain: string;
    /**
     * The token value.
     * @type {string}
     * @memberof AccessTokenRequest
     */
    token: string;
    /**
     * Indicates whether public key is requested or not.
     * @type {boolean}
     * @memberof AccessTokenRequest
     */
    publicKeyRequired: boolean;
}
/**
 * Access token generation response.
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
    /**
     * Access token for authentication.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    tokenId?: string;
    /**
     * The token status.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    status?: string;
    /**
     * Access token issued time in milliseconds.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    issuedOn?: string;
    /**
     * Access token expiration time.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    expiresInSeconds?: string;
    /**
     * Public key to encrypt data.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    publicKeyBase64?: string;
    /**
     * Encyption algorithym. One way ECDH 256 bit key.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    algorithm?: string;
    /**
     * Echoes back the value from the request header for tracking.
     * @type {string}
     * @memberof AccessTokenResponse
     */
    clientRequestId?: string;
}
/**
 * Request to look up card-related information such as issuer country, card function and card brand associated with a payment card or payment token. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface AccountInfoLookupRequest
 */
export interface AccountInfoLookupRequest {
    /**
     * Object name of the account verification request.
     * @type {string}
     * @memberof AccountInfoLookupRequest
     */
    requestType: string;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof AccountInfoLookupRequest
     */
    storeId?: string;
}
/**
 * Details related to updated account information.
 * @export
 * @interface AccountUpdaterResponse
 */
export interface AccountUpdaterResponse {
    /**
     * Account updater replacement PAN or TransArmor token.
     * @type {string}
     * @memberof AccountUpdaterResponse
     */
    updatedCard?: string;
    /**
     * Updated value of token.
     * @type {string}
     * @memberof AccountUpdaterResponse
     */
    updatedToken?: string;
    /**
     * New account number expiration date in MMYY format.
     * @type {string}
     * @memberof AccountUpdaterResponse
     */
    updatedExpirationDate?: string;
    /**
     * Status of the updated account. An account may have closed (C), the expiry date may have changed (E), the account may have changed (A), or the cardholder should be contacted (Q).
     * @type {string}
     * @memberof AccountUpdaterResponse
     */
    updatedAccountStatus?: string;
    /**
     * Code for the error encountered when updating account.
     * @type {string}
     * @memberof AccountUpdaterResponse
     */
    updatedAccountErrorCode?: string;
}
/**
 * Request to verify payment card or payment token. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface AccountVerificationRequest
 */
export interface AccountVerificationRequest {
    /**
     * Object name of the account verification request.
     * @type {string}
     * @memberof AccountVerificationRequest
     */
    requestType: string;
    /**
     * 
     * @type {Address}
     * @memberof AccountVerificationRequest
     */
    billingAddress?: Address;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof AccountVerificationRequest
     */
    storeId?: string;
    /**
     * The unique merchant transaction ID from the request, if supplied.
     * @type {string}
     * @memberof AccountVerificationRequest
     */
    merchantTransactionId?: string;
    /**
     * 
     * @type {AdditionalDetails}
     * @memberof AccountVerificationRequest
     */
    additionalDetails?: AdditionalDetails;
}
/**
 * Request to create Credit primary transaction using ACH telecheck details.
 * @export
 * @interface AchCreditTransaction
 */
export interface AchCreditTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {TeleCheckAchPaymentMethod}
     * @memberof AchCreditTransaction
     */
    paymentMethod: TeleCheckAchPaymentMethod;
}
/**
 * Request to perform ACH telecheck post auth transaction.
 * @export
 * @interface AchPostAuthTransaction
 */
export interface AchPostAuthTransaction extends SecondaryTransaction {
    /**
     * 
     * @type {Amount}
     * @memberof AchPostAuthTransaction
     */
    transactionAmount: Amount;
}
/**
 * 
 * @export
 * @interface AchPostAuthTransactionAllOf
 */
export interface AchPostAuthTransactionAllOf {
    /**
     * 
     * @type {Amount}
     * @memberof AchPostAuthTransactionAllOf
     */
    transactionAmount: Amount;
}
/**
 * Request to create pre-auth primary transaction using ACH telecheck details.
 * @export
 * @interface AchPreAuthTransaction
 */
export interface AchPreAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {TeleCheckAchPaymentMethod}
     * @memberof AchPreAuthTransaction
     */
    paymentMethod: TeleCheckAchPaymentMethod;
}
/**
 * 
 * @export
 * @interface AchPreAuthTransactionAllOf
 */
export interface AchPreAuthTransactionAllOf {
    /**
     * 
     * @type {TeleCheckAchPaymentMethod}
     * @memberof AchPreAuthTransactionAllOf
     */
    paymentMethod: TeleCheckAchPaymentMethod;
}
/**
 * Identifies if the transaction is single or recurring for ACH transaction which is a optional field for Application Type ICA.
 * @export
 * @enum {string}
 */
export enum AchRecurringType {
    Single = 'Single',
    Recurring = 'Recurring'
}

/**
 * ACH TeleCheck response.
 * @export
 * @interface AchResponse
 */
export interface AchResponse {
    /**
     * Response code for TeleCheck authentication decision in the sale response message.
     * @type {string}
     * @memberof AchResponse
     */
    responseCode?: string;
    /**
     * Code provided if check is approved.
     * @type {string}
     * @memberof AchResponse
     */
    approvalCode?: string;
    /**
     * Reference number.
     * @type {string}
     * @memberof AchResponse
     */
    referenceNumber?: string;
    /**
     * Preferred flag.
     * @type {string}
     * @memberof AchResponse
     */
    preferredFlag?: string;
    /**
     * Indicates the result of the requested authorization and is returned in the sale response.
     * @type {string}
     * @memberof AchResponse
     */
    transactionStatus?: string;
}
/**
 * Request to perform ACH TeleCheck return transaction. Note - If the ACH transaction to be refunded has not yet been sent to Telecheck, the original transaction will be automatically voided instead.
 * @export
 * @interface AchReturnTransaction
 */
export interface AchReturnTransaction extends SecondaryTransaction {
    /**
     * 
     * @type {Amount}
     * @memberof AchReturnTransaction
     */
    transactionAmount: Amount;
}
/**
 * Request to create Sale primary transaction using ACH telecheck details.
 * @export
 * @interface AchSaleTransaction
 */
export interface AchSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {TeleCheckAchPaymentMethod}
     * @memberof AchSaleTransaction
     */
    paymentMethod: TeleCheckAchPaymentMethod;
}
/**
 * Request to perform ACH void transaction.
 * @export
 * @interface AchVoidTransaction
 */
export interface AchVoidTransaction extends SecondaryTransaction {
    /**
     * 
     * @type {Amount}
     * @memberof AchVoidTransaction
     */
    transactionAmount: Amount;
}
/**
 * Rate and corresponding amount being applied to purchase cards, for instance in the form of taxes or discounts.
 * @export
 * @interface AdditionalAmountRate
 */
export interface AdditionalAmountRate {
    /**
     * Amount in 3 decimal 12 bytes total digit.
     * @type {number}
     * @memberof AdditionalAmountRate
     */
    amount: number;
    /**
     * Rate in 3 decimal 12 bytes total digit.
     * @type {number}
     * @memberof AdditionalAmountRate
     */
    rate: number;
}
/**
 * Merchant supplied tracking numbers.
 * @export
 * @interface AdditionalDetails
 */
export interface AdditionalDetails {
    /**
     * Comments for the payment.
     * @type {string}
     * @memberof AdditionalDetails
     */
    comments?: string;
    /**
     * Invoice number.
     * @type {string}
     * @memberof AdditionalDetails
     */
    invoiceNumber?: string;
    /**
     * Purchase order number.
     * @type {string}
     * @memberof AdditionalDetails
     */
    purchaseOrderNumber?: string;
    /**
     * The operator ID.
     * @type {string}
     * @memberof AdditionalDetails
     */
    operatorId?: string;
    /**
     * The sales system ID.
     * @type {string}
     * @memberof AdditionalDetails
     */
    salesSystemId?: string;
    /**
     * Indicates if the particular transaction is a deferred authorization.
     * @type {boolean}
     * @memberof AdditionalDetails
     */
    ipgDeferredAuth?: boolean;
    /**
     * this is highRiskPurchaseIndicator.
     * @type {boolean}
     * @memberof AdditionalDetails
     */
    highRiskPurchaseIndicator?: boolean;
    /**
     * Provides request information that is necessary to generate receipts.
     * @type {Array<ReceiptRequestInfo>}
     * @memberof AdditionalDetails
     */
    receipts?: Array<ReceiptRequestInfo>;
    /**
     * Strong customer authentication exemption type indicator.
     * @type {string}
     * @memberof AdditionalDetails
     */
    scaExemptionType?: AdditionalDetailsScaExemptionTypeEnum;
    /**
     * Eight-character Visa merchant identifier (VMID) assigned by Visa, required for trusted merchant and delegated authentication.
     * @type {string}
     * @memberof AdditionalDetails
     */
    scaVisaMerchantID?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AdditionalDetailsScaExemptionTypeEnum {
    LowValueExemption = 'Low Value Exemption',
    TRAExemption = 'TRA Exemption',
    TrustedMerchantExemption = 'Trusted Merchant Exemption',
    SCPExemption = 'SCP Exemption',
    DelegatedAuthentication = 'Delegated Authentication'
}

/**
 * Additional transaction details for transaction response.
 * @export
 * @interface AdditionalTransactionDetails
 */
export interface AdditionalTransactionDetails {
    /**
     * Comment for the payment.
     * @type {string}
     * @memberof AdditionalTransactionDetails
     */
    comments?: string;
    /**
     * Invoice number.
     * @type {string}
     * @memberof AdditionalTransactionDetails
     */
    invoiceNumber?: string;
    /**
     * Purchase order number.
     * @type {string}
     * @memberof AdditionalTransactionDetails
     */
    purchaseOrderNumber?: string;
    /**
     * The type of debit disbursement transaction.
     * @type {string}
     * @memberof AdditionalTransactionDetails
     */
    disbursementTransType?: AdditionalTransactionDetailsDisbursementTransTypeEnum;
    /**
     * The wallet provider type.
     * @type {string}
     * @memberof AdditionalTransactionDetails
     */
    walletProvider?: AdditionalTransactionDetailsWalletProviderEnum;
    /**
     * Provides receipt response data, if it has been requested.
     * @type {Array<Receipt>}
     * @memberof AdditionalTransactionDetails
     */
    receipts?: Array<Receipt>;
}

/**
    * @export
    * @enum {string}
    */
export enum AdditionalTransactionDetailsDisbursementTransTypeEnum {
    FUNDING = 'FUNDING',
    DISBURSEMENT = 'DISBURSEMENT'
}
/**
    * @export
    * @enum {string}
    */
export enum AdditionalTransactionDetailsWalletProviderEnum {
    GOOGLEPAY = 'GOOGLE_PAY',
    APPLEPAY = 'APPLE_PAY',
    SAMSUNGPAY = 'SAMSUNG_PAY',
    MASTERPASS = 'MASTERPASS'
}

/**
 * Model for address information.
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * Company name associated with the address.
     * @type {string}
     * @memberof Address
     */
    company?: string;
    /**
     * First line of the street address.
     * @type {string}
     * @memberof Address
     */
    address1?: string;
    /**
     * Second line of the street address.
     * @type {string}
     * @memberof Address
     */
    address2?: string;
    /**
     * City or locality.
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof Address
     */
    region?: string;
    /**
     * ZIP code or postal code.
     * @type {string}
     * @memberof Address
     */
    postalCode?: string;
    /**
     * ISO-3166-1  ALPHA-2, ALPHA-3, numeric or full country name. In the case of PaySecure endpoints, pass the country code in an ISO format.
     * @type {string}
     * @memberof Address
     */
    country?: string;
}
/**
 * Additional data specific to the airline industry.
 * @export
 * @interface Airline
 */
export interface Airline {
    /**
     * The passenger name associated with the transaction.
     * @type {string}
     * @memberof Airline
     */
    passengerName?: string;
    /**
     * The airline ticket number associated with the transaction.
     * @type {string}
     * @memberof Airline
     */
    ticketNumber?: string;
    /**
     * The carrier that issued the ticket.
     * @type {string}
     * @memberof Airline
     */
    issuingCarrier?: string;
    /**
     * The carrier associated with the transaction.
     * @type {string}
     * @memberof Airline
     */
    carrierName?: string;
    /**
     * The IATA code associated with the travel agency.
     * @type {string}
     * @memberof Airline
     */
    travelAgencyIataCode?: string;
    /**
     * The business name of the travel agency.
     * @type {string}
     * @memberof Airline
     */
    travelAgencyName?: string;
    /**
     * The airline plan number associated with the transaction.
     * @type {string}
     * @memberof Airline
     */
    airlinePlanNumber?: string;
    /**
     * The invoice number used by the airline.
     * @type {string}
     * @memberof Airline
     */
    airlineInvoiceNumber?: string;
    /**
     * The reservation system used to create the ticket.
     * @type {string}
     * @memberof Airline
     */
    reservationSystem?: AirlineReservationSystemEnum;
    /**
     * If the transaction is associated with a restricted class fare.
     * @type {boolean}
     * @memberof Airline
     */
    restricted?: boolean;
    /**
     * Array containing up to 4 items that describe the route associated with the transaction.
     * @type {Array<AirlineTravelRoute>}
     * @memberof Airline
     */
    travelRoute?: Array<AirlineTravelRoute>;
    /**
     * The number of any other tickets associated with the transaction ticket.
     * @type {string}
     * @memberof Airline
     */
    relatedTicketNumber?: string;
    /**
     * Identify the purchase of ancillary goods or services with a false value. If this element is not provided, the transaction is assumed to be a purchase of an airline ticket.
     * @type {Array<AirlineAncillaryServiceCategory>}
     * @memberof Airline
     */
    ancillaryServiceCategory?: Array<AirlineAncillaryServiceCategory>;
    /**
     * Identifies if the transaction is a ticket purchase.
     * @type {boolean}
     * @memberof Airline
     */
    ticketPurchase?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum AirlineReservationSystemEnum {
    START = 'START',
    TWA = 'TWA',
    DELTA = 'DELTA',
    SABRE = 'SABRE',
    COVIAAPOLLO = 'COVIA_APOLLO',
    DRBLANK = 'DR_BLANK',
    DER = 'DER',
    TUI = 'TUI'
}

/**
 * 
 * @export
 * @interface AirlineAncillaryServiceCategory
 */
export interface AirlineAncillaryServiceCategory {
    /**
     * Identifies the service purchased in the transaction if not a base ticket
     * @type {string}
     * @memberof AirlineAncillaryServiceCategory
     */
    serviceCategory: AirlineAncillaryServiceCategoryServiceCategoryEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum AirlineAncillaryServiceCategoryServiceCategoryEnum {
    BUNDLEDSERVICE = 'BUNDLED_SERVICE',
    BAGGAGEFEE = 'BAGGAGE_FEE',
    CHANGEFEE = 'CHANGE_FEE',
    CARGO = 'CARGO',
    CARBONOFFSET = 'CARBON_OFFSET',
    FREQUENTFLYER = 'FREQUENT_FLYER',
    GIFTCARD = 'GIFT_CARD',
    GROUNDTRANSPORT = 'GROUND_TRANSPORT',
    INFLIGHTENTERTAINMENT = 'IN_FLIGHT_ENTERTAINMENT',
    LOUNGE = 'LOUNGE',
    MEDICAL = 'MEDICAL',
    MEALBEVERAGE = 'MEAL_BEVERAGE',
    OTHER = 'OTHER',
    PASSENGERASSISTFEE = 'PASSENGER_ASSIST_FEE',
    PETS = 'PETS',
    SEATFEES = 'SEAT_FEES',
    STANDBY = 'STANDBY',
    SERVICEFEE = 'SERVICE_FEE',
    STORE = 'STORE',
    TRAVELSERVICE = 'TRAVEL_SERVICE',
    UNACCOMPANIEDTRAVEL = 'UNACCOMPANIED_TRAVEL',
    UPGRADES = 'UPGRADES',
    WIFI = 'WI_FI'
}

/**
 * Additional information about the route.
 * @export
 * @interface AirlineTravelRoute
 */
export interface AirlineTravelRoute {
    /**
     * Date of departure.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    departureDate?: string;
    /**
     * The IATA code for the departure airport.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    origin?: string;
    /**
     * The IATA code for the destination. airport.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    destination?: string;
    /**
     * The IATA code for the carrier.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    carrierCode?: string;
    /**
     * The airline code for the service class of the ticket.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    serviceClass?: string;
    /**
     * Indicates whether the route is direct.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    stopoverType?: AirlineTravelRouteStopoverTypeEnum;
    /**
     * The airline fare basis code.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    fareBasisCode?: string;
    /**
     * Fee charged by a country when a person leaves the country.
     * @type {number}
     * @memberof AirlineTravelRoute
     */
    departureTax?: number;
    /**
     * The airline flight number associated with the ticket.
     * @type {string}
     * @memberof AirlineTravelRoute
     */
    flightNumber?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AirlineTravelRouteStopoverTypeEnum {
    DIRECT = 'DIRECT',
    STOPOVER = 'STOPOVER'
}

/**
 * The payment object for AliPay transactions. Use this to populate AliPay payment method details.
 * @export
 * @interface AliPay
 */
export interface AliPay {
    /**
     * Use this to indicate the type of machine-readable payment data for scanning.
     * @type {string}
     * @memberof AliPay
     */
    paymentDataType: AliPayPaymentDataTypeEnum;
    /**
     * Use this to send payment-related information, such as customer identity ID.
     * @type {string}
     * @memberof AliPay
     */
    paymentData: string;
    /**
     * Use this to send an order title that shows up in the statement.
     * @type {string}
     * @memberof AliPay
     */
    orderTitle: string;
    /**
     * Use this to send order details that show up in the statement.
     * @type {string}
     * @memberof AliPay
     */
    orderDetails: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AliPayPaymentDataTypeEnum {
    BARCODE = 'BARCODE',
    QRCODE = 'QRCODE'
}

/**
 * Payment method containing AliPay information.
 * @export
 * @interface AliPayPaymentMethod
 */
export interface AliPayPaymentMethod {
    /**
     * 
     * @type {AliPay}
     * @memberof AliPayPaymentMethod
     */
    aliPay: AliPay;
}
/**
 * 
 * @export
 * @interface AliPayPaymentMethodAllOf
 */
export interface AliPayPaymentMethodAllOf {
    /**
     * 
     * @type {AliPay}
     * @memberof AliPayPaymentMethodAllOf
     */
    aliPay: AliPay;
}
/**
 * Request to create sale transaction using AliPay.
 * @export
 * @interface AliPaySaleTransaction
 */
export interface AliPaySaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {AliPayPaymentMethod}
     * @memberof AliPaySaleTransaction
     */
    paymentMethod: AliPayPaymentMethod;
}
/**
 * 
 * @export
 * @interface AliPaySaleTransactionAllOf
 */
export interface AliPaySaleTransactionAllOf {
    /**
     * 
     * @type {AliPayPaymentMethod}
     * @memberof AliPaySaleTransactionAllOf
     */
    paymentMethod: AliPayPaymentMethod;
}
/**
 * Amount of the transaction.
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * Sub component values must add up to total amount.
     * @type {number}
     * @memberof Amount
     */
    total: number;
    /**
     * ISO 4217 currency code.
     * @type {string}
     * @memberof Amount
     */
    currency: string;
    /**
     * 
     * @type {AmountComponents}
     * @memberof Amount
     */
    components?: AmountComponents;
}
/**
 * Transaction amounts with multiple components.
 * @export
 * @interface AmountComponents
 */
export interface AmountComponents {
    /**
     * Subtotal amount.
     * @type {number}
     * @memberof AmountComponents
     */
    subtotal?: number;
    /**
     * Value-added tax amount.
     * @type {number}
     * @memberof AmountComponents
     */
    vatAmount?: number;
    /**
     * Local tax amount.
     * @type {number}
     * @memberof AmountComponents
     */
    localTax?: number;
    /**
     * Shipping amount.
     * @type {number}
     * @memberof AmountComponents
     */
    shipping?: number;
    /**
     * Cashback amount.
     * @type {number}
     * @memberof AmountComponents
     */
    cashback?: number;
    /**
     * Tip amount.
     * @type {number}
     * @memberof AmountComponents
     */
    tip?: number;
}
/**
 * Request authentication of the payment card to verify the cardholder and be eligible for liability shift. An AuthenticationRequest should not be submitted with in the same request as an AuthenticationResult. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface AuthenticationRequest
 */
export interface AuthenticationRequest {
    /**
     * Indicates what kind of authentication scheme the merchant wants to use on the card.
     * @type {string}
     * @memberof AuthenticationRequest
     */
    authenticationType: string;
}
/**
 * Submit the result of 3DS authentication managed outside of the gateway. An AuthenticationResult should not be submitted within the same request as an AuthenticationRequest. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface AuthenticationResult
 */
export interface AuthenticationResult {
    /**
     * Specifies the version of 3DS to be used where authentication was managed outside of the gateway.
     * @type {string}
     * @memberof AuthenticationResult
     */
    authenticationType: string;
}
/**
 * Provides shared fields for all AuthenticationUpdateRequest types. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface AuthenticationUpdateRequest
 */
export interface AuthenticationUpdateRequest {
    /**
     * An optional Outlet ID for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof AuthenticationUpdateRequest
     */
    storeId?: string;
    /**
     * Object name of the authentication update request.
     * @type {string}
     * @memberof AuthenticationUpdateRequest
     */
    authenticationType: string;
    /**
     * 
     * @type {Address}
     * @memberof AuthenticationUpdateRequest
     */
    billingAddress?: Address;
}
/**
 * Object contains background style properties.
 * @export
 * @interface Background
 */
export interface Background {
    /**
     * 
     * @type {TopBar}
     * @memberof Background
     */
    topBar?: TopBar;
    /**
     * 
     * @type {Body}
     * @memberof Background
     */
    body?: Body;
    /**
     * 
     * @type {Content}
     * @memberof Background
     */
    content?: Content;
    /**
     * 
     * @type {Borders}
     * @memberof Background
     */
    borders?: Borders;
}
/**
 * Object contains background color properties.
 * @export
 * @interface BackgroundColor
 */
export interface BackgroundColor {
    /**
     * 
     * @type {Header}
     * @memberof BackgroundColor
     */
    header?: Header;
    /**
     * 
     * @type {Content}
     * @memberof BackgroundColor
     */
    content?: Content;
    /**
     * 
     * @type {Footer}
     * @memberof BackgroundColor
     */
    footer?: Footer;
}
/**
 * Bancontact QR information.
 * @export
 * @interface BancontactQR
 */
export interface BancontactQR {
    /**
     * Transaction Routing Means.
     * @type {string}
     * @memberof BancontactQR
     */
    transactionRoutingMeans: BancontactQRTransactionRoutingMeansEnum;
    /**
     * Issuer Customer Reference.
     * @type {string}
     * @memberof BancontactQR
     */
    issuerCustomerReference?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum BancontactQRTransactionRoutingMeansEnum {
    QRCode = 'QR Code',
    URLIntent = 'URL Intent'
}

/**
 * Contains apiTraceId and clientRequestId shared in all response types.
 * @export
 * @interface BasicResponse
 */
export interface BasicResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof BasicResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof BasicResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof BasicResponse
     */
    responseType?: ResponseType;
}
/**
 * Customer billing information.
 * @export
 * @interface Billing
 */
export interface Billing {
    /**
     * Billing name.
     * @type {string}
     * @memberof Billing
     */
    name?: string;
    /**
     * Customer ID for billing purpose.
     * @type {string}
     * @memberof Billing
     */
    customerId?: string;
    /**
     * Customer birth date.
     * @type {string}
     * @memberof Billing
     */
    birthDate?: string;
    /**
     * 
     * @type {Contact}
     * @memberof Billing
     */
    contact?: Contact;
    /**
     * 
     * @type {Address}
     * @memberof Billing
     */
    address?: Address;
}
/**
 * Customer address fields associated with billing.
 * @export
 * @interface BillingAddress
 */
export interface BillingAddress {
    /**
     * First name.
     * @type {string}
     * @memberof BillingAddress
     */
    firstName?: string;
    /**
     * Last name.
     * @type {string}
     * @memberof BillingAddress
     */
    lastName?: string;
    /**
     * Middle name.
     * @type {string}
     * @memberof BillingAddress
     */
    middleName?: string;
    /**
     * First line of street address.
     * @type {string}
     * @memberof BillingAddress
     */
    street: string;
    /**
     * Second line of street address.
     * @type {string}
     * @memberof BillingAddress
     */
    street2?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof BillingAddress
     */
    stateProvince?: string;
    /**
     * City.
     * @type {string}
     * @memberof BillingAddress
     */
    city?: string;
    /**
     * Country.
     * @type {string}
     * @memberof BillingAddress
     */
    country?: string;
    /**
     * 
     * @type {Phone}
     * @memberof BillingAddress
     */
    phone?: Phone;
    /**
     * Postal code.
     * @type {string}
     * @memberof BillingAddress
     */
    zipPostalCode?: string;
}
/**
 * Object that holds information about card that should be blocked.
 * @export
 * @interface BlockCard
 */
export interface BlockCard {
    /**
     * Use this field to send clear PAN or tokens other than TransArmor Token.
     * @type {string}
     * @memberof BlockCard
     */
    cardNumber?: string;
    /**
     * Client order ID.
     * @type {string}
     * @memberof BlockCard
     */
    orderId?: string;
    /**
     * The unique merchant transaction ID.
     * @type {string}
     * @memberof BlockCard
     */
    merchantTransactionId?: string;
}
/**
 * Object that holds information about domain that should be blocked.
 * @export
 * @interface BlockDomain
 */
export interface BlockDomain {
    /**
     * Use this field to send domain name to be blocked.
     * @type {string}
     * @memberof BlockDomain
     */
    domain?: string;
}
/**
 * Object that holds information about IP address that should be blocked.
 * @export
 * @interface BlockIPAddress
 */
export interface BlockIPAddress {
    /**
     * Use this field to send IP address to be blocked.
     * @type {string}
     * @memberof BlockIPAddress
     */
    ipAddress?: string;
    /**
     * Client order ID.
     * @type {string}
     * @memberof BlockIPAddress
     */
    orderId?: string;
}
/**
 * Object that holds information about name that should be blocked.
 * @export
 * @interface BlockName
 */
export interface BlockName {
    /**
     * Use this field to send name to be blocked.
     * @type {string}
     * @memberof BlockName
     */
    name?: string;
    /**
     * Client order ID.
     * @type {string}
     * @memberof BlockName
     */
    orderId?: string;
}
/**
 * Object that holds information about blocked card numbers.
 * @export
 * @interface BlockedCardNumber
 */
export interface BlockedCardNumber {
    /**
     * Use this field to send clear PAN or tokens other than TransArmor Token.
     * @type {string}
     * @memberof BlockedCardNumber
     */
    cardNumber?: string;
    /**
     * Token identifier.
     * @type {string}
     * @memberof BlockedCardNumber
     */
    tokenIdentifier?: string;
}
/**
 * Object that holds information about items that should be blocked.
 * @export
 * @interface BlockedItems
 */
export interface BlockedItems {
    /**
     * 
     * @type {BlockCard}
     * @memberof BlockedItems
     */
    blockCard?: BlockCard;
    /**
     * 
     * @type {BlockDomain}
     * @memberof BlockedItems
     */
    blockDomain?: BlockDomain;
    /**
     * 
     * @type {BlockName}
     * @memberof BlockedItems
     */
    blockName?: BlockName;
    /**
     * 
     * @type {BlockIPAddress}
     * @memberof BlockedItems
     */
    blockIPAddress?: BlockIPAddress;
}
/**
 * 
 * @export
 * @interface Body
 */
export interface Body {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Body
     */
    color?: string;
}
/**
 * 
 * @export
 * @interface Borders
 */
export interface Borders {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Borders
     */
    color?: string;
}
/**
 * Request to update branding style properties for store.
 * @export
 * @interface BrandingStyleConfigurationRequest
 */
export interface BrandingStyleConfigurationRequest {
    /**
     * 
     * @type {Array<StoreBrandingStyleConfiguration>}
     * @memberof BrandingStyleConfigurationRequest
     */
    stores?: Array<StoreBrandingStyleConfiguration>;
}
/**
 * 
 * @export
 * @interface BrandingStyleConfigurationResponse
 */
export interface BrandingStyleConfigurationResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof BrandingStyleConfigurationResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof BrandingStyleConfigurationResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof BrandingStyleConfigurationResponse
     */
    responseType?: ResponseType;
    /**
     * 
     * @type {Array<BrandingStyleConfigurationResult>}
     * @memberof BrandingStyleConfigurationResponse
     */
    stores?: Array<BrandingStyleConfigurationResult>;
}
/**
 * 
 * @export
 * @interface BrandingStyleConfigurationResult
 */
export interface BrandingStyleConfigurationResult {
    /**
     * An optional outlet id for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof BrandingStyleConfigurationResult
     */
    id?: string;
    /**
     * Status from branding style configuration process.
     * @type {string}
     * @memberof BrandingStyleConfigurationResult
     */
    status?: string;
}
/**
 * Object contains button style properties.
 * @export
 * @interface Button
 */
export interface Button {
    /**
     * 
     * @type {Primary}
     * @memberof Button
     */
    primary?: Primary;
    /**
     * 
     * @type {Hover}
     * @memberof Button
     */
    hover?: Hover;
}
/**
 * Additional data specific to the car rental industry.
 * @export
 * @interface CarRental
 */
export interface CarRental {
    /**
     * The car rental agreement number.
     * @type {string}
     * @memberof CarRental
     */
    agreementNumber?: string;
    /**
     * The name of the person renting the car.
     * @type {string}
     * @memberof CarRental
     */
    renterName?: string;
    /**
     * The city where the rental ends and the car is returned.
     * @type {string}
     * @memberof CarRental
     */
    returnCity?: string;
    /**
     * The date the car rental ends and the car is returned.
     * @type {string}
     * @memberof CarRental
     */
    returnDate?: string;
    /**
     * The date the car rental begins.
     * @type {string}
     * @memberof CarRental
     */
    pickupDate?: string;
    /**
     * The classification of the rental car.
     * @type {string}
     * @memberof CarRental
     */
    rentalClassId?: string;
    /**
     * Array containing information about charges other than the rental rate.
     * @type {Array<CarRentalExtraCharges>}
     * @memberof CarRental
     */
    extraCharges?: Array<CarRentalExtraCharges>;
    /**
     * Indicates if the transaction is related to a no-show charge.
     * @type {boolean}
     * @memberof CarRental
     */
    noShowIndicator?: boolean;
}
/**
 * 
 * @export
 * @interface CarRentalExtraCharges
 */
export interface CarRentalExtraCharges {
    /**
     * Additional charge item.
     * @type {string}
     * @memberof CarRentalExtraCharges
     */
    chargeItem?: CarRentalExtraChargesChargeItemEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CarRentalExtraChargesChargeItemEnum {
    EXTRAMILEAGE = 'EXTRA_MILEAGE',
    GAS = 'GAS',
    LATERETURN = 'LATE_RETURN',
    ONEWAYSERVICEFEE = 'ONE_WAY_SERVICE_FEE',
    PARKINGVIOLATION = 'PARKING_VIOLATION'
}

/**
 * Properties for the payment method.
 * @export
 * @interface Card
 */
export interface Card {
    /**
     * TransArmor token value. Either the token fields or card number field must contain a value.
     * @type {string}
     * @memberof Card
     */
    taToken?: string;
    /**
     * TransArmor token key to identify the merchant.
     * @type {string}
     * @memberof Card
     */
    taTokenKey?: string;
    /**
     * The cardholder name as it appears on the card.
     * @type {string}
     * @memberof Card
     */
    cardholderName?: string;
    /**
     * Use this field to send clear PAN or tokens other than TransArmor Token.
     * @type {string}
     * @memberof Card
     */
    cardNumber?: string;
    /**
     * Payment method expiration date. Format is MMYYYY.
     * @type {string}
     * @memberof Card
     */
    expDate?: string;
    /**
     * CVV present indicator.
     * @type {string}
     * @memberof Card
     */
    cvv?: string;
    /**
     * The company (usually a bank) that issued the card.
     * @type {string}
     * @memberof Card
     */
    issuer?: string;
    /**
     * A number that distinguishes between two plastic cards with the same card number in the event of the card being re-issued.
     * @type {string}
     * @memberof Card
     */
    cardReissuedNumber?: string;
}
/**
 * Card function. This field is required when performing transactions for Brazil merchants.
 * @export
 * @enum {string}
 */
export enum CardFunction {
    CREDIT = 'CREDIT',
    DEBIT = 'DEBIT',
    PREPAID = 'PREPAID',
    VOUCHER = 'VOUCHER',
    UNDEFINED = 'UNDEFINED'
}

/**
 * Card information.
 * @export
 * @interface CardInfo
 */
export interface CardInfo {
    /**
     * The card brand.
     * @type {string}
     * @memberof CardInfo
     */
    brand?: string;
    /**
     * The product ID of the brand.
     * @type {string}
     * @memberof CardInfo
     */
    brandProductId?: string;
    /**
     * 
     * @type {CardFunction}
     * @memberof CardInfo
     */
    cardFunction?: CardFunction;
    /**
     * Indicates whether it is a corporate or non-corporate card.
     * @type {string}
     * @memberof CardInfo
     */
    commercialCard?: CardInfoCommercialCardEnum;
    /**
     * The country of the issuer.
     * @type {string}
     * @memberof CardInfo
     */
    issuerCountry?: string;
    /**
     * The name of the issuer.
     * @type {string}
     * @memberof CardInfo
     */
    issuerName?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum CardInfoCommercialCardEnum {
    CORPORATE = 'CORPORATE',
    NONCORPORATE = 'NON_CORPORATE'
}

/**
 * Request to look up card-related information such as issuer country, card function and card brand.
 * @export
 * @interface CardInfoLookupRequest
 */
export interface CardInfoLookupRequest {
    /**
     * An optional outlet id for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof CardInfoLookupRequest
     */
    storeId?: string;
    /**
     * 
     * @type {PaymentCard}
     * @memberof CardInfoLookupRequest
     */
    paymentCard: PaymentCard;
}
/**
 * Response from card info lookup request.
 * @export
 * @interface CardInfoLookupResponse
 */
export interface CardInfoLookupResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof CardInfoLookupResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof CardInfoLookupResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof CardInfoLookupResponse
     */
    responseType?: ResponseType;
    /**
     * One or more card information retrieved based on BIN.
     * @type {Array<CardInfo>}
     * @memberof CardInfoLookupResponse
     */
    cardDetails?: Array<CardInfo>;
    /**
     * Request status.
     * @type {string}
     * @memberof CardInfoLookupResponse
     */
    requestStatus?: CardInfoLookupResponseRequestStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CardInfoLookupResponseRequestStatusEnum {
    SUCCESS = 'SUCCESS',
    LISTEMPTY = 'LIST_EMPTY'
}

/**
 * Request to verify card validity.
 * @export
 * @interface CardVerificationRequest
 */
export interface CardVerificationRequest {
    /**
     * 
     * @type {PaymentCard}
     * @memberof CardVerificationRequest
     */
    paymentCard: PaymentCard;
    /**
     * 
     * @type {Address}
     * @memberof CardVerificationRequest
     */
    billingAddress?: Address;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof CardVerificationRequest
     */
    storeId?: string;
}
/**
 * The payment object for China-domestic transactions. Use this to populate all china domestic payment method details.
 * @export
 * @interface ChinaDomestic
 */
export interface ChinaDomestic {
    /**
     * Use this to indicate the product code according to the product category list.
     * @type {string}
     * @memberof ChinaDomestic
     */
    productCode: string;
    /**
     * The quantity.
     * @type {number}
     * @memberof ChinaDomestic
     */
    productQuantity: number;
    /**
     * Rate amount in 3 decimal 12 bytes total digit.
     * @type {number}
     * @memberof ChinaDomestic
     */
    productPrice: number;
    /**
     * The product description.
     * @type {string}
     * @memberof ChinaDomestic
     */
    productDescription: string;
    /**
     * Use this to indicate the product code according to the product category list.
     * @type {string}
     * @memberof ChinaDomestic
     */
    redirectURL: string;
    /**
     * Use this to limit card functions to debit cards.
     * @type {boolean}
     * @memberof ChinaDomestic
     */
    limitCardFunctionToDebit?: boolean;
    /**
     * Use this to indicate the CUP customer ID if known.
     * @type {string}
     * @memberof ChinaDomestic
     */
    customerId?: string;
    /**
     * Use this to indicate the CUP bank ID if known.
     * @type {string}
     * @memberof ChinaDomestic
     */
    bankId?: string;
    /**
     * Use this as unique identifier of WeChat user which is corresponded to the appid of merchant. The field is only applicable for ChinaDomesticPaymentMethod - brand = WECHAT_DOMESTIC
     * @type {string}
     * @memberof ChinaDomestic
     */
    openId?: string;
}
/**
 * Payment method containing China Domestic information.
 * @export
 * @interface ChinaDomesticPaymentMethod
 */
export interface ChinaDomesticPaymentMethod {
    /**
     * 
     * @type {ChinaDomestic}
     * @memberof ChinaDomesticPaymentMethod
     */
    chinaDomestic: ChinaDomestic;
    /**
     * 
     * @type {string}
     * @memberof ChinaDomesticPaymentMethod
     */
    brand: ChinaDomesticPaymentMethodBrandEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ChinaDomesticPaymentMethodBrandEnum {
    ALIPAYDOMESTIC = 'ALIPAY_DOMESTIC',
    CUPDOMESTIC = 'CUP_DOMESTIC',
    WECHATDOMESTIC = 'WECHAT_DOMESTIC'
}

/**
 * 
 * @export
 * @interface ChinaDomesticPaymentMethodAllOf
 */
export interface ChinaDomesticPaymentMethodAllOf {
    /**
     * 
     * @type {ChinaDomestic}
     * @memberof ChinaDomesticPaymentMethodAllOf
     */
    chinaDomestic: ChinaDomestic;
    /**
     * 
     * @type {string}
     * @memberof ChinaDomesticPaymentMethodAllOf
     */
    brand: ChinaDomesticPaymentMethodAllOfBrandEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ChinaDomesticPaymentMethodAllOfBrandEnum {
    ALIPAYDOMESTIC = 'ALIPAY_DOMESTIC',
    CUPDOMESTIC = 'CUP_DOMESTIC',
    WECHATDOMESTIC = 'WECHAT_DOMESTIC'
}

/**
 * Request to create sale transaction using China PnR.
 * @export
 * @interface ChinaPnRSaleTransaction
 */
export interface ChinaPnRSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {ChinaDomesticPaymentMethod}
     * @memberof ChinaPnRSaleTransaction
     */
    paymentMethod: ChinaDomesticPaymentMethod;
}
/**
 * 
 * @export
 * @interface ChinaPnRSaleTransactionAllOf
 */
export interface ChinaPnRSaleTransactionAllOf {
    /**
     * 
     * @type {ChinaDomesticPaymentMethod}
     * @memberof ChinaPnRSaleTransactionAllOf
     */
    paymentMethod: ChinaDomesticPaymentMethod;
}
/**
 * Object contains classic mode branding style properties.
 * @export
 * @interface ClassicMode
 */
export interface ClassicMode {
    /**
     * 
     * @type {BackgroundColor}
     * @memberof ClassicMode
     */
    backgroundColor?: BackgroundColor;
    /**
     * 
     * @type {Mobile}
     * @memberof ClassicMode
     */
    mobile?: Mobile;
    /**
     * 
     * @type {FontProperties}
     * @memberof ClassicMode
     */
    amountTitle?: FontProperties;
    /**
     * 
     * @type {FontProperties}
     * @memberof ClassicMode
     */
    superscription?: FontProperties;
    /**
     * 
     * @type {FontProperties}
     * @memberof ClassicMode
     */
    individualText?: FontProperties;
    /**
     * 
     * @type {FontProperties}
     * @memberof ClassicMode
     */
    label?: FontProperties;
    /**
     * 
     * @type {FontProperties}
     * @memberof ClassicMode
     */
    normalText?: FontProperties;
    /**
     * 
     * @type {Properties}
     * @memberof ClassicMode
     */
    buttons?: Properties;
    /**
     * 
     * @type {Properties}
     * @memberof ClassicMode
     */
    anchor?: Properties;
    /**
     * 
     * @type {Properties}
     * @memberof ClassicMode
     */
    systemMessages?: Properties;
}
/**
 * Contains clearing related response information.
 * @export
 * @interface ClearingDetails
 */
export interface ClearingDetails {
    /**
     * The array contains information about the clearing elements.
     * @type {Array<ClearingElement>}
     * @memberof ClearingDetails
     */
    clearingElements?: Array<ClearingElement>;
    /**
     * Timestamp when the clearing has been processed. The used format is \"YYYYMMDDhhmmss\".
     * @type {string}
     * @memberof ClearingDetails
     */
    batchTimeStamp?: string;
    /**
     * Start receipt number for the clearing process.
     * @type {number}
     * @memberof ClearingDetails
     */
    receiptNumberFrom?: number;
    /**
     * End receipt number for the clearing process.
     * @type {number}
     * @memberof ClearingDetails
     */
    receiptNumberTo?: number;
    /**
     * Trace number for the clearing process.
     * @type {number}
     * @memberof ClearingDetails
     */
    traceNumber?: number;
}
/**
 * Holds brand specific clearing information.
 * @export
 * @interface ClearingElement
 */
export interface ClearingElement {
    /**
     * Contains the brand of the card.
     * @type {string}
     * @memberof ClearingElement
     */
    brand?: string;
    /**
     * Holds the total clearing value computed for a specific brand.
     * @type {number}
     * @memberof ClearingElement
     */
    value?: number;
    /**
     * Specifies the amount of clearing elements for a given brand.
     * @type {number}
     * @memberof ClearingElement
     */
    count?: number;
}
/**
 * Country and language of client.
 * @export
 * @interface ClientLocale
 */
export interface ClientLocale {
    /**
     * Language used by client.
     * @type {string}
     * @memberof ClientLocale
     */
    language: string;
    /**
     * Country of the client.
     * @type {string}
     * @memberof ClientLocale
     */
    country: string;
}
/**
 * 
 * @export
 * @interface ClientRegistration
 */
export interface ClientRegistration {
    /**
     * Merchant reference code. Used by FirstAPI and reflected in settlement records and webhook notifications. Typically, the merchantRef field is the purchase order number or unique sequence value associated to a given transaction.
     * @type {string}
     * @memberof ClientRegistration
     */
    merchantRef?: string;
    /**
     * Type of transaction merchant wants to process.
     * @type {string}
     * @memberof ClientRegistration
     */
    transactionType: string;
    /**
     * 
     * @type {Customer}
     * @memberof ClientRegistration
     */
    customer: Customer;
    /**
     * 
     * @type {Merchant}
     * @memberof ClientRegistration
     */
    merchant: Merchant;
    /**
     * 
     * @type {FraudRegistrationDevice}
     * @memberof ClientRegistration
     */
    device?: FraudRegistrationDevice;
    /**
     * A JSON object that can carry any additional information that might be helpful for fraud detection.
     * @type {object}
     * @memberof ClientRegistration
     */
    userDefined?: object;
    /**
     * Defines the type of the original transaction that is being evaluated for the Fraud Score.
     * @type {string}
     * @memberof ClientRegistration
     */
    originalTransactionType: string;
}
/**
 * Object contains combined mode branding style properties.
 * @export
 * @interface CombinedMode
 */
export interface CombinedMode {
    /**
     * 
     * @type {Logo}
     * @memberof CombinedMode
     */
    logo?: Logo;
    /**
     * 
     * @type {Background}
     * @memberof CombinedMode
     */
    background?: Background;
    /**
     * 
     * @type {Text}
     * @memberof CombinedMode
     */
    text?: Text;
    /**
     * 
     * @type {Button}
     * @memberof CombinedMode
     */
    button?: Button;
}
/**
 * The type of connect mode.
 * @export
 * @enum {string}
 */
export enum ConnectMode {
    Classic = 'Classic',
    Combined = 'Combined'
}

/**
 * Customer contact information.
 * @export
 * @interface Contact
 */
export interface Contact {
    /**
     * Primary phone number.
     * @type {string}
     * @memberof Contact
     */
    phone?: string;
    /**
     * Mobile phone number.
     * @type {string}
     * @memberof Contact
     */
    mobilePhone?: string;
    /**
     * Fax number.
     * @type {string}
     * @memberof Contact
     */
    fax?: string;
    /**
     * Email address.
     * @type {string}
     * @memberof Contact
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface Content
 */
export interface Content {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Content
     */
    color?: string;
}
/**
 * Object that holds information about country.
 * @export
 * @interface CountryProfile
 */
export interface CountryProfile {
    /**
     * Country profile.
     * @type {number}
     * @memberof CountryProfile
     */
    profile?: number;
}
/**
 * Use this model to create a payment token.
 * @export
 * @interface CreatePaymentToken
 */
export interface CreatePaymentToken {
    /**
     * Client-supplied payment token value. Only applicable for DataVault tokenization scheme.
     * @type {string}
     * @memberof CreatePaymentToken
     */
    value?: string;
    /**
     * If the token is reusable.
     * @type {boolean}
     * @memberof CreatePaymentToken
     */
    reusable?: boolean;
    /**
     * Decline duplicate payment info if client token is supplied.
     * @type {boolean}
     * @memberof CreatePaymentToken
     */
    declineDuplicates?: boolean;
}
/**
 * Currency conversion. Abstract class, do not use this class directly, use one of its children: Dcc, DynamicPricing.
 * @export
 * @interface CurrencyConversion
 */
export interface CurrencyConversion {
    /**
     * Type of currency conversion.
     * @type {string}
     * @memberof CurrencyConversion
     */
    conversionType: string;
    /**
     * Inquiry rate id.
     * @type {string}
     * @memberof CurrencyConversion
     */
    inquiryRateId: string;
}
/**
 * Currency Conversion Response.
 * @export
 * @interface CurrencyConversionResponse
 */
export interface CurrencyConversionResponse {
    /**
     * Dynamic Currency Conversion Applied.
     * @type {boolean}
     * @memberof CurrencyConversionResponse
     */
    dccApplied?: boolean;
    /**
     * 
     * @type {ExchangeRateDetails}
     * @memberof CurrencyConversionResponse
     */
    exchangeRateDetails?: ExchangeRateDetails;
}
/**
 * Customer model for customers registered at merchant\'s website.
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * Unique ID for the customer, if registered. This field is required if the parent object is present.
     * @type {string}
     * @memberof Customer
     */
    id: string;
    /**
     * The timestamp of the customers registration in the merchants platform. Format is YYYY-MM-DD.
     * @type {string}
     * @memberof Customer
     */
    startDate?: string;
    /**
     * Customer\'s first name.
     * @type {string}
     * @memberof Customer
     */
    firstName?: string;
    /**
     * Customer\'s last name.
     * @type {string}
     * @memberof Customer
     */
    lastName?: string;
    /**
     * Customer\'s middle name.
     * @type {string}
     * @memberof Customer
     */
    middleName?: string;
    /**
     * Customer\'s email address.
     * @type {string}
     * @memberof Customer
     */
    email?: string;
    /**
     * The unique ID of the current login session. Must be unique for the customer.
     * @type {string}
     * @memberof Customer
     */
    sessionId?: string;
    /**
     * The username of this customer in the merchants system. This field should contain customer-supplied data if available instead of a generated ID. This field can contain the clients email address if it is also used for authentication purposes.
     * @type {string}
     * @memberof Customer
     */
    username?: string;
    /**
     * The customers gender. Do not set this property if the customer does not specify a gender.
     * @type {string}
     * @memberof Customer
     */
    gender?: CustomerGenderEnum;
    /**
     * The customer\'s year of birth. Format is YYYY.
     * @type {string}
     * @memberof Customer
     */
    dateOfBirth?: string;
    /**
     * 
     * @type {CustomerAddress}
     * @memberof Customer
     */
    address?: CustomerAddress;
    /**
     * A JSON object that can carry any additional information about the customer that might be helpful for fraud detection.
     * @type {object}
     * @memberof Customer
     */
    userDefined?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum CustomerGenderEnum {
    Male = 'male',
    Female = 'female',
    Other = 'other'
}

/**
 * Customer address fields.
 * @export
 * @interface CustomerAddress
 */
export interface CustomerAddress {
    /**
     * First line of street address.
     * @type {string}
     * @memberof CustomerAddress
     */
    street: string;
    /**
     * Second line of street address.
     * @type {string}
     * @memberof CustomerAddress
     */
    street2?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof CustomerAddress
     */
    stateProvince?: string;
    /**
     * City.
     * @type {string}
     * @memberof CustomerAddress
     */
    city?: string;
    /**
     * Country.
     * @type {string}
     * @memberof CustomerAddress
     */
    country: string;
    /**
     * Postal code.
     * @type {string}
     * @memberof CustomerAddress
     */
    zipPostalCode: string;
    /**
     * 
     * @type {Phone}
     * @memberof CustomerAddress
     */
    phone?: Phone;
}
/**
 * Request to perform a DCC exchange rate inquiry.
 * @export
 * @interface DCCExchangeRateRequest
 */
export interface DCCExchangeRateRequest extends ExchangeRateRequest {
    /**
     * The bank identification number (BIN) of the card to be used for DCC. The BIN is the first 6 digits of the card number.
     * @type {string}
     * @memberof DCCExchangeRateRequest
     */
    bin: string;
}
/**
 * 
 * @export
 * @interface DCCExchangeRateRequestAllOf
 */
export interface DCCExchangeRateRequestAllOf {
    /**
     * The bank identification number (BIN) of the card to be used for DCC. The BIN is the first 6 digits of the card number.
     * @type {string}
     * @memberof DCCExchangeRateRequestAllOf
     */
    bin: string;
}
/**
 * Request to perform a dynamic pricing exchange rate inquiry.
 * @export
 * @interface Dcc
 */
export interface Dcc extends CurrencyConversion {
    /**
     * Indicates whether customer agrees with rate to be used.
     * @type {boolean}
     * @memberof Dcc
     */
    dccApplied: boolean;
}
/**
 * 
 * @export
 * @interface DccAllOf
 */
export interface DccAllOf {
    /**
     * Indicates whether customer agrees with rate to be used.
     * @type {boolean}
     * @memberof DccAllOf
     */
    dccApplied: boolean;
}
/**
 * Decrypted Apple Pay payload.
 * @export
 * @interface DecryptedApplePay
 */
export interface DecryptedApplePay {
    /**
     * Payment card number.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    accountNumber: string;
    /**
     * Card expiration date in MMYYYY format.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    expiration: string;
    /**
     * Name of the cardholder.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    cardholderName?: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    brand?: string;
    /**
     * The wallet cryptogram from the decrypted data.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    cryptogram: string;
    /**
     * The ECI indicator from the decrypted data.
     * @type {string}
     * @memberof DecryptedApplePay
     */
    eciIndicator: string;
}
/**
 * Wallet payment method containing decrypted Apple Pay information.
 * @export
 * @interface DecryptedApplePayWalletPaymentMethod
 */
export interface DecryptedApplePayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {DecryptedApplePay}
     * @memberof DecryptedApplePayWalletPaymentMethod
     */
    decryptedApplePay: DecryptedApplePay;
}
/**
 * 
 * @export
 * @interface DecryptedApplePayWalletPaymentMethodAllOf
 */
export interface DecryptedApplePayWalletPaymentMethodAllOf {
    /**
     * 
     * @type {DecryptedApplePay}
     * @memberof DecryptedApplePayWalletPaymentMethodAllOf
     */
    decryptedApplePay: DecryptedApplePay;
}
/**
 * Decrypted Google Pay payload.
 * @export
 * @interface DecryptedGooglePay
 */
export interface DecryptedGooglePay {
    /**
     * Payment card number.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    accountNumber: string;
    /**
     * Card expiration date in MMYYYY format.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    expiration: string;
    /**
     * Name of the cardholder.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    cardholderName?: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    brand?: string;
    /**
     * The wallet cryptogram from the decrypted data.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    cryptogram: string;
    /**
     * The ECI indicator from the decrypted data.
     * @type {string}
     * @memberof DecryptedGooglePay
     */
    eciIndicator: string;
}
/**
 * Wallet payment method containing decrypted Google Pay information.
 * @export
 * @interface DecryptedGooglePayWalletPaymentMethod
 */
export interface DecryptedGooglePayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {DecryptedGooglePay}
     * @memberof DecryptedGooglePayWalletPaymentMethod
     */
    decryptedGooglePay: DecryptedGooglePay;
}
/**
 * 
 * @export
 * @interface DecryptedGooglePayWalletPaymentMethodAllOf
 */
export interface DecryptedGooglePayWalletPaymentMethodAllOf {
    /**
     * 
     * @type {DecryptedGooglePay}
     * @memberof DecryptedGooglePayWalletPaymentMethodAllOf
     */
    decryptedGooglePay: DecryptedGooglePay;
}
/**
 * Decrypted Samsung Pay payload.
 * @export
 * @interface DecryptedSamsungPay
 */
export interface DecryptedSamsungPay {
    /**
     * Payment card number.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    accountNumber: string;
    /**
     * Card expiration date in MMYYYY format.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    expiration: string;
    /**
     * Name of the cardholder.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    cardholderName?: string;
    /**
     * Card brand.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    brand?: string;
    /**
     * The wallet cryptogram from the decrypted data.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    cryptogram: string;
    /**
     * The ECI indicator from the decrypted data.
     * @type {string}
     * @memberof DecryptedSamsungPay
     */
    eciIndicator: string;
}
/**
 * Wallet payment method containing decrypted Samsung Pay information.
 * @export
 * @interface DecryptedSamsungPayWalletPaymentMethod
 */
export interface DecryptedSamsungPayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {DecryptedSamsungPay}
     * @memberof DecryptedSamsungPayWalletPaymentMethod
     */
    decryptedSamsungPay: DecryptedSamsungPay;
}
/**
 * 
 * @export
 * @interface DecryptedSamsungPayWalletPaymentMethodAllOf
 */
export interface DecryptedSamsungPayWalletPaymentMethodAllOf {
    /**
     * 
     * @type {DecryptedSamsungPay}
     * @memberof DecryptedSamsungPayWalletPaymentMethodAllOf
     */
    decryptedSamsungPay: DecryptedSamsungPay;
}
/**
 * 
 * @export
 * @interface DeleteBrandingStyleConfigurationResponse
 */
export interface DeleteBrandingStyleConfigurationResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof DeleteBrandingStyleConfigurationResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof DeleteBrandingStyleConfigurationResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof DeleteBrandingStyleConfigurationResponse
     */
    responseType?: ResponseType;
    /**
     * Store ID number.
     * @type {string}
     * @memberof DeleteBrandingStyleConfigurationResponse
     */
    storeId?: string;
    /**
     * Status from delete branding style configuration process.
     * @type {string}
     * @memberof DeleteBrandingStyleConfigurationResponse
     */
    status?: string;
}
/**
 * The device where this transaction originated.
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * Defines the type of this object.
     * @type {string}
     * @memberof Device
     */
    deviceType: DeviceDeviceTypeEnum;
    /**
     * The unique ID of the device. Must be unique for the entire system (not just within a specific merchant or industry).
     * @type {string}
     * @memberof Device
     */
    deviceId: string;
    /**
     * Information about the networks associated with the device.
     * @type {Array<Items>}
     * @memberof Device
     */
    networks?: Array<Items>;
    /**
     * The GPS decimal latitude, ranging from (-90.0 to 90.0) where positive numbers indicate locations North of the equator.
     * @type {number}
     * @memberof Device
     */
    latitude?: number;
    /**
     * The GPS decimal longitude, ranging from (-180.0 to 180.0) where positive numbers indicate locations East of the IERS Reference Meridian.
     * @type {number}
     * @memberof Device
     */
    longitude?: number;
    /**
     * The device\'s International Mobile Equipment Identity (IMEI) as described in IETF RFC7254.
     * @type {string}
     * @memberof Device
     */
    imei?: string;
    /**
     * The device\'s model name.
     * @type {string}
     * @memberof Device
     */
    model?: string;
    /**
     * The device\'s manufacturer.
     * @type {string}
     * @memberof Device
     */
    manufacturer?: string;
    /**
     * The timezone offset from UTC to the devices timezone configuration, specified in the format +hh:mm.
     * @type {string}
     * @memberof Device
     */
    timezoneOffset?: string;
    /**
     * A flag indicating that the device has been altered to allow privileged access to users. This flag should only be set to false if a test was performed and the result was negative. Leave unset otherwise.
     * @type {boolean}
     * @memberof Device
     */
    rooted?: boolean;
    /**
     * A flag indicating that malware was detected on the mobile phone. This flag should only be set to false if a test was performed and the result was negative. Leave unset otherwise.
     * @type {boolean}
     * @memberof Device
     */
    malwareDetected?: boolean;
    /**
     * A JSON object that can carry any additional information about the device that might be helpful for fraud detection.
     * @type {object}
     * @memberof Device
     */
    userDefined?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum DeviceDeviceTypeEnum {
    Pos = 'device/pos',
    Mobile = 'device/mobile'
}

/**
 * Disbursement information. Abstract class, do not use this class directly, use one of its children: FundingTransactionType, DisbursementTransactionType.
 * @export
 * @interface Disbursement
 */
export interface Disbursement {
    /**
     * The type of disbursement.
     * @type {string}
     * @memberof Disbursement
     */
    disbursementType: string;
    /**
     * 
     * @type {SenderInfo}
     * @memberof Disbursement
     */
    senderInfo: SenderInfo;
    /**
     * 
     * @type {ReceiverInfo}
     * @memberof Disbursement
     */
    receiverInfo: ReceiverInfo;
}
/**
 * Push disbursement information.
 * @export
 * @interface DisbursementTransactionType
 */
export interface DisbursementTransactionType extends Disbursement {
}
/**
 * Document information.
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * Document type.
     * @type {string}
     * @memberof Document
     */
    type: DocumentTypeEnum;
    /**
     * Document number.
     * @type {string}
     * @memberof Document
     */
    number: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DocumentTypeEnum {
    NATIONALIDENTITY = 'NATIONAL_IDENTITY',
    SINGLETAXIDENTIFICATION = 'SINGLE_TAX_IDENTIFICATION',
    SINGLECODEOFLABORIDENTIFICATION = 'SINGLE_CODE_OF_LABOR_IDENTIFICATION',
    BOOKENLISTMENT = 'BOOK_ENLISTMENT',
    CIVICNOTEBOOK = 'CIVIC_NOTEBOOK',
    PASSPORT = 'PASSPORT'
}

/**
 * Request to perform a dynamic pricing exchange rate inquiry.
 * @export
 * @interface DynamicPricing
 */
export interface DynamicPricing extends CurrencyConversion {
    /**
     * The currency code to convert for dynamic pricing in ISO 4217 currency code format.
     * @type {string}
     * @memberof DynamicPricing
     */
    foreignCurrency: string;
    /**
     * Foreign amount.
     * @type {string}
     * @memberof DynamicPricing
     */
    foreignAmount: string;
}
/**
 * 
 * @export
 * @interface DynamicPricingAllOf
 */
export interface DynamicPricingAllOf {
    /**
     * The currency code to convert for dynamic pricing in ISO 4217 currency code format.
     * @type {string}
     * @memberof DynamicPricingAllOf
     */
    foreignCurrency: string;
    /**
     * Foreign amount.
     * @type {string}
     * @memberof DynamicPricingAllOf
     */
    foreignAmount: string;
}
/**
 * Request to perform a dynamic pricing exchange rate inquiry.
 * @export
 * @interface DynamicPricingExchangeRateRequest
 */
export interface DynamicPricingExchangeRateRequest extends ExchangeRateRequest {
    /**
     * The currency code to convert for dynamic pricing in either numeric or alphabetic ISO 4217 currency code format.
     * @type {string}
     * @memberof DynamicPricingExchangeRateRequest
     */
    foreignCurrency: string;
}
/**
 * 
 * @export
 * @interface DynamicPricingExchangeRateRequestAllOf
 */
export interface DynamicPricingExchangeRateRequestAllOf {
    /**
     * The currency code to convert for dynamic pricing in either numeric or alphabetic ISO 4217 currency code format.
     * @type {string}
     * @memberof DynamicPricingExchangeRateRequestAllOf
     */
    foreignCurrency: string;
}
/**
 * Object that holds data to configure email notifications.
 * @export
 * @interface EmailNotificationData
 */
export interface EmailNotificationData {
    /**
     * Use this to enable/disable email notifications.
     * @type {boolean}
     * @memberof EmailNotificationData
     */
    enableNotification?: boolean;
    /**
     * The merchant name to be displayed in the email to customer.
     * @type {string}
     * @memberof EmailNotificationData
     */
    merchantName?: string;
    /**
     * The email address(es) for receiving transaction notifications.
     * @type {string}
     * @memberof EmailNotificationData
     */
    receiverEmail?: string;
    /**
     * The email address for sending transaction notifications to customer.
     * @type {string}
     * @memberof EmailNotificationData
     */
    senderEmail?: string;
    /**
     * The locale for received notifications.
     * @type {string}
     * @memberof EmailNotificationData
     */
    locale?: string;
}
/**
 * Encrypted Apple Pay payload.
 * @export
 * @interface EncryptedApplePay
 */
export interface EncryptedApplePay {
    /**
     * The encrypted wallet payload.
     * @type {string}
     * @memberof EncryptedApplePay
     */
    data: string;
    /**
     * 
     * @type {EncryptedApplePayHeader}
     * @memberof EncryptedApplePay
     */
    header: EncryptedApplePayHeader;
    /**
     * Signature of the payment and header data.
     * @type {string}
     * @memberof EncryptedApplePay
     */
    signature: string;
    /**
     * Version information about the payment token.
     * @type {string}
     * @memberof EncryptedApplePay
     */
    version?: EncryptedApplePayVersionEnum;
    /**
     * Base64-encoded value of PKPaymentRequest. Required only if applicationDataHash is present.
     * @type {string}
     * @memberof EncryptedApplePay
     */
    applicationData?: string;
    /**
     * The merchant ID assigned by the wallet provider.
     * @type {string}
     * @memberof EncryptedApplePay
     */
    merchantId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EncryptedApplePayVersionEnum {
    ECV1 = 'EC_v1'
}

/**
 * Additional version-dependent information used to decrypt and verify the payment.
 * @export
 * @interface EncryptedApplePayHeader
 */
export interface EncryptedApplePayHeader {
    /**
     * Merchant supplied information about the payment request. Contains Base64-encoded SHA256 hash of the applicationData property of the original PKPaymentRequest. Note - applicationData from PaymentData of PKPaymentToken Refer to Apple Pay documentation.
     * @type {string}
     * @memberof EncryptedApplePayHeader
     */
    applicationDataHash?: string;
    /**
     * Temporary key for generating shared secret from a device.
     * @type {string}
     * @memberof EncryptedApplePayHeader
     */
    ephemeralPublicKey: string;
    /**
     * Hash of the X.509 encoded public key bytes of the merchant’s certificate.
     * @type {string}
     * @memberof EncryptedApplePayHeader
     */
    publicKeyHash: string;
    /**
     * Transaction identifier, generated on the device.
     * @type {string}
     * @memberof EncryptedApplePayHeader
     */
    transactionId: string;
}
/**
 * Wallet payment method containing encrypted Apple Pay information.
 * @export
 * @interface EncryptedApplePayWalletPaymentMethod
 */
export interface EncryptedApplePayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {EncryptedApplePay}
     * @memberof EncryptedApplePayWalletPaymentMethod
     */
    encryptedApplePay: EncryptedApplePay;
}
/**
 * 
 * @export
 * @interface EncryptedApplePayWalletPaymentMethodAllOf
 */
export interface EncryptedApplePayWalletPaymentMethodAllOf {
    /**
     * 
     * @type {EncryptedApplePay}
     * @memberof EncryptedApplePayWalletPaymentMethodAllOf
     */
    encryptedApplePay: EncryptedApplePay;
}
/**
 * Encrypted Google Pay payload.
 * @export
 * @interface EncryptedGooglePay
 */
export interface EncryptedGooglePay {
    /**
     * 
     * @type {EncryptedGooglePayData}
     * @memberof EncryptedGooglePay
     */
    data: EncryptedGooglePayData;
    /**
     * Signature for verifying that the message comes from Google. The signature is created using ECDSA.
     * @type {string}
     * @memberof EncryptedGooglePay
     */
    signature: string;
    /**
     * Identifies under which encryption/signing scheme this message has been created. In this way, the protocol can evolve over time if needed. For Google Payments transactions, this should be set to ECv1.
     * @type {string}
     * @memberof EncryptedGooglePay
     */
    version: string;
}
/**
 * The encrypted wallet payload.
 * @export
 * @interface EncryptedGooglePayData
 */
export interface EncryptedGooglePayData {
    /**
     * The encrypted message containing the actual payment information as well as additional security fields.
     * @type {string}
     * @memberof EncryptedGooglePayData
     */
    encryptedMessage: string;
    /**
     * The ephemeral public key associated with the private key to encrypt the message in uncompressed point format.
     * @type {string}
     * @memberof EncryptedGooglePayData
     */
    ephemeralPublicKey: string;
    /**
     * MAC of the encryptedMessage.
     * @type {string}
     * @memberof EncryptedGooglePayData
     */
    tag: string;
}
/**
 * Wallet payment method containing encrypted Google Pay information.
 * @export
 * @interface EncryptedGooglePayWalletPaymentMethod
 */
export interface EncryptedGooglePayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {EncryptedGooglePay}
     * @memberof EncryptedGooglePayWalletPaymentMethod
     */
    encryptedGooglePay: EncryptedGooglePay;
}
/**
 * 
 * @export
 * @interface EncryptedGooglePayWalletPaymentMethodAllOf
 */
export interface EncryptedGooglePayWalletPaymentMethodAllOf {
    /**
     * 
     * @type {EncryptedGooglePay}
     * @memberof EncryptedGooglePayWalletPaymentMethodAllOf
     */
    encryptedGooglePay: EncryptedGooglePay;
}
/**
 * Encrypted Samsung Pay payload.
 * @export
 * @interface EncryptedSamsungPay
 */
export interface EncryptedSamsungPay {
    /**
     * The encrypted wallet payload.
     * @type {string}
     * @memberof EncryptedSamsungPay
     */
    data: string;
    /**
     * Identifies under which encryption/signing scheme this message has been created. In this way, the protocol can evolve over time if needed. For Google Payments transactions, this should be set to ECv1.
     * @type {string}
     * @memberof EncryptedSamsungPay
     */
    version?: string;
}
/**
 * Wallet payment method containing encrypted Samsung Pay information.
 * @export
 * @interface EncryptedSamsungPayWalletPaymentMethod
 */
export interface EncryptedSamsungPayWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * 
     * @type {EncryptedSamsungPay}
     * @memberof EncryptedSamsungPayWalletPaymentMethod
     */
    encryptedSamsungPay: EncryptedSamsungPay;
}
/**
 * 
 * @export
 * @interface EncryptedSamsungPayWalletPaymentMethodAllOf
 */
export interface EncryptedSamsungPayWalletPaymentMethodAllOf {
    /**
     * 
     * @type {EncryptedSamsungPay}
     * @memberof EncryptedSamsungPayWalletPaymentMethodAllOf
     */
    encryptedSamsungPay: EncryptedSamsungPay;
}
/**
 * Provides clearing response information for the specific endpoint.
 * @export
 * @interface EndpointResponse
 */
export interface EndpointResponse {
    /**
     * Specifies the identifier of an endpoint.
     * @type {string}
     * @memberof EndpointResponse
     */
    endpointID?: string;
    /**
     * Defines the clearing status of an endpoint.
     * @type {string}
     * @memberof EndpointResponse
     */
    status?: EndpointResponseStatusEnum;
    /**
     * Defines the batch number of an endpoint clearing process.
     * @type {string}
     * @memberof EndpointResponse
     */
    batchNumber?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EndpointResponseStatusEnum {
    APPROVED = 'APPROVED',
    DECLINED = 'DECLINED',
    FAILED = 'FAILED'
}

/**
 * 
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
    /**
     * The property or attribute associated with the error.
     * @type {string}
     * @memberof ErrorDetails
     */
    field?: string;
    /**
     * Information specific to a property or attribute.
     * @type {string}
     * @memberof ErrorDetails
     */
    message?: string;
}
/**
 * Error message.
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
    /**
     * Error code.
     * @type {string}
     * @memberof ErrorMessage
     */
    code?: string;
    /**
     * Error description.
     * @type {string}
     * @memberof ErrorMessage
     */
    description?: string;
}
/**
 * Response containing an error object.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof ErrorResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof ErrorResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof ErrorResponse
     */
    responseType?: ResponseType;
    /**
     * 
     * @type {Error}
     * @memberof ErrorResponse
     */
    error?: Error;
}
/**
 * Fields related to Currency Conversion Inquiry.
 * @export
 * @interface ExchangeRateDetails
 */
export interface ExchangeRateDetails {
    /**
     * Inquiry rate ID.
     * @type {string}
     * @memberof ExchangeRateDetails
     */
    inquiryRateId?: string;
    /**
     * Foreign currency in alphabetic ISO 4217 currency code format.
     * @type {string}
     * @memberof ExchangeRateDetails
     */
    foreignCurrency?: string;
    /**
     * Foreign amount.
     * @type {string}
     * @memberof ExchangeRateDetails
     */
    foreignAmount?: string;
    /**
     * Exchange rate.
     * @type {string}
     * @memberof ExchangeRateDetails
     */
    exchangeRate?: string;
    /**
     * Dcc offered.
     * @type {boolean}
     * @memberof ExchangeRateDetails
     */
    dccOffered?: boolean;
    /**
     * Exchange rate source timestamp. The used format is \"yyyy-MM-dd\'T\'HH:mm:ss.SSSXXX\"
     * @type {string}
     * @memberof ExchangeRateDetails
     */
    exchangeRateSourceTimestamp?: string;
    /**
     * Expiration timestamp. The used format is \"yyyy-MM-dd\'T\'HH:mm:ss.SSSXXX\"
     * @type {string}
     * @memberof ExchangeRateDetails
     */
    expirationTimestamp?: string;
    /**
     * Margin rate percentage.
     * @type {string}
     * @memberof ExchangeRateDetails
     */
    marginRatePercentage?: string;
    /**
     * Exchange rate source name.
     * @type {string}
     * @memberof ExchangeRateDetails
     */
    exchangeRateSourceName?: string;
}
/**
 * Request to perform an exchange rate inquiry. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface ExchangeRateRequest
 */
export interface ExchangeRateRequest {
    /**
     * Object name of the exchange rate request.
     * @type {string}
     * @memberof ExchangeRateRequest
     */
    requestType: string;
    /**
     * The original amount of the merchant currency for calculation.
     * @type {number}
     * @memberof ExchangeRateRequest
     */
    baseAmount: number;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof ExchangeRateRequest
     */
    storeId?: string;
}
/**
 * Exchange rate response.
 * @export
 * @interface ExchangeRateResponse
 */
export interface ExchangeRateResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof ExchangeRateResponse
     */
    responseType?: ResponseType;
    /**
     * The response transaction ID.
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    ipgTransactionId?: string;
    /**
     * Time of the request. The used format is \"yyyy-MM-dd\'T\'HH:mm:ss.SSSXXX\".
     * @type {string}
     * @memberof ExchangeRateResponse
     */
    requestTime?: string;
    /**
     * 
     * @type {ExchangeRateDetails}
     * @memberof ExchangeRateResponse
     */
    exchangeRateDetails?: ExchangeRateDetails;
}
/**
 * Required for normal transactions except for payment with \'RECURRING\' flags.
 * @export
 * @interface Expiration
 */
export interface Expiration {
    /**
     * Month of the card expiration date in MM format.
     * @type {string}
     * @memberof Expiration
     */
    month: string;
    /**
     * Year of the card expiration date in YY format.
     * @type {string}
     * @memberof Expiration
     */
    year: string;
}
/**
 * Font face property.
 * @export
 * @enum {string}
 */
export enum FontFace {
    Arial = 'arial',
    CourierNew = 'courier new',
    TimesNewRoman = 'times new roman',
    TrebuchetMs = 'trebuchet ms',
    Verdana = 'verdana'
}

/**
 * Object contains font properties.
 * @export
 * @interface FontProperties
 */
export interface FontProperties {
    /**
     * 
     * @type {FontFace}
     * @memberof FontProperties
     */
    fontFace?: FontFace;
    /**
     * Font size property.
     * @type {string}
     * @memberof FontProperties
     */
    fontSize?: string;
    /**
     * 
     * @type {FontWeight}
     * @memberof FontProperties
     */
    fontWeight?: FontWeight;
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof FontProperties
     */
    fontColor?: string;
}
/**
 * Font weight property.
 * @export
 * @enum {string}
 */
export enum FontWeight {
    Normal = 'normal',
    Bold = 'bold'
}

/**
 * 
 * @export
 * @interface Footer
 */
export interface Footer {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Footer
     */
    color?: string;
}
/**
 * Address fields.
 * @export
 * @interface FraudAddress
 */
export interface FraudAddress {
    /**
     * First line of street address.
     * @type {string}
     * @memberof FraudAddress
     */
    street: string;
    /**
     * Second line of street address.
     * @type {string}
     * @memberof FraudAddress
     */
    street2?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof FraudAddress
     */
    stateProvince?: string;
    /**
     * City.
     * @type {string}
     * @memberof FraudAddress
     */
    city?: string;
    /**
     * Country.
     * @type {string}
     * @memberof FraudAddress
     */
    country: string;
    /**
     * Postal code.
     * @type {string}
     * @memberof FraudAddress
     */
    zipPostalCode: string;
}
/**
 * The list of items included in the order.
 * @export
 * @interface FraudOrder
 */
export interface FraudOrder {
    /**
     * 
     * @type {ShipToAddress}
     * @memberof FraudOrder
     */
    shipToAddress?: ShipToAddress;
    /**
     * The list of items included in the order.
     * @type {Array<FraudOrderItems>}
     * @memberof FraudOrder
     */
    items?: Array<FraudOrderItems>;
    /**
     * The URL to the merchant\'s management system, for reporting and analysis.
     * @type {string}
     * @memberof FraudOrder
     */
    detailsUrl?: string;
    /**
     * A JSON object that can carry any additional information about the order that might be helpful for fraud detection.
     * @type {object}
     * @memberof FraudOrder
     */
    userDefined?: object;
}
/**
 * Product details.
 * @export
 * @interface FraudOrderItems
 */
export interface FraudOrderItems {
    /**
     * A unique ID associated with the product. Must be unique within the merchant\'s system.
     * @type {string}
     * @memberof FraudOrderItems
     */
    id?: string;
    /**
     * A name or short description of the product.
     * @type {string}
     * @memberof FraudOrderItems
     */
    name?: string;
    /**
     * The unit in which the product is sold (e.g. litre, kilogram, etc). Leave empty if the product is sold as a complete unit.
     * @type {string}
     * @memberof FraudOrderItems
     */
    quantity?: string;
    /**
     * The number of units sold. Set to 1 if there is only one unit of the item. Leave empty if the quantity is unknown at the time of the request.
     * @type {string}
     * @memberof FraudOrderItems
     */
    unit?: string;
    /**
     * The price per unit.
     * @type {string}
     * @memberof FraudOrderItems
     */
    unitPrice?: string;
    /**
     * The categories that this product belongs to.
     * @type {Array<Array<string>>}
     * @memberof FraudOrderItems
     */
    categories?: Array<Array<string>>;
    /**
     * The URL to the merchant\'s management system, for reporting and analysis.
     * @type {string}
     * @memberof FraudOrderItems
     */
    detailsUrl?: string;
    /**
     * A JSON object that can carry any additional information about the order that might be helpful for fraud detection.
     * @type {object}
     * @memberof FraudOrderItems
     */
    userDefined?: object;
}
/**
 * 
 * @export
 * @interface FraudRegistration
 */
export interface FraudRegistration {
    /**
     * Merchant reference code. Used by FirstAPI and reflected in settlement records and webhook notifications. Typically, the merchantRef field is the purchase order number or unique sequence value associated to a given transaction.
     * @type {string}
     * @memberof FraudRegistration
     */
    merchantRef?: string;
    /**
     * Type of transaction merchant wants to process.
     * @type {string}
     * @memberof FraudRegistration
     */
    transactionType: string;
    /**
     * 
     * @type {Customer}
     * @memberof FraudRegistration
     */
    customer: Customer;
    /**
     * 
     * @type {Merchant}
     * @memberof FraudRegistration
     */
    merchant: Merchant;
    /**
     * 
     * @type {FraudRegistrationDevice}
     * @memberof FraudRegistration
     */
    device?: FraudRegistrationDevice;
    /**
     * A JSON object that can carry any additional information that might be helpful for fraud detection.
     * @type {object}
     * @memberof FraudRegistration
     */
    userDefined?: object;
}
/**
 * A JSON object that holds info about the payment registration card.
 * @export
 * @interface FraudRegistrationCard
 */
export interface FraudRegistrationCard {
    /**
     * The cardholder name as it appears on the card.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    cardholderName?: string;
    /**
     * Use this field to send clear PAN or tokens other than TransArmor Token.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    cardNumber?: string;
    /**
     * Payment method expiration date. Format is MMYYYY.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    expDate?: string;
    /**
     * CVV present indicator.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    cvvPresent?: string;
    /**
     * The company (usually a bank) that issued the card.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    issuer?: string;
    /**
     * A number that distinguishes between two plastic cards with the same card number in the event of the card being re-issued.
     * @type {string}
     * @memberof FraudRegistrationCard
     */
    cardReissuedNumber?: string;
}
/**
 * The device where this transaction originated.
 * @export
 * @interface FraudRegistrationDevice
 */
export interface FraudRegistrationDevice {
    /**
     * Defines the type of this object.
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    deviceType: FraudRegistrationDeviceDeviceTypeEnum;
    /**
     * The unique ID of the device. Must be unique for the entire system (not just within a specific merchant or industry).
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    deviceId: string;
    /**
     * Information about the networks associated with the device.
     * @type {Array<FraudRegistrationDeviceItems>}
     * @memberof FraudRegistrationDevice
     */
    networks?: Array<FraudRegistrationDeviceItems>;
    /**
     * The GPS decimal latitude, ranging from (-90.0 to 90.0) where positive numbers indicate locations North of the equator.
     * @type {number}
     * @memberof FraudRegistrationDevice
     */
    latitude?: number;
    /**
     * The GPS decimal longitude, ranging from (-180.0 to 180.0) where positive numbers indicate locations East of the IERS Reference Meridian.
     * @type {number}
     * @memberof FraudRegistrationDevice
     */
    longitude?: number;
    /**
     * The device\'s International Mobile Equipment Identity (IMEI) as described in IETF RFC7254.
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    imei?: string;
    /**
     * The device\'s model name.
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    model?: string;
    /**
     * The device\'s manufacturer.
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    manufacturer?: string;
    /**
     * The timezone offset from UTC to the devices timezone configuration, specified in the format +hh:mm.
     * @type {string}
     * @memberof FraudRegistrationDevice
     */
    timezoneOffset?: string;
    /**
     * A flag indicating that the device has been altered to allow privileged access to users. This flag should only be set to false if a test was performed and the result was negative. Leave unset otherwise.
     * @type {boolean}
     * @memberof FraudRegistrationDevice
     */
    rooted?: boolean;
    /**
     * A flag indicating that malware was detected on the mobile phone. This flag should only be set to false if a test was performed and the result was negative. Leave unset otherwise.
     * @type {boolean}
     * @memberof FraudRegistrationDevice
     */
    malwareDetected?: boolean;
    /**
     * A JSON object that can carry any additional information about the device that might be helpful for fraud detection.
     * @type {object}
     * @memberof FraudRegistrationDevice
     */
    userDefined?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum FraudRegistrationDeviceDeviceTypeEnum {
    Pos = 'device/pos',
    Mobile = 'device/mobile'
}

/**
 * Network information.
 * @export
 * @interface FraudRegistrationDeviceItems
 */
export interface FraudRegistrationDeviceItems {
    /**
     * Defines the type of network associated with the device.
     * @type {string}
     * @memberof FraudRegistrationDeviceItems
     */
    networkType: FraudRegistrationDeviceItemsNetworkTypeEnum;
    /**
     * The IPv4 or IPv6 address of the device if the network assigned one.
     * @type {string}
     * @memberof FraudRegistrationDeviceItems
     */
    ip?: string;
    /**
     * The MAC address of the device that is connected to the Wi-Fi network.
     * @type {string}
     * @memberof FraudRegistrationDeviceItems
     */
    mac?: string;
    /**
     * The Wi-Fi networks Service Set Identifier (SSID).
     * @type {string}
     * @memberof FraudRegistrationDeviceItems
     */
    ssid?: string;
    /**
     * The Wi-Fi networks Basic Service Set Identifier (BSSID).
     * @type {string}
     * @memberof FraudRegistrationDeviceItems
     */
    bssid?: string;
    /**
     * A JSON object that can carry any additional information about the network that might be helpful for fraud detection.
     * @type {object}
     * @memberof FraudRegistrationDeviceItems
     */
    userDefined?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum FraudRegistrationDeviceItemsNetworkTypeEnum {
    Mobile = 'network/mobile',
    Wifi = 'network/wifi'
}

/**
 * Error occurred during the registration.
 * @export
 * @interface FraudRegistrationError
 */
export interface FraudRegistrationError {
    /**
     * 
     * @type {Array<ErrorMessage>}
     * @memberof FraudRegistrationError
     */
    messages?: Array<ErrorMessage>;
}
/**
 * 
 * @export
 * @interface FraudRegistrationResponse
 */
export interface FraudRegistrationResponse {
    /**
     * The value used to track the transaction.
     * @type {string}
     * @memberof FraudRegistrationResponse
     */
    correlationId?: string;
    /**
     * Status of the transaction. Valid values are \'Not Processed\' and \'Scored successfully\'
     * @type {string}
     * @memberof FraudRegistrationResponse
     */
    transactionStatus?: FraudRegistrationResponseTransactionStatusEnum;
    /**
     * If status returned is \"failure\", input validation errors occurred. Please refer to the \"Errors Section\" for more info. Valid values are \'success\' and \'failed\'.
     * @type {string}
     * @memberof FraudRegistrationResponse
     */
    validationStatus?: string;
    /**
     * The transactionType provided in request.
     * @type {string}
     * @memberof FraudRegistrationResponse
     */
    transactionType?: string;
    /**
     * 
     * @type {FraudScore}
     * @memberof FraudRegistrationResponse
     */
    fraudScore?: FraudScore;
    /**
     * 
     * @type {FraudRegistrationError}
     * @memberof FraudRegistrationResponse
     */
    error?: FraudRegistrationError;
}

/**
    * @export
    * @enum {string}
    */
export enum FraudRegistrationResponseTransactionStatusEnum {
    ScoredSuccessfully = 'Scored Successfully',
    NotProcessed = 'Not Processed'
}

/**
 * Fraud likelihood assessment consisting of a score, associated warning(s), and explanation(s) of score received.
 * @export
 * @interface FraudScore
 */
export interface FraudScore {
    /**
     * The score attributed to this request by our machine learning system, ranging from 0 (less likely to be fraud) to 1000 (more likely to be fraud).
     * @type {string}
     * @memberof FraudScore
     */
    score?: string;
    /**
     * A list of non-critical warnings raised while processing the request. Warnings included in this list will have integration and data-quality related messages.
     * @type {Array<string>}
     * @memberof FraudScore
     */
    warnings?: Array<string>;
    /**
     * Explanation of the fraud score applied consisting of a description, type of the explanation, and rule (if applicable).
     * @type {Array<object>}
     * @memberof FraudScore
     */
    explanations?: Array<object>;
    /**
     * The score attributed to this request by our machine learning system, ranging from 0 (less likely to be fraud) to 1000 (more likely to be fraud).
     * @type {string}
     * @memberof FraudScore
     */
    recommendedDecision?: string;
}
/**
 * Object that holds all fraud settings.
 * @export
 * @interface FraudSettings
 */
export interface FraudSettings {
    /**
     * 
     * @type {BlockedItems}
     * @memberof FraudSettings
     */
    blockedItems?: BlockedItems;
    /**
     * 
     * @type {Array<MaximumPurchaseAmount>}
     * @memberof FraudSettings
     */
    maximumPurchaseAmount?: Array<MaximumPurchaseAmount>;
    /**
     * 
     * @type {LockoutTime}
     * @memberof FraudSettings
     */
    lockoutTime?: LockoutTime;
    /**
     * 
     * @type {CountryProfile}
     * @memberof FraudSettings
     */
    countryProfile?: CountryProfile;
}
/**
 * Response from fraud settings request.
 * @export
 * @interface FraudSettingsResponse
 */
export interface FraudSettingsResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof FraudSettingsResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof FraudSettingsResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof FraudSettingsResponse
     */
    responseType?: ResponseType;
    /**
     * The outlet ID.
     * @type {string}
     * @memberof FraudSettingsResponse
     */
    storeId?: string;
    /**
     * List of blocked card numbers.
     * @type {Array<BlockedCardNumber>}
     * @memberof FraudSettingsResponse
     */
    blockedCardNumbers?: Array<BlockedCardNumber>;
    /**
     * List of blocked fraud names.
     * @type {Array<string>}
     * @memberof FraudSettingsResponse
     */
    blockedNames?: Array<string>;
    /**
     * List of blocked fraud domain names.
     * @type {Array<string>}
     * @memberof FraudSettingsResponse
     */
    blockedDomainNames?: Array<string>;
    /**
     * List of blocked fraud IP address/Class C.
     * @type {Array<string>}
     * @memberof FraudSettingsResponse
     */
    blockedIpOrClassCAddresses?: Array<string>;
    /**
     * Maximum purchase amount limit.
     * @type {Array<MaximumPurchaseAmount>}
     * @memberof FraudSettingsResponse
     */
    maximumPurchaseAmount?: Array<MaximumPurchaseAmount>;
    /**
     * 
     * @type {LockoutTime}
     * @memberof FraudSettingsResponse
     */
    lockoutTime?: LockoutTime;
    /**
     * Country profile.
     * @type {string}
     * @memberof FraudSettingsResponse
     */
    countryProfile?: string;
}
/**
 * How often payments are sent.
 * @export
 * @interface Frequency
 */
export interface Frequency {
    /**
     * Rate of frequency.
     * @type {number}
     * @memberof Frequency
     */
    every: number;
    /**
     * Unit which defines the frequency.
     * @type {string}
     * @memberof Frequency
     */
    unit: FrequencyUnitEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum FrequencyUnitEnum {
    DAY = 'DAY',
    WEEK = 'WEEK',
    MONTH = 'MONTH',
    YEAR = 'YEAR'
}

/**
 * Pull disbursement information.
 * @export
 * @interface FundingTransactionType
 */
export interface FundingTransactionType extends Disbursement {
}
/**
 * 
 * @export
 * @interface Header
 */
export interface Header {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Header
     */
    color?: string;
}
/**
 * 
 * @export
 * @interface Hover
 */
export interface Hover {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Hover
     */
    color?: string;
}
/**
 * Identification information.
 * @export
 * @interface IdInfo
 */
export interface IdInfo {
    /**
     * Identification type.
     * @type {string}
     * @memberof IdInfo
     */
    idType?: string;
    /**
     * Identification data.
     * @type {string}
     * @memberof IdInfo
     */
    idData?: string;
}
/**
 * Industry-specific information.
 * @export
 * @interface IndustrySpecificExtensions
 */
export interface IndustrySpecificExtensions {
    /**
     * 
     * @type {Airline}
     * @memberof IndustrySpecificExtensions
     */
    airline?: Airline;
    /**
     * 
     * @type {Lodging}
     * @memberof IndustrySpecificExtensions
     */
    lodging?: Lodging;
    /**
     * 
     * @type {CarRental}
     * @memberof IndustrySpecificExtensions
     */
    carRental?: CarRental;
    /**
     * 
     * @type {Mcc6012}
     * @memberof IndustrySpecificExtensions
     */
    mcc6012?: Mcc6012;
}
/**
 * 
 * @export
 * @interface InitiateClearingResponse
 */
export interface InitiateClearingResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof InitiateClearingResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof InitiateClearingResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof InitiateClearingResponse
     */
    responseType?: ResponseType;
    /**
     * Request status. If it is anything other than \'SUCCESS\', please refer to 400s HTTP error codes or decline. See Error object for details.
     * @type {string}
     * @memberof InitiateClearingResponse
     */
    requestStatus?: InitiateClearingResponseRequestStatusEnum;
    /**
     * 
     * @type {ClearingDetails}
     * @memberof InitiateClearingResponse
     */
    clearingDetails?: ClearingDetails;
    /**
     * The array holds response information of the involved endpoints.
     * @type {Array<EndpointResponse>}
     * @memberof InitiateClearingResponse
     */
    endpointResponses?: Array<EndpointResponse>;
}

/**
    * @export
    * @enum {string}
    */
export enum InitiateClearingResponseRequestStatusEnum {
    SUCCESS = 'SUCCESS',
    PROCESSINGFAILED = 'PROCESSING_FAILED',
    FAILURE = 'FAILURE'
}

/**
 * 
 * @export
 * @interface InitiateClearingResponseAllOf
 */
export interface InitiateClearingResponseAllOf {
    /**
     * Request status. If it is anything other than \'SUCCESS\', please refer to 400s HTTP error codes or decline. See Error object for details.
     * @type {string}
     * @memberof InitiateClearingResponseAllOf
     */
    requestStatus?: InitiateClearingResponseAllOfRequestStatusEnum;
    /**
     * 
     * @type {ClearingDetails}
     * @memberof InitiateClearingResponseAllOf
     */
    clearingDetails?: ClearingDetails;
    /**
     * The array holds response information of the involved endpoints.
     * @type {Array<EndpointResponse>}
     * @memberof InitiateClearingResponseAllOf
     */
    endpointResponses?: Array<EndpointResponse>;
}

/**
    * @export
    * @enum {string}
    */
export enum InitiateClearingResponseAllOfRequestStatusEnum {
    SUCCESS = 'SUCCESS',
    PROCESSINGFAILED = 'PROCESSING_FAILED',
    FAILURE = 'FAILURE'
}

/**
 * Indicates that the total sum payable is divided for payment at successive fixed times.
 * @export
 * @interface InstallmentOptions
 */
export interface InstallmentOptions {
    /**
     * Number of installments for a sale transaction if the customer pays the total amount in multiple transactions.
     * @type {number}
     * @memberof InstallmentOptions
     */
    numberOfInstallments?: number;
    /**
     * Indicates whether the installment interest amount has been applied.
     * @type {boolean}
     * @memberof InstallmentOptions
     */
    installmentsInterest?: boolean;
    /**
     * The number of months the first installment payment will be delayed.
     * @type {number}
     * @memberof InstallmentOptions
     */
    installmentDelayMonths?: number;
    /**
     * The type of recurring payment.
     * @type {string}
     * @memberof InstallmentOptions
     */
    recurringType?: InstallmentOptionsRecurringTypeEnum;
    /**
     * Indicates if the merchant supports merchant advice code (MAC) in order to receive table 55 code for a declined recurring transaction.
     * @type {boolean}
     * @memberof InstallmentOptions
     */
    merchantAdviceCodeSupported?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InstallmentOptionsRecurringTypeEnum {
    FIRST = 'FIRST',
    REPEAT = 'REPEAT',
    STANDINGINSTRUCTION = 'STANDING_INSTRUCTION'
}

/**
 * The issuers response to the payment request. This field should be filled in when the message has already passed through the issuer (e.g. post-authorization).
 * @export
 * @interface IssuerResponse
 */
export interface IssuerResponse {
    /**
     * The verification response code, as sent by the verification system.
     * @type {string}
     * @memberof IssuerResponse
     */
    code: string;
    /**
     * The interpretation of the response code. Valid values are \"approved\" - The verification was conducted and is approved. \"declined\" - The verification was conducted and is not approved. \"disabled\" - The verification was not conducted because it was not requested or disabled in the verification. \"unknown\" - The verification was attempted but it failed due to some system error (e.g. timeout).
     * @type {string}
     * @memberof IssuerResponse
     */
    status?: IssuerResponseStatusEnum;
    /**
     * An identifier of the system/specification from which the code was received, and how the status was derived.
     * @type {string}
     * @memberof IssuerResponse
     */
    scheme: string;
}

/**
    * @export
    * @enum {string}
    */
export enum IssuerResponseStatusEnum {
    Approved = 'approved',
    Declined = 'declined',
    Disabled = 'disabled',
    Unknown = 'unknown'
}

/**
 * Network information.
 * @export
 * @interface Items
 */
export interface Items {
    /**
     * Defines the type of network associated with the device.
     * @type {string}
     * @memberof Items
     */
    networkType: ItemsNetworkTypeEnum;
    /**
     * The IPv4 or IPv6 address of the device if the network assigned one.
     * @type {string}
     * @memberof Items
     */
    ip?: string;
    /**
     * The devices primary phone number. This value should be supplied directly without any transformation (e.g. removal of spaces, hyphens or parentheses). If this data is available in segregated fields, it should be concatenated using a blank space (\" \") as a separator.
     * @type {string}
     * @memberof Items
     */
    phoneNumber?: string;
    /**
     * The network carrier name.
     * @type {string}
     * @memberof Items
     */
    carrierName?: string;
    /**
     * The Mobile Country Code (MCC) as described in the ITUs E.212 specification.
     * @type {string}
     * @memberof Items
     */
    mobileCountryCode?: string;
    /**
     * The Mobile Network Code (MNC) as described in the ITUs E.212 specification.
     * @type {string}
     * @memberof Items
     */
    mobileNetworkCode?: string;
    /**
     * The Mobile Subscription Identification Number code (MSIN) as described in the ITUs E.212 specification.
     * @type {string}
     * @memberof Items
     */
    subscriptionIdentificationNumber?: string;
    /**
     * The Location Area Code (LAC) is a 16-bit identifier for a region that is covered by a set of network antennas.
     * @type {string}
     * @memberof Items
     */
    locationAreaCode?: string;
    /**
     * The Cell ID (CID) is identifier for a specific Base Transceiver Station (BTS) within a specific Location Area Code (LAC).
     * @type {string}
     * @memberof Items
     */
    cellId?: string;
    /**
     * An identifier of the network standard used.
     * @type {string}
     * @memberof Items
     */
    standard?: string;
    /**
     * The MAC address of the device that is connected to the Wi-Fi network.
     * @type {string}
     * @memberof Items
     */
    mac?: string;
    /**
     * The Wi-Fi networks Service Set Identifier (SSID).
     * @type {string}
     * @memberof Items
     */
    ssid?: string;
    /**
     * The Wi-Fi networks Basic Service Set Identifier (BSSID).
     * @type {string}
     * @memberof Items
     */
    bssid?: string;
    /**
     * A JSON object that can carry any additional information about the network that might be helpful for fraud detection.
     * @type {object}
     * @memberof Items
     */
    userDefined?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ItemsNetworkTypeEnum {
    Mobile = 'network/mobile',
    Wifi = 'network/wifi'
}

/**
 * The specific location (e.g. store or station) where the transaction takes place.
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * The unique ID of this location.
     * @type {string}
     * @memberof Location
     */
    locationId?: string;
    /**
     * 
     * @type {FraudAddress}
     * @memberof Location
     */
    merchantAddress?: FraudAddress;
    /**
     * Free-text field to describe a hierarchy the merchant would like to provide.
     * @type {string}
     * @memberof Location
     */
    hierarchy?: string;
    /**
     * The timezone offset from UTC to the merchants timezone configuration, specified in the format +hh:mm.
     * @type {string}
     * @memberof Location
     */
    timezoneOffset?: string;
    /**
     * A JSON object that can carry any additional information about the location that might be helpful for fraud detection.
     * @type {object}
     * @memberof Location
     */
    userDefined?: object;
}
/**
 * Object that holds information about lockout times.
 * @export
 * @interface LockoutTime
 */
export interface LockoutTime {
    /**
     * Auto-lockout time.
     * @type {number}
     * @memberof LockoutTime
     */
    autoLockoutTime?: number;
    /**
     * Duplicate lockout time.
     * @type {number}
     * @memberof LockoutTime
     */
    duplicateLockoutTime?: number;
}
/**
 * Additional data specific to the lodging/hotel industry.
 * @export
 * @interface Lodging
 */
export interface Lodging {
    /**
     * Date of arrival.
     * @type {string}
     * @memberof Lodging
     */
    arrivalDate?: string;
    /**
     * Date of departure.
     * @type {string}
     * @memberof Lodging
     */
    departureDate?: string;
    /**
     * Portfolio number.
     * @type {string}
     * @memberof Lodging
     */
    folioNumber?: string;
    /**
     * Information about charges other than base lodging.
     * @type {Array<LodgingExtraCharges>}
     * @memberof Lodging
     */
    extraCharges?: Array<LodgingExtraCharges>;
    /**
     * Indicates if the transaction is associated with a delayed or no-show penalty.
     * @type {boolean}
     * @memberof Lodging
     */
    noShowIndicator?: boolean;
}
/**
 * 
 * @export
 * @interface LodgingExtraCharges
 */
export interface LodgingExtraCharges {
    /**
     * 
     * @type {string}
     * @memberof LodgingExtraCharges
     */
    chargeItem?: LodgingExtraChargesChargeItemEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum LodgingExtraChargesChargeItemEnum {
    GIFTSHOP = 'GIFT_SHOP',
    LAUNDRY = 'LAUNDRY',
    MINIBAR = 'MINI_BAR',
    RESTAURANT = 'RESTAURANT',
    TELEPHONE = 'TELEPHONE',
    OTHER = 'OTHER'
}

/**
 * Object contains logo data.
 * @export
 * @interface Logo
 */
export interface Logo {
    /**
     * Define position of logo.
     * @type {string}
     * @memberof Logo
     */
    position: LogoPositionEnum;
    /**
     * The filename of the uploaded logo.
     * @type {string}
     * @memberof Logo
     */
    filename: string;
    /**
     * Base64 image data.
     * @type {string}
     * @memberof Logo
     */
    data: string;
}

/**
    * @export
    * @enum {string}
    */
export enum LogoPositionEnum {
    TOP = 'TOP',
    BOTTOM = 'BOTTOM'
}

/**
 * The loyalty program information associated with this payment.
 * @export
 * @interface Loyalty
 */
export interface Loyalty {
    /**
     * A unique ID associated with the loyalty program account. Must be unique within the merchants system. Depending on loyalty programs the account might also serve as a credit/bank account. If this is the case the ID must be not be the PAN.
     * @type {string}
     * @memberof Loyalty
     */
    id?: string;
    /**
     * A string that identifies the program in which the customer is enrolled if the merchant supports several programs or levels.
     * @type {string}
     * @memberof Loyalty
     */
    program?: string;
    /**
     * The balance of the loyalty program account in a program specific currency (e.g. points).
     * @type {number}
     * @memberof Loyalty
     */
    balance?: number;
}
/**
 * Masterpass Wallet payment method information.
 * @export
 * @interface MasterpassWalletPaymentMethod
 */
export interface MasterpassWalletPaymentMethod extends WalletPaymentMethod {
    /**
     * Masterpass Wallet ID.
     * @type {string}
     * @memberof MasterpassWalletPaymentMethod
     */
    walletId: string;
    /**
     * 
     * @type {PaymentCard}
     * @memberof MasterpassWalletPaymentMethod
     */
    paymentCard: PaymentCard;
}
/**
 * 
 * @export
 * @interface MasterpassWalletPaymentMethodAllOf
 */
export interface MasterpassWalletPaymentMethodAllOf {
    /**
     * Masterpass Wallet ID.
     * @type {string}
     * @memberof MasterpassWalletPaymentMethodAllOf
     */
    walletId: string;
    /**
     * 
     * @type {PaymentCard}
     * @memberof MasterpassWalletPaymentMethodAllOf
     */
    paymentCard: PaymentCard;
}
/**
 * Object that holds information about maximum purchase amount limit.
 * @export
 * @interface MaximumPurchaseAmount
 */
export interface MaximumPurchaseAmount {
    /**
     * Currency in alphabetic ISO 4217 currency code format.
     * @type {string}
     * @memberof MaximumPurchaseAmount
     */
    currency: string;
    /**
     * Maximum purchase amount limit.
     * @type {string}
     * @memberof MaximumPurchaseAmount
     */
    maxAmount: string;
}
/**
 * The group MCC (Merchant Category Code) 6012
 * @export
 * @interface Mcc6012
 */
export interface Mcc6012 {
    /**
     * The date of birth of the cardholder (YYYYMMDD).
     * @type {string}
     * @memberof Mcc6012
     */
    dateOfBirth?: string;
    /**
     * The first six digits of the primary account number.
     * @type {string}
     * @memberof Mcc6012
     */
    accountFirst6?: string;
    /**
     * The last four digits of the primary account number.
     * @type {string}
     * @memberof Mcc6012
     */
    accountLast4?: string;
    /**
     * The account number where the primary account number is not a card.
     * @type {string}
     * @memberof Mcc6012
     */
    accountNum?: string;
    /**
     * The postal code of the cardholder.
     * @type {string}
     * @memberof Mcc6012
     */
    postCode?: string;
    /**
     * Surname or last name of the card holder.
     * @type {string}
     * @memberof Mcc6012
     */
    surname?: string;
}
/**
 * The merchant where this transaction occurred.
 * @export
 * @interface Merchant
 */
export interface Merchant {
    /**
     * The 4-digit Merchant Category Code. The merchant might be associated with multiple MCCs. In that case the MCC provided here will be the one that better describes the current transaction.
     * @type {string}
     * @memberof Merchant
     */
    mcc?: string;
    /**
     * The unique ID of this merchant. Must be unique for the entire system (not just within a specific industry).
     * @type {string}
     * @memberof Merchant
     */
    merchantUniqueId: string;
    /**
     * 
     * @type {Location}
     * @memberof Merchant
     */
    location?: Location;
    /**
     * A JSON object that can carry any additional information about the merchant that might be helpful for fraud detection.
     * @type {object}
     * @memberof Merchant
     */
    userDefined?: object;
}
/**
 * Info about the payment method.
 * @export
 * @interface Method
 */
export interface Method {
    /**
     * Unique ID for the payment method type.
     * @type {string}
     * @memberof Method
     */
    methodType: MethodMethodTypeEnum;
    /**
     * The unique ID of this payment method if it was previously registered with a registration/method or if it is currently being registered. Must be unique for the entire system (not just within a specific merchant or industry). Mandatory if being used inside a registration/method.
     * @type {string}
     * @memberof Method
     */
    methodId?: string;
    /**
     * The address that should be used to send billing information for this payment method.
     * @type {string}
     * @memberof Method
     */
    methodAlias?: string;
    /**
     * 
     * @type {Card}
     * @memberof Method
     */
    card: Card;
    /**
     * The wallet provider. This field should be normalized before sending through the API.
     * @type {string}
     * @memberof Method
     */
    provider?: string;
    /**
     * A JSON object that can carry any additional information about the method that might be helpful for fraud detection.
     * @type {object}
     * @memberof Method
     */
    userDefined?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum MethodMethodTypeEnum {
    Card = 'method/card',
    Wallet = 'method/wallet'
}

/**
 * Object contains configurable style properties for mobile.
 * @export
 * @interface Mobile
 */
export interface Mobile {
    /**
     * 
     * @type {MobileHeaderArea}
     * @memberof Mobile
     */
    headerArea?: MobileHeaderArea;
    /**
     * check if logo should be shown
     * @type {boolean}
     * @memberof Mobile
     */
    showLogo?: boolean;
}
/**
 * 
 * @export
 * @interface MobileHeaderArea
 */
export interface MobileHeaderArea {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof MobileHeaderArea
     */
    color?: string;
}
/**
 * Error information.
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Uniquely identifies an error condition. Client applications need to read and handle errors based on this.
     * @type {string}
     * @memberof ModelError
     */
    code?: string;
    /**
     * A generic description of the error condition.
     * @type {string}
     * @memberof ModelError
     */
    message?: string;
    /**
     * Detailed information about message format errors.
     * @type {Array<ErrorDetails>}
     * @memberof ModelError
     */
    details?: Array<ErrorDetails>;
}
/**
 * Use this model to provide order related details.
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * Client Order ID if supplied by client.
     * @type {string}
     * @memberof Order
     */
    orderId?: string;
    /**
     * 
     * @type {Billing}
     * @memberof Order
     */
    billing?: Billing;
    /**
     * 
     * @type {Shipping}
     * @memberof Order
     */
    shipping?: Shipping;
    /**
     * 
     * @type {IndustrySpecificExtensions}
     * @memberof Order
     */
    industrySpecificExtensions?: IndustrySpecificExtensions;
    /**
     * 
     * @type {PurchaseCards}
     * @memberof Order
     */
    purchaseCard?: PurchaseCards;
    /**
     * 
     * @type {InstallmentOptions}
     * @memberof Order
     */
    installmentOptions?: InstallmentOptions;
    /**
     * 
     * @type {SoftDescriptor}
     * @memberof Order
     */
    softDescriptor?: SoftDescriptor;
    /**
     * 
     * @type {AdditionalDetails}
     * @memberof Order
     */
    additionalDetails?: AdditionalDetails;
    /**
     * 
     * @type {BancontactQR}
     * @memberof Order
     */
    bancontactQR?: BancontactQR;
}
/**
 * Order response with error field included.
 * @export
 * @interface OrderErrorResponse
 */
export interface OrderErrorResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof OrderErrorResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof OrderErrorResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof OrderErrorResponse
     */
    responseType?: ResponseType;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof OrderErrorResponse
     */
    orderId?: string;
    /**
     * 
     * @type {Billing}
     * @memberof OrderErrorResponse
     */
    billing?: Billing;
    /**
     * 
     * @type {Shipping}
     * @memberof OrderErrorResponse
     */
    shipping?: Shipping;
    /**
     * Required for some payment methods (for example, Klarna).
     * @type {Array<TransactionResponse>}
     * @memberof OrderErrorResponse
     */
    transactions?: Array<TransactionResponse>;
    /**
     * 
     * @type {AdditionalDetails}
     * @memberof OrderErrorResponse
     */
    additionalDetails?: AdditionalDetails;
    /**
     * 
     * @type {Error}
     * @memberof OrderErrorResponse
     */
    error?: Error;
}
/**
 * Common object for primary and secondary payment request responses.
 * @export
 * @interface OrderResponse
 */
export interface OrderResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof OrderResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof OrderResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof OrderResponse
     */
    responseType?: ResponseType;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof OrderResponse
     */
    orderId?: string;
    /**
     * 
     * @type {Billing}
     * @memberof OrderResponse
     */
    billing?: Billing;
    /**
     * 
     * @type {Shipping}
     * @memberof OrderResponse
     */
    shipping?: Shipping;
    /**
     * Required for some payment methods (for example, Klarna).
     * @type {Array<TransactionResponse>}
     * @memberof OrderResponse
     */
    transactions?: Array<TransactionResponse>;
    /**
     * 
     * @type {AdditionalDetails}
     * @memberof OrderResponse
     */
    additionalDetails?: AdditionalDetails;
}
/**
 * The payment object for PayPal transactions.
 * @export
 * @interface PayPal
 */
export interface PayPal {
    /**
     * Email address of the recipient.
     * @type {string}
     * @memberof PayPal
     */
    recipientEmail: string;
}
/**
 * Payment method containing PayPal information.
 * @export
 * @interface PayPalPaymentMethod
 */
export interface PayPalPaymentMethod {
    /**
     * 
     * @type {PayPal}
     * @memberof PayPalPaymentMethod
     */
    payPal: PayPal;
}
/**
 * 
 * @export
 * @interface PayPalPaymentMethodAllOf
 */
export interface PayPalPaymentMethodAllOf {
    /**
     * 
     * @type {PayPal}
     * @memberof PayPalPaymentMethodAllOf
     */
    payPal: PayPal;
}
/**
 * Payment information for the transaction.
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * Defines the type of the payment.
     * @type {string}
     * @memberof Payment
     */
    paymentType: PaymentPaymentTypeEnum;
    /**
     * 
     * @type {Method}
     * @memberof Payment
     */
    method: Method;
    /**
     * Indicates if the cards Personal Identification Number was supplied.
     * @type {boolean}
     * @memberof Payment
     */
    pinPresent: boolean;
    /**
     * The method in which the card information entered the system.
     * @type {string}
     * @memberof Payment
     */
    entryMethod: PaymentEntryMethodEnum;
    /**
     * 
     * @type {IssuerResponse}
     * @memberof Payment
     */
    issuerResponse?: IssuerResponse;
    /**
     * The actual approved amount. This field should be filled in when the message has already passed through the issuer (e.g. post-authorization). For transaction/authorization this amount refers to the amount that was locked on the card-holders account.
     * @type {string}
     * @memberof Payment
     */
    issuerApprovedAmount?: string;
    /**
     * The payment methods account balance if available. This field should be filled in when the message has already passed through the issuer (e.g. post-authorization).
     * @type {string}
     * @memberof Payment
     */
    issuerCardBalance?: string;
    /**
     * 
     * @type {VerificationAvs}
     * @memberof Payment
     */
    verificationAvs?: VerificationAvs;
    /**
     * 
     * @type {Verification3ds}
     * @memberof Payment
     */
    verification3ds?: Verification3ds;
    /**
     * 
     * @type {VerificationCvv}
     * @memberof Payment
     */
    verificationCvv?: VerificationCvv;
    /**
     * A JSON object that carries any additional information that might be helpful for fraud detection.
     * @type {object}
     * @memberof Payment
     */
    userDefined?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentPaymentTypeEnum {
    Card = 'payment/card',
    Wallet = 'payment/wallet'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentEntryMethodEnum {
    Manual = 'manual',
    Stripe = 'stripe',
    Ocr = 'ocr',
    Emv = 'emv',
    Nfc = 'nfc',
    Remote = 'remote',
    PinPresent = 'pin_present'
}

/**
 * Payment card model.
 * @export
 * @interface PaymentCard
 */
export interface PaymentCard {
    /**
     * Payment card number.
     * @type {string}
     * @memberof PaymentCard
     */
    number: string;
    /**
     * 
     * @type {Expiration}
     * @memberof PaymentCard
     */
    expiryDate?: Expiration;
    /**
     * Card verification value/number.
     * @type {string}
     * @memberof PaymentCard
     */
    securityCode?: string;
    /**
     * 
     * @type {CardFunction}
     * @memberof PaymentCard
     */
    cardFunction?: CardFunction;
    /**
     * Name of the cardholder.
     * @type {string}
     * @memberof PaymentCard
     */
    cardholderName?: string;
    /**
     * The payment card BIN.
     * @type {string}
     * @memberof PaymentCard
     */
    bin?: string;
    /**
     * The last 4 numbers of a payment card.
     * @type {string}
     * @memberof PaymentCard
     */
    last4?: string;
    /**
     * Required only if using dual branded card.
     * @type {string}
     * @memberof PaymentCard
     */
    brand?: string;
}
/**
 * Request to create credit transaction using payment card.
 * @export
 * @interface PaymentCardCreditTransaction
 */
export interface PaymentCardCreditTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardCreditTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentCardCreditTransaction
     */
    currencyConversion?: CurrencyConversion;
}
/**
 * Request to create disbursement transaction using a payment card.
 * @export
 * @interface PaymentCardDisbursementTransaction
 */
export interface PaymentCardDisbursementTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {Disbursement}
     * @memberof PaymentCardDisbursementTransaction
     */
    disbursement: Disbursement;
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardDisbursementTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentCardDisbursementTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentCardDisbursementTransaction
     */
    createToken?: CreatePaymentToken;
}
/**
 * 
 * @export
 * @interface PaymentCardDisbursementTransactionAllOf
 */
export interface PaymentCardDisbursementTransactionAllOf {
    /**
     * 
     * @type {Disbursement}
     * @memberof PaymentCardDisbursementTransactionAllOf
     */
    disbursement: Disbursement;
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardDisbursementTransactionAllOf
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentCardDisbursementTransactionAllOf
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentCardDisbursementTransactionAllOf
     */
    createToken?: CreatePaymentToken;
}
/**
 * Request to create forced ticket primary transaction.
 * @export
 * @interface PaymentCardForcedTicketTransaction
 */
export interface PaymentCardForcedTicketTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardForcedTicketTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * Stores the six-digit reference number you have received as the result of a successful external authorization (e.g. by phone). The gateway needs this number for uniquely mapping a ForcedTicket transaction to a previously performed external authorization.
     * @type {string}
     * @memberof PaymentCardForcedTicketTransaction
     */
    referenceNumber: string;
}
/**
 * 
 * @export
 * @interface PaymentCardForcedTicketTransactionAllOf
 */
export interface PaymentCardForcedTicketTransactionAllOf {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardForcedTicketTransactionAllOf
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * Stores the six-digit reference number you have received as the result of a successful external authorization (e.g. by phone). The gateway needs this number for uniquely mapping a ForcedTicket transaction to a previously performed external authorization.
     * @type {string}
     * @memberof PaymentCardForcedTicketTransactionAllOf
     */
    referenceNumber: string;
}
/**
 * Used to request information associated with a payment card.
 * @export
 * @interface PaymentCardInfoLookupRequest
 */
export interface PaymentCardInfoLookupRequest extends AccountInfoLookupRequest {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentCardInfoLookupRequest
     */
    paymentCard: PaymentCard;
}
/**
 * 
 * @export
 * @interface PaymentCardInfoLookupRequestAllOf
 */
export interface PaymentCardInfoLookupRequestAllOf {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentCardInfoLookupRequestAllOf
     */
    paymentCard: PaymentCard;
}
/**
 * Request to create payer auth primary transaction.
 * @export
 * @interface PaymentCardPayerAuthTransaction
 */
export interface PaymentCardPayerAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardPayerAuthTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentCardPayerAuthTransaction
     */
    currencyConversion?: CurrencyConversion;
}
/**
 * 
 * @export
 * @interface PaymentCardPayerAuthTransactionAllOf
 */
export interface PaymentCardPayerAuthTransactionAllOf {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardPayerAuthTransactionAllOf
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentCardPayerAuthTransactionAllOf
     */
    currencyConversion?: CurrencyConversion;
}
/**
 * Payment method containing payment card information.
 * @export
 * @interface PaymentCardPaymentMethod
 */
export interface PaymentCardPaymentMethod {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentCardPaymentMethod
     */
    paymentCard: PaymentCard;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof PaymentCardPaymentMethod
     */
    paymentFacilitator?: PaymentFacilitator;
}
/**
 * 
 * @export
 * @interface PaymentCardPaymentMethodAllOf
 */
export interface PaymentCardPaymentMethodAllOf {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentCardPaymentMethodAllOf
     */
    paymentCard: PaymentCard;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof PaymentCardPaymentMethodAllOf
     */
    paymentFacilitator?: PaymentFacilitator;
}
/**
 * Request to update payment token for one or more cards.
 * @export
 * @interface PaymentCardPaymentTokenUpdateRequest
 */
export interface PaymentCardPaymentTokenUpdateRequest {
    /**
     * Object name of tokenization request.
     * @type {string}
     * @memberof PaymentCardPaymentTokenUpdateRequest
     */
    requestType: string;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof PaymentCardPaymentTokenUpdateRequest
     */
    storeId?: string;
    /**
     * List of payment tokens to be updated in the request.
     * @type {Array<UpdatePaymentToken>}
     * @memberof PaymentCardPaymentTokenUpdateRequest
     */
    paymentTokens: Array<UpdatePaymentToken>;
}
/**
 * Used to generate payment tokens during payment.
 * @export
 * @interface PaymentCardPaymentTokenizationRequest
 */
export interface PaymentCardPaymentTokenizationRequest extends PaymentTokenizationRequest {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentCardPaymentTokenizationRequest
     */
    paymentCard: PaymentCard;
}
/**
 * 
 * @export
 * @interface PaymentCardPaymentTokenizationRequestAllOf
 */
export interface PaymentCardPaymentTokenizationRequestAllOf {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentCardPaymentTokenizationRequestAllOf
     */
    paymentCard: PaymentCard;
}
/**
 * Request to create pre-auth transaction using credit card.
 * @export
 * @interface PaymentCardPreAuthTransaction
 */
export interface PaymentCardPreAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardPreAuthTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentCardPreAuthTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentCardPreAuthTransaction
     */
    createToken?: CreatePaymentToken;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PaymentCardPreAuthTransaction
     */
    splitShipment?: SplitShipment;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentCardPreAuthTransaction
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentCardPreAuthTransaction
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentCardPreAuthTransaction
     */
    authenticationResult?: AuthenticationResult;
    /**
     * This flag can only be used in a preAuth transaction that updates the amount of a previous preAuth transaction to either increase the preAuth amount (DecrementalPreAuthFlag = false) or decrease the preAuth amount (DecrementalPreAuthFlag = true).
     * @type {boolean}
     * @memberof PaymentCardPreAuthTransaction
     */
    decrementalFlag?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentCardPreAuthTransactionAllOf
 */
export interface PaymentCardPreAuthTransactionAllOf {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardPreAuthTransactionAllOf
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentCardPreAuthTransactionAllOf
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentCardPreAuthTransactionAllOf
     */
    createToken?: CreatePaymentToken;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PaymentCardPreAuthTransactionAllOf
     */
    splitShipment?: SplitShipment;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentCardPreAuthTransactionAllOf
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentCardPreAuthTransactionAllOf
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentCardPreAuthTransactionAllOf
     */
    authenticationResult?: AuthenticationResult;
    /**
     * This flag can only be used in a preAuth transaction that updates the amount of a previous preAuth transaction to either increase the preAuth amount (DecrementalPreAuthFlag = false) or decrease the preAuth amount (DecrementalPreAuthFlag = true).
     * @type {boolean}
     * @memberof PaymentCardPreAuthTransactionAllOf
     */
    decrementalFlag?: boolean;
}
/**
 * Request to create sale transaction using payment card.
 * @export
 * @interface PaymentCardSaleTransaction
 */
export interface PaymentCardSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardSaleTransaction
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentCardSaleTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentCardSaleTransaction
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentCardSaleTransaction
     */
    createToken?: CreatePaymentToken;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentCardSaleTransaction
     */
    currencyConversion?: CurrencyConversion;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentCardSaleTransaction
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentCardSaleTransaction
     */
    authenticationResult?: AuthenticationResult;
}
/**
 * 
 * @export
 * @interface PaymentCardSaleTransactionAllOf
 */
export interface PaymentCardSaleTransactionAllOf {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentCardSaleTransactionAllOf
     */
    paymentMethod: PaymentCardPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentCardSaleTransactionAllOf
     */
    storedCredentials?: StoredCredential;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentCardSaleTransactionAllOf
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentCardSaleTransactionAllOf
     */
    createToken?: CreatePaymentToken;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentCardSaleTransactionAllOf
     */
    currencyConversion?: CurrencyConversion;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentCardSaleTransactionAllOf
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentCardSaleTransactionAllOf
     */
    authenticationResult?: AuthenticationResult;
}
/**
 * Used to request account verification using a payment card. The expiryDate in paymentCard object is required to perform a PaymentCardVerificationRequest.
 * @export
 * @interface PaymentCardVerificationRequest
 */
export interface PaymentCardVerificationRequest extends AccountVerificationRequest {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentCardVerificationRequest
     */
    paymentCard: PaymentCard;
}
/**
 * 
 * @export
 * @interface PaymentCardVerificationRequestAllOf
 */
export interface PaymentCardVerificationRequestAllOf {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentCardVerificationRequestAllOf
     */
    paymentCard: PaymentCard;
}
/**
 * Information from the payment device including the blob data and its mode of entry.
 * @export
 * @interface PaymentDevice
 */
export interface PaymentDevice {
    /**
     * The data format.
     * @type {string}
     * @memberof PaymentDevice
     */
    deviceType: PaymentDeviceDeviceTypeEnum;
    /**
     * Data from device containing, at a minimum, a transaction-unique key serial number (KSN) and track 2 card data.
     * @type {string}
     * @memberof PaymentDevice
     */
    data: string;
    /**
     * Card verification value/number.
     * @type {string}
     * @memberof PaymentDevice
     */
    securityCode?: string;
    /**
     * Name of cardholder.
     * @type {string}
     * @memberof PaymentDevice
     */
    cardholderName?: string;
    /**
     * 
     * @type {CardFunction}
     * @memberof PaymentDevice
     */
    cardFunction?: CardFunction;
    /**
     * The card brand.
     * @type {string}
     * @memberof PaymentDevice
     */
    brand?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentDeviceDeviceTypeEnum {
    SWIPE = 'SWIPE'
}

/**
 * Request to create credit transaction using decrypted card details from payment device. The transaction origin will be fixed as PHONE when data is manually entered into the device and as RETAIL when data is entered into the device via swipe.
 * @export
 * @interface PaymentDeviceCreditTransaction
 */
export interface PaymentDeviceCreditTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDeviceCreditTransaction
     */
    paymentMethod: PaymentDevicePaymentMethod;
}
/**
 * 
 * @export
 * @interface PaymentDeviceCreditTransactionAllOf
 */
export interface PaymentDeviceCreditTransactionAllOf {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDeviceCreditTransactionAllOf
     */
    paymentMethod: PaymentDevicePaymentMethod;
}
/**
 * Request to create disbursement transaction using decrypted card details from payment device. The transaction origin will be fixed as PHONE when data is manually entered into the device and as RETAIL when data is entered into the device via swipe.
 * @export
 * @interface PaymentDeviceDisbursementTransaction
 */
export interface PaymentDeviceDisbursementTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDeviceDisbursementTransaction
     */
    paymentMethod: PaymentDevicePaymentMethod;
    /**
     * 
     * @type {Disbursement}
     * @memberof PaymentDeviceDisbursementTransaction
     */
    disbursement: Disbursement;
}
/**
 * 
 * @export
 * @interface PaymentDeviceDisbursementTransactionAllOf
 */
export interface PaymentDeviceDisbursementTransactionAllOf {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDeviceDisbursementTransactionAllOf
     */
    paymentMethod: PaymentDevicePaymentMethod;
    /**
     * 
     * @type {Disbursement}
     * @memberof PaymentDeviceDisbursementTransactionAllOf
     */
    disbursement: Disbursement;
}
/**
 * Payment method containing payment device information.
 * @export
 * @interface PaymentDevicePaymentMethod
 */
export interface PaymentDevicePaymentMethod {
    /**
     * 
     * @type {PaymentDevice}
     * @memberof PaymentDevicePaymentMethod
     */
    paymentDevice: PaymentDevice;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof PaymentDevicePaymentMethod
     */
    paymentFacilitator?: PaymentFacilitator;
}
/**
 * 
 * @export
 * @interface PaymentDevicePaymentMethodAllOf
 */
export interface PaymentDevicePaymentMethodAllOf {
    /**
     * 
     * @type {PaymentDevice}
     * @memberof PaymentDevicePaymentMethodAllOf
     */
    paymentDevice: PaymentDevice;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof PaymentDevicePaymentMethodAllOf
     */
    paymentFacilitator?: PaymentFacilitator;
}
/**
 * Used to generate payment tokens during payment using a payment device.
 * @export
 * @interface PaymentDevicePaymentTokenizationRequest
 */
export interface PaymentDevicePaymentTokenizationRequest extends PaymentTokenizationRequest {
    /**
     * 
     * @type {PaymentDevice}
     * @memberof PaymentDevicePaymentTokenizationRequest
     */
    paymentDevice: PaymentDevice;
}
/**
 * 
 * @export
 * @interface PaymentDevicePaymentTokenizationRequestAllOf
 */
export interface PaymentDevicePaymentTokenizationRequestAllOf {
    /**
     * 
     * @type {PaymentDevice}
     * @memberof PaymentDevicePaymentTokenizationRequestAllOf
     */
    paymentDevice: PaymentDevice;
}
/**
 * Request to create pre-auth transaction using decrypted card details from payment device. The transaction origin will be fixed as PHONE when data is manually entered into the device and as RETAIL when data is entered into the device via swipe.
 * @export
 * @interface PaymentDevicePreAuthTransaction
 */
export interface PaymentDevicePreAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDevicePreAuthTransaction
     */
    paymentMethod: PaymentDevicePaymentMethod;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentDevicePreAuthTransaction
     */
    createToken?: CreatePaymentToken;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentDevicePreAuthTransaction
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentDevicePreAuthTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PaymentDevicePreAuthTransaction
     */
    splitShipment?: SplitShipment;
    /**
     * This flag can only be used in a preAuth transaction that updates the amount of a previous preAuth transaction to either increase the preAuth amount (DecrementalPreAuthFlag = false) or decrease the preAuth amount (DecrementalPreAuthFlag = true).
     * @type {boolean}
     * @memberof PaymentDevicePreAuthTransaction
     */
    decrementalFlag?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentDevicePreAuthTransactionAllOf
 */
export interface PaymentDevicePreAuthTransactionAllOf {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDevicePreAuthTransactionAllOf
     */
    paymentMethod: PaymentDevicePaymentMethod;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentDevicePreAuthTransactionAllOf
     */
    createToken?: CreatePaymentToken;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentDevicePreAuthTransactionAllOf
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentDevicePreAuthTransactionAllOf
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PaymentDevicePreAuthTransactionAllOf
     */
    splitShipment?: SplitShipment;
    /**
     * This flag can only be used in a preAuth transaction that updates the amount of a previous preAuth transaction to either increase the preAuth amount (DecrementalPreAuthFlag = false) or decrease the preAuth amount (DecrementalPreAuthFlag = true).
     * @type {boolean}
     * @memberof PaymentDevicePreAuthTransactionAllOf
     */
    decrementalFlag?: boolean;
}
/**
 * Request to create sale transaction using decrypted card details from payment device. The transaction origin will be fixed as PHONE when data is manually entered into the device and as RETAIL when data is entered into the device via swipe.
 * @export
 * @interface PaymentDeviceSaleTransaction
 */
export interface PaymentDeviceSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDeviceSaleTransaction
     */
    paymentMethod: PaymentDevicePaymentMethod;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentDeviceSaleTransaction
     */
    createToken?: CreatePaymentToken;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentDeviceSaleTransaction
     */
    storedCredentials?: StoredCredential;
}
/**
 * 
 * @export
 * @interface PaymentDeviceSaleTransactionAllOf
 */
export interface PaymentDeviceSaleTransactionAllOf {
    /**
     * 
     * @type {PaymentDevicePaymentMethod}
     * @memberof PaymentDeviceSaleTransactionAllOf
     */
    paymentMethod: PaymentDevicePaymentMethod;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentDeviceSaleTransactionAllOf
     */
    createToken?: CreatePaymentToken;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentDeviceSaleTransactionAllOf
     */
    storedCredentials?: StoredCredential;
}
/**
 * Payment facilitator details provided by the merchant.
 * @export
 * @interface PaymentFacilitator
 */
export interface PaymentFacilitator {
    /**
     * External merchant ID of the payment facilitator.
     * @type {string}
     * @memberof PaymentFacilitator
     */
    externalMerchantId: string;
    /**
     * Payment facilitator ID supplied during boarding.
     * @type {string}
     * @memberof PaymentFacilitator
     */
    paymentFacilitatorId: string;
    /**
     * Independent sales organization (ISO) ID provided by Mastercard.
     * @type {string}
     * @memberof PaymentFacilitator
     */
    saleOrganizationId?: string;
    /**
     * Payment facilitator name.
     * @type {string}
     * @memberof PaymentFacilitator
     */
    name: string;
    /**
     * 
     * @type {SubMerchantData}
     * @memberof PaymentFacilitator
     */
    subMerchantData?: SubMerchantData;
}
/**
 * Provides details of the payment method used.
 * @export
 * @interface PaymentMethodDetails
 */
export interface PaymentMethodDetails {
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentMethodDetails
     */
    paymentCard?: PaymentCard;
    /**
     * 
     * @type {PaymentMethodType}
     * @memberof PaymentMethodDetails
     */
    paymentMethodType?: PaymentMethodType;
}
/**
 * Request to create a new payment schedule using a payment method.
 * @export
 * @interface PaymentMethodPaymentSchedulesRequest
 */
export interface PaymentMethodPaymentSchedulesRequest extends PaymentSchedulesRequest {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentMethodPaymentSchedulesRequest
     */
    paymentMethod: PaymentCardPaymentMethod;
}
/**
 * 
 * @export
 * @interface PaymentMethodPaymentSchedulesRequestAllOf
 */
export interface PaymentMethodPaymentSchedulesRequestAllOf {
    /**
     * 
     * @type {PaymentCardPaymentMethod}
     * @memberof PaymentMethodPaymentSchedulesRequestAllOf
     */
    paymentMethod: PaymentCardPaymentMethod;
}
/**
 * Type of payment method.
 * @export
 * @enum {string}
 */
export enum PaymentMethodType {
    ALIPAY = 'ALIPAY',
    ALIPAYPAYSECUREUS = 'ALIPAY_PAYSECURE_US',
    ALIPAYDOMESTIC = 'ALIPAY_DOMESTIC',
    APM = 'APM',
    CUPDOMESTIC = 'CUP_DOMESTIC',
    DEBITDE = 'DEBITDE',
    EMI = 'EMI',
    GIROPAY = 'GIROPAY',
    IDEAL = 'IDEAL',
    INDIAWALLET = 'INDIAWALLET',
    KLARNA = 'KLARNA',
    KPS = 'KPS',
    NETBANKING = 'NETBANKING',
    PAYMENTCARD = 'PAYMENT_CARD',
    PAYMENTTOKEN = 'PAYMENT_TOKEN',
    PAYPAL = 'PAYPAL',
    SEPA = 'SEPA',
    SOFORT = 'SOFORT',
    WALLET = 'WALLET',
    WECHATDOMESTIC = 'WECHAT_DOMESTIC',
    TELECHECK = 'TELECHECK'
}

/**
 * 
 * @export
 * @interface PaymentRegistration
 */
export interface PaymentRegistration {
    /**
     * Merchant reference code. Used by FirstAPI and reflected in settlement records and webhook notifications. Typically, the merchantRef field is the purchase order number or unique sequence value associated to a given transaction.
     * @type {string}
     * @memberof PaymentRegistration
     */
    merchantRef?: string;
    /**
     * Type of transaction merchant wants to process.
     * @type {string}
     * @memberof PaymentRegistration
     */
    transactionType: string;
    /**
     * 
     * @type {Customer}
     * @memberof PaymentRegistration
     */
    customer: Customer;
    /**
     * 
     * @type {Merchant}
     * @memberof PaymentRegistration
     */
    merchant: Merchant;
    /**
     * 
     * @type {FraudRegistrationDevice}
     * @memberof PaymentRegistration
     */
    device?: FraudRegistrationDevice;
    /**
     * A JSON object that can carry any additional information that might be helpful for fraud detection.
     * @type {object}
     * @memberof PaymentRegistration
     */
    userDefined?: object;
    /**
     * Defines the type of the original transaction that is being evaluated for the Fraud Score.
     * @type {string}
     * @memberof PaymentRegistration
     */
    originalTransactionType: string;
    /**
     * 
     * @type {IssuerResponse}
     * @memberof PaymentRegistration
     */
    issuerResponse?: IssuerResponse;
    /**
     * 
     * @type {VerificationAvs}
     * @memberof PaymentRegistration
     */
    verificationAvs?: VerificationAvs;
    /**
     * 
     * @type {Verification3ds}
     * @memberof PaymentRegistration
     */
    verification3ds?: Verification3ds;
    /**
     * 
     * @type {VerificationCvv}
     * @memberof PaymentRegistration
     */
    verificationCvv?: VerificationCvv;
    /**
     * 
     * @type {RegistrationMethod}
     * @memberof PaymentRegistration
     */
    registrationMethod: RegistrationMethod;
}
/**
 * Payment schedules response with error field included.
 * @export
 * @interface PaymentSchedulesErrorResponse
 */
export interface PaymentSchedulesErrorResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof PaymentSchedulesErrorResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof PaymentSchedulesErrorResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof PaymentSchedulesErrorResponse
     */
    responseType?: ResponseType;
    /**
     * Result of requested operation. If it\'s anything other than \'SUCCESS\', please refer to 400s HTTP error codes or decline. See Error object for details.
     * @type {string}
     * @memberof PaymentSchedulesErrorResponse
     */
    requestStatus?: PaymentSchedulesErrorResponseRequestStatusEnum;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentSchedulesErrorResponse
     */
    orderId?: string;
    /**
     * 
     * @type {TransactionResponse}
     * @memberof PaymentSchedulesErrorResponse
     */
    transactionResponse?: TransactionResponse;
    /**
     * 
     * @type {Error}
     * @memberof PaymentSchedulesErrorResponse
     */
    error?: Error;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentSchedulesErrorResponseRequestStatusEnum {
    SUCCESS = 'SUCCESS',
    VALIDATIONFAILED = 'VALIDATION_FAILED',
    PROCESSINGFAILED = 'PROCESSING_FAILED',
    FAILURE = 'FAILURE',
    DECLINED = 'DECLINED'
}

/**
 * Request to create a gateway schedule. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface PaymentSchedulesRequest
 */
export interface PaymentSchedulesRequest {
    /**
     * Object name of the payment schedules request.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    requestType: string;
    /**
     * Store ID number.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    storeId?: string;
    /**
     * Date of mandate signature.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    startDate: string;
    /**
     * Number of times the recurring payment will process.
     * @type {number}
     * @memberof PaymentSchedulesRequest
     */
    numberOfPayments?: number;
    /**
     * Number of failures that can be encountered before re-tries cease.
     * @type {number}
     * @memberof PaymentSchedulesRequest
     */
    maximumFailures?: number;
    /**
     * Invoice number.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    invoiceNumber?: string;
    /**
     * Purchase order number.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    purchaseOrderNumber?: string;
    /**
     * 
     * @type {TransactionOrigin}
     * @memberof PaymentSchedulesRequest
     */
    transactionOrigin?: TransactionOrigin;
    /**
     * Dynamic merchant name for the cardholder\'s statement.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    dynamicMerchantName?: string;
    /**
     * 
     * @type {Frequency}
     * @memberof PaymentSchedulesRequest
     */
    frequency: Frequency;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentSchedulesRequest
     */
    transactionAmount: Amount;
    /**
     * 
     * @type {ClientLocale}
     * @memberof PaymentSchedulesRequest
     */
    clientLocale?: ClientLocale;
    /**
     * Client order ID if supplied by client.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    orderId?: string;
    /**
     * 
     * @type {Billing}
     * @memberof PaymentSchedulesRequest
     */
    billing?: Billing;
    /**
     * 
     * @type {Shipping}
     * @memberof PaymentSchedulesRequest
     */
    shipping?: Shipping;
    /**
     * User supplied comments.
     * @type {string}
     * @memberof PaymentSchedulesRequest
     */
    comments?: string;
}
/**
 * Response from the gateway scheduler creation call.
 * @export
 * @interface PaymentSchedulesResponse
 */
export interface PaymentSchedulesResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof PaymentSchedulesResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof PaymentSchedulesResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof PaymentSchedulesResponse
     */
    responseType?: ResponseType;
    /**
     * Result of requested operation. If it\'s anything other than \'SUCCESS\', please refer to 400s HTTP error codes or decline. See Error object for details.
     * @type {string}
     * @memberof PaymentSchedulesResponse
     */
    requestStatus?: PaymentSchedulesResponseRequestStatusEnum;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentSchedulesResponse
     */
    orderId?: string;
    /**
     * 
     * @type {TransactionResponse}
     * @memberof PaymentSchedulesResponse
     */
    transactionResponse?: TransactionResponse;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentSchedulesResponseRequestStatusEnum {
    SUCCESS = 'SUCCESS',
    VALIDATIONFAILED = 'VALIDATION_FAILED',
    PROCESSINGFAILED = 'PROCESSING_FAILED',
    FAILURE = 'FAILURE',
    DECLINED = 'DECLINED'
}

/**
 * Request to create credit transaction using payment token.
 * @export
 * @interface PaymentTokenCreditTransaction
 */
export interface PaymentTokenCreditTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenCreditTransaction
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentTokenCreditTransaction
     */
    currencyConversion?: CurrencyConversion;
}
/**
 * 
 * @export
 * @interface PaymentTokenCreditTransactionAllOf
 */
export interface PaymentTokenCreditTransactionAllOf {
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenCreditTransactionAllOf
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentTokenCreditTransactionAllOf
     */
    currencyConversion?: CurrencyConversion;
}
/**
 * Response details for payment token creation.
 * @export
 * @interface PaymentTokenDetails
 */
export interface PaymentTokenDetails {
    /**
     * Client-supplied payment token value. Only applicable for DataVault tokenization scheme.
     * @type {string}
     * @memberof PaymentTokenDetails
     */
    value?: string;
    /**
     * If the token is reusable.
     * @type {boolean}
     * @memberof PaymentTokenDetails
     */
    reusable?: boolean;
    /**
     * Decline duplicate payment info if client token is supplied.
     * @type {boolean}
     * @memberof PaymentTokenDetails
     */
    declineDuplicates?: boolean;
    /**
     * The last 4 numbers of a payment card.
     * @type {string}
     * @memberof PaymentTokenDetails
     */
    last4?: string;
    /**
     * Card brand, only for tokenization with payment.
     * @type {string}
     * @memberof PaymentTokenDetails
     */
    brand?: string;
    /**
     * If the account the token was created from has been verified.
     * @type {boolean}
     * @memberof PaymentTokenDetails
     */
    accountVerification?: boolean;
    /**
     * Inidcates the type of tokenization source.
     * @type {string}
     * @memberof PaymentTokenDetails
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface PaymentTokenDetailsAllOf
 */
export interface PaymentTokenDetailsAllOf {
    /**
     * The last 4 numbers of a payment card.
     * @type {string}
     * @memberof PaymentTokenDetailsAllOf
     */
    last4?: string;
    /**
     * Card brand, only for tokenization with payment.
     * @type {string}
     * @memberof PaymentTokenDetailsAllOf
     */
    brand?: string;
    /**
     * If the account the token was created from has been verified.
     * @type {boolean}
     * @memberof PaymentTokenDetailsAllOf
     */
    accountVerification?: boolean;
    /**
     * Inidcates the type of tokenization source.
     * @type {string}
     * @memberof PaymentTokenDetailsAllOf
     */
    type?: string;
}
/**
 * Request to create disbursement transaction using a payment token.
 * @export
 * @interface PaymentTokenDisbursementTransaction
 */
export interface PaymentTokenDisbursementTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {Disbursement}
     * @memberof PaymentTokenDisbursementTransaction
     */
    disbursement: Disbursement;
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenDisbursementTransaction
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentTokenDisbursementTransaction
     */
    storedCredentials?: StoredCredential;
}
/**
 * 
 * @export
 * @interface PaymentTokenDisbursementTransactionAllOf
 */
export interface PaymentTokenDisbursementTransactionAllOf {
    /**
     * 
     * @type {Disbursement}
     * @memberof PaymentTokenDisbursementTransactionAllOf
     */
    disbursement: Disbursement;
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenDisbursementTransactionAllOf
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentTokenDisbursementTransactionAllOf
     */
    storedCredentials?: StoredCredential;
}
/**
 * Used to request card information associated with a payment token.
 * @export
 * @interface PaymentTokenInfoLookupRequest
 */
export interface PaymentTokenInfoLookupRequest extends AccountInfoLookupRequest {
    /**
     * 
     * @type {UsePaymentToken}
     * @memberof PaymentTokenInfoLookupRequest
     */
    paymentToken: UsePaymentToken;
}
/**
 * 
 * @export
 * @interface PaymentTokenInfoLookupRequestAllOf
 */
export interface PaymentTokenInfoLookupRequestAllOf {
    /**
     * 
     * @type {UsePaymentToken}
     * @memberof PaymentTokenInfoLookupRequestAllOf
     */
    paymentToken: UsePaymentToken;
}
/**
 * Payment method containing payment tokenization information.
 * @export
 * @interface PaymentTokenPaymentMethod
 */
export interface PaymentTokenPaymentMethod {
    /**
     * 
     * @type {UsePaymentToken}
     * @memberof PaymentTokenPaymentMethod
     */
    paymentToken: UsePaymentToken;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof PaymentTokenPaymentMethod
     */
    paymentFacilitator?: PaymentFacilitator;
}
/**
 * 
 * @export
 * @interface PaymentTokenPaymentMethodAllOf
 */
export interface PaymentTokenPaymentMethodAllOf {
    /**
     * 
     * @type {UsePaymentToken}
     * @memberof PaymentTokenPaymentMethodAllOf
     */
    paymentToken: UsePaymentToken;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof PaymentTokenPaymentMethodAllOf
     */
    paymentFacilitator?: PaymentFacilitator;
}
/**
 * Request to create pre-auth transaction using payment token.
 * @export
 * @interface PaymentTokenPreAuthTransaction
 */
export interface PaymentTokenPreAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenPreAuthTransaction
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentTokenPreAuthTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PaymentTokenPreAuthTransaction
     */
    splitShipment?: SplitShipment;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentTokenPreAuthTransaction
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentTokenPreAuthTransaction
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentTokenPreAuthTransaction
     */
    authenticationResult?: AuthenticationResult;
    /**
     * This flag can only be used in a preAuth transaction that updates the amount of a previous preAuth transaction to either increase the preAuth amount (DecrementalPreAuthFlag = false) or decrease the preAuth amount (DecrementalPreAuthFlag = true).
     * @type {boolean}
     * @memberof PaymentTokenPreAuthTransaction
     */
    decrementalFlag?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentTokenPreAuthTransactionAllOf
 */
export interface PaymentTokenPreAuthTransactionAllOf {
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenPreAuthTransactionAllOf
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentTokenPreAuthTransactionAllOf
     */
    storedCredentials?: StoredCredential;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PaymentTokenPreAuthTransactionAllOf
     */
    splitShipment?: SplitShipment;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentTokenPreAuthTransactionAllOf
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentTokenPreAuthTransactionAllOf
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentTokenPreAuthTransactionAllOf
     */
    authenticationResult?: AuthenticationResult;
    /**
     * This flag can only be used in a preAuth transaction that updates the amount of a previous preAuth transaction to either increase the preAuth amount (DecrementalPreAuthFlag = false) or decrease the preAuth amount (DecrementalPreAuthFlag = true).
     * @type {boolean}
     * @memberof PaymentTokenPreAuthTransactionAllOf
     */
    decrementalFlag?: boolean;
}
/**
 * Request to create sale transaction using payment token.
 * @export
 * @interface PaymentTokenSaleTransaction
 */
export interface PaymentTokenSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenSaleTransaction
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentTokenSaleTransaction
     */
    storedCredentials?: StoredCredential;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentTokenSaleTransaction
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentTokenSaleTransaction
     */
    currencyConversion?: CurrencyConversion;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentTokenSaleTransaction
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentTokenSaleTransaction
     */
    authenticationResult?: AuthenticationResult;
}
/**
 * 
 * @export
 * @interface PaymentTokenSaleTransactionAllOf
 */
export interface PaymentTokenSaleTransactionAllOf {
    /**
     * 
     * @type {PaymentTokenPaymentMethod}
     * @memberof PaymentTokenSaleTransactionAllOf
     */
    paymentMethod: PaymentTokenPaymentMethod;
    /**
     * 
     * @type {StoredCredential}
     * @memberof PaymentTokenSaleTransactionAllOf
     */
    storedCredentials?: StoredCredential;
    /**
     * Settle with multiple sub-merchants, sale and preAuth only.
     * @type {Array<SubMerchantSplit>}
     * @memberof PaymentTokenSaleTransactionAllOf
     */
    settlementSplit?: Array<SubMerchantSplit>;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof PaymentTokenSaleTransactionAllOf
     */
    currencyConversion?: CurrencyConversion;
    /**
     * 
     * @type {AuthenticationRequest}
     * @memberof PaymentTokenSaleTransactionAllOf
     */
    authenticationRequest?: AuthenticationRequest;
    /**
     * 
     * @type {AuthenticationResult}
     * @memberof PaymentTokenSaleTransactionAllOf
     */
    authenticationResult?: AuthenticationResult;
}
/**
 * 
 * @export
 * @interface PaymentTokenUpdateResponse
 */
export interface PaymentTokenUpdateResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof PaymentTokenUpdateResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof PaymentTokenUpdateResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof PaymentTokenUpdateResponse
     */
    responseType?: ResponseType;
    /**
     * The status of the request.
     * @type {string}
     * @memberof PaymentTokenUpdateResponse
     */
    requestStatus?: PaymentTokenUpdateResponseRequestStatusEnum;
    /**
     * Time of the request.
     * @type {number}
     * @memberof PaymentTokenUpdateResponse
     */
    requestTime?: number;
    /**
     * 
     * @type {Array<Error>}
     * @memberof PaymentTokenUpdateResponse
     */
    errors?: Array<Error>;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentTokenUpdateResponseRequestStatusEnum {
    FAILED = 'FAILED',
    SUCCESS = 'SUCCESS',
    PARTIALSUCCESS = 'PARTIAL_SUCCESS'
}

/**
 * Used to request account verification using a payment token.
 * @export
 * @interface PaymentTokenVerificationRequest
 */
export interface PaymentTokenVerificationRequest extends AccountVerificationRequest {
    /**
     * 
     * @type {UsePaymentToken}
     * @memberof PaymentTokenVerificationRequest
     */
    paymentToken: UsePaymentToken;
}
/**
 * 
 * @export
 * @interface PaymentTokenVerificationRequestAllOf
 */
export interface PaymentTokenVerificationRequestAllOf {
    /**
     * 
     * @type {UsePaymentToken}
     * @memberof PaymentTokenVerificationRequestAllOf
     */
    paymentToken: UsePaymentToken;
}
/**
 * Payment tokenization response with error field included.
 * @export
 * @interface PaymentTokenizationErrorResponse
 */
export interface PaymentTokenizationErrorResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof PaymentTokenizationErrorResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof PaymentTokenizationErrorResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof PaymentTokenizationErrorResponse
     */
    responseType?: ResponseType;
    /**
     * The status of the request.
     * @type {string}
     * @memberof PaymentTokenizationErrorResponse
     */
    requestStatus?: PaymentTokenizationErrorResponseRequestStatusEnum;
    /**
     * Time of the request.
     * @type {number}
     * @memberof PaymentTokenizationErrorResponse
     */
    requestTime?: number;
    /**
     * Card brand.
     * @type {string}
     * @memberof PaymentTokenizationErrorResponse
     */
    brand?: string;
    /**
     * Country of the card issued.
     * @type {string}
     * @memberof PaymentTokenizationErrorResponse
     */
    country?: string;
    /**
     * 
     * @type {PaymentTokenDetails}
     * @memberof PaymentTokenizationErrorResponse
     */
    paymentToken?: PaymentTokenDetails;
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentTokenizationErrorResponse
     */
    paymentCard?: PaymentCard;
    /**
     * 
     * @type {ProcessorData}
     * @memberof PaymentTokenizationErrorResponse
     */
    processor?: ProcessorData;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentTokenizationErrorResponse
     */
    orderId?: string;
    /**
     * The response transaction ID.
     * @type {string}
     * @memberof PaymentTokenizationErrorResponse
     */
    ipgTransactionId?: string;
    /**
     * The unique merchant transaction ID from the request header, if supplied.
     * @type {string}
     * @memberof PaymentTokenizationErrorResponse
     */
    merchantTransactionId?: string;
    /**
     * 
     * @type {Error}
     * @memberof PaymentTokenizationErrorResponse
     */
    error?: Error;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentTokenizationErrorResponseRequestStatusEnum {
    DELETED = 'DELETED',
    FAILED = 'FAILED',
    SUCCESS = 'SUCCESS',
    APPROVED = 'APPROVED',
    WAITING = 'WAITING',
    VALIDATIONFAILED = 'VALIDATION_FAILED',
    DECLINED = 'DECLINED'
}

/**
 * Used to generate payment tokens. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface PaymentTokenizationRequest
 */
export interface PaymentTokenizationRequest {
    /**
     * Object name of tokenization request.
     * @type {string}
     * @memberof PaymentTokenizationRequest
     */
    requestType: string;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof PaymentTokenizationRequest
     */
    storeId?: string;
    /**
     * 
     * @type {Address}
     * @memberof PaymentTokenizationRequest
     */
    billingAddress?: Address;
    /**
     * 
     * @type {CreatePaymentToken}
     * @memberof PaymentTokenizationRequest
     */
    createToken: CreatePaymentToken;
    /**
     * If the account should be verified prior to token creation.
     * @type {boolean}
     * @memberof PaymentTokenizationRequest
     */
    accountVerification?: boolean;
    /**
     * The unique merchant transaction ID from the request, if supplied.
     * @type {string}
     * @memberof PaymentTokenizationRequest
     */
    merchantTransactionId?: string;
    /**
     * 
     * @type {AdditionalDetails}
     * @memberof PaymentTokenizationRequest
     */
    additionalDetails?: AdditionalDetails;
}
/**
 * 
 * @export
 * @interface PaymentTokenizationResponse
 */
export interface PaymentTokenizationResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof PaymentTokenizationResponse
     */
    responseType?: ResponseType;
    /**
     * The status of the request.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    requestStatus?: PaymentTokenizationResponseRequestStatusEnum;
    /**
     * Time of the request.
     * @type {number}
     * @memberof PaymentTokenizationResponse
     */
    requestTime?: number;
    /**
     * Card brand.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    brand?: string;
    /**
     * Country of the card issued.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    country?: string;
    /**
     * 
     * @type {PaymentTokenDetails}
     * @memberof PaymentTokenizationResponse
     */
    paymentToken?: PaymentTokenDetails;
    /**
     * 
     * @type {PaymentCard}
     * @memberof PaymentTokenizationResponse
     */
    paymentCard?: PaymentCard;
    /**
     * 
     * @type {ProcessorData}
     * @memberof PaymentTokenizationResponse
     */
    processor?: ProcessorData;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    orderId?: string;
    /**
     * The response transaction ID.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    ipgTransactionId?: string;
    /**
     * The unique merchant transaction ID from the request header, if supplied.
     * @type {string}
     * @memberof PaymentTokenizationResponse
     */
    merchantTransactionId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentTokenizationResponseRequestStatusEnum {
    DELETED = 'DELETED',
    FAILED = 'FAILED',
    SUCCESS = 'SUCCESS',
    APPROVED = 'APPROVED',
    WAITING = 'WAITING',
    VALIDATIONFAILED = 'VALIDATION_FAILED',
    DECLINED = 'DECLINED'
}

/**
 * Detailed information about a payment URL.
 * @export
 * @interface PaymentUrlDetail
 */
export interface PaymentUrlDetail {
    /**
     * URL for embedded payment link.
     * @type {string}
     * @memberof PaymentUrlDetail
     */
    paymentUrl?: string;
    /**
     * The unique merchant transaction ID from the request, if supplied.
     * @type {string}
     * @memberof PaymentUrlDetail
     */
    merchantTransactionId?: string;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentUrlDetail
     */
    orderId?: string;
    /**
     * The transaction time in seconds since epoch.
     * @type {number}
     * @memberof PaymentUrlDetail
     */
    requestTime?: number;
    /**
     * 
     * @type {PaymentUrlStatus}
     * @memberof PaymentUrlDetail
     */
    status?: PaymentUrlStatus;
}
/**
 * Response from an embedded payment link request.
 * @export
 * @interface PaymentUrlDetailResponse
 */
export interface PaymentUrlDetailResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof PaymentUrlDetailResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof PaymentUrlDetailResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof PaymentUrlDetailResponse
     */
    responseType?: ResponseType;
    /**
     * Array of payment URL details.
     * @type {Array<PaymentUrlDetail>}
     * @memberof PaymentUrlDetailResponse
     */
    paymentUrlDetails?: Array<PaymentUrlDetail>;
}
/**
 * Payment URL response with error field included.
 * @export
 * @interface PaymentUrlErrorResponse
 */
export interface PaymentUrlErrorResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof PaymentUrlErrorResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof PaymentUrlErrorResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof PaymentUrlErrorResponse
     */
    responseType?: ResponseType;
    /**
     * Request status. If it is anything other than \'SUCCESS\', please refer to 400s HTTP error codes or decline. See Error object for details.
     * @type {string}
     * @memberof PaymentUrlErrorResponse
     */
    requestStatus?: PaymentUrlErrorResponseRequestStatusEnum;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentUrlErrorResponse
     */
    orderId?: string;
    /**
     * URL for embedded payment link.
     * @type {string}
     * @memberof PaymentUrlErrorResponse
     */
    paymentUrl?: string;
    /**
     * ID code from the transaction.
     * @type {string}
     * @memberof PaymentUrlErrorResponse
     */
    transactionId?: string;
    /**
     * 
     * @type {Error}
     * @memberof PaymentUrlErrorResponse
     */
    error?: Error;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentUrlErrorResponseRequestStatusEnum {
    SUCCESS = 'SUCCESS',
    VALIDATIONFAILED = 'VALIDATION_FAILED',
    PROCESSINGFAILED = 'PROCESSING_FAILED',
    FAILURE = 'FAILURE'
}

/**
 * Request to generate an embedded payment link.
 * @export
 * @interface PaymentUrlRequest
 */
export interface PaymentUrlRequest {
    /**
     * An optional Outlet ID for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    storeId?: string;
    /**
     * 
     * @type {ClientLocale}
     * @memberof PaymentUrlRequest
     */
    clientLocale?: ClientLocale;
    /**
     * 
     * @type {Amount}
     * @memberof PaymentUrlRequest
     */
    transactionAmount: Amount;
    /**
     * 
     * @type {TransactionType}
     * @memberof PaymentUrlRequest
     */
    transactionType: TransactionType;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    orderId?: string;
    /**
     * 
     * @type {Billing}
     * @memberof PaymentUrlRequest
     */
    billing?: Billing;
    /**
     * 
     * @type {Shipping}
     * @memberof PaymentUrlRequest
     */
    shipping?: Shipping;
    /**
     * URL for notifying merchant of payment result.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    transactionNotificationURL?: string;
    /**
     * Time until payment URL expires.
     * @type {number}
     * @memberof PaymentUrlRequest
     */
    expiration?: number;
    /**
     * If 3D secure should be applied.
     * @type {boolean}
     * @memberof PaymentUrlRequest
     */
    authenticateTransaction?: boolean;
    /**
     * Dynamic merchant name for the cardholder\'s statement.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    dynamicMerchantName?: string;
    /**
     * Invoice number.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    invoiceNumber?: string;
    /**
     * Purchase order number.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    purchaseOrderNumber?: string;
    /**
     * The text to be displayed to the payer on the hosted payment page.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    hostedPaymentPageText?: string;
    /**
     * IPv4 or IPv6 network address.
     * @type {string}
     * @memberof PaymentUrlRequest
     */
    ip?: string;
}
/**
 * Response from an embedded payment link request.
 * @export
 * @interface PaymentUrlResponse
 */
export interface PaymentUrlResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof PaymentUrlResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof PaymentUrlResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof PaymentUrlResponse
     */
    responseType?: ResponseType;
    /**
     * Request status. If it is anything other than \'SUCCESS\', please refer to 400s HTTP error codes or decline. See Error object for details.
     * @type {string}
     * @memberof PaymentUrlResponse
     */
    requestStatus?: PaymentUrlResponseRequestStatusEnum;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof PaymentUrlResponse
     */
    orderId?: string;
    /**
     * URL for embedded payment link.
     * @type {string}
     * @memberof PaymentUrlResponse
     */
    paymentUrl?: string;
    /**
     * ID code from the transaction.
     * @type {string}
     * @memberof PaymentUrlResponse
     */
    transactionId?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentUrlResponseRequestStatusEnum {
    SUCCESS = 'SUCCESS',
    VALIDATIONFAILED = 'VALIDATION_FAILED',
    PROCESSINGFAILED = 'PROCESSING_FAILED',
    FAILURE = 'FAILURE'
}

/**
 * The status of payment URL.
 * @export
 * @enum {string}
 */
export enum PaymentUrlStatus {
    Created = 'Created',
    Used = 'Used',
    Expired = 'Expired',
    Cancelled = 'Cancelled'
}

/**
 * Request to create credit transaction using PayPal.
 * @export
 * @interface PaypalCreditTransaction
 */
export interface PaypalCreditTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {PayPalPaymentMethod}
     * @memberof PaypalCreditTransaction
     */
    paymentMethod: PayPalPaymentMethod;
}
/**
 * 
 * @export
 * @interface PaypalCreditTransactionAllOf
 */
export interface PaypalCreditTransactionAllOf {
    /**
     * 
     * @type {PayPalPaymentMethod}
     * @memberof PaypalCreditTransactionAllOf
     */
    paymentMethod: PayPalPaymentMethod;
}
/**
 * Phone number.
 * @export
 * @interface Phone
 */
export interface Phone {
    /**
     * Type of phone.
     * @type {string}
     * @memberof Phone
     */
    type?: string;
    /**
     * Free form phone number.
     * @type {string}
     * @memberof Phone
     */
    number?: string;
}
/**
 * Request to perform post auth transaction.
 * @export
 * @interface PostAuthTransaction
 */
export interface PostAuthTransaction extends SecondaryTransaction {
    /**
     * 
     * @type {Amount}
     * @memberof PostAuthTransaction
     */
    transactionAmount: Amount;
    /**
     * 
     * @type {TransactionOrigin}
     * @memberof PostAuthTransaction
     */
    transactionOrigin?: TransactionOrigin;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PostAuthTransaction
     */
    splitShipment?: SplitShipment;
    /**
     * 
     * @type {SoftDescriptor}
     * @memberof PostAuthTransaction
     */
    softDescriptor?: SoftDescriptor;
}
/**
 * 
 * @export
 * @interface PostAuthTransactionAllOf
 */
export interface PostAuthTransactionAllOf {
    /**
     * 
     * @type {Amount}
     * @memberof PostAuthTransactionAllOf
     */
    transactionAmount: Amount;
    /**
     * 
     * @type {TransactionOrigin}
     * @memberof PostAuthTransactionAllOf
     */
    transactionOrigin?: TransactionOrigin;
    /**
     * 
     * @type {SplitShipment}
     * @memberof PostAuthTransactionAllOf
     */
    splitShipment?: SplitShipment;
    /**
     * 
     * @type {SoftDescriptor}
     * @memberof PostAuthTransactionAllOf
     */
    softDescriptor?: SoftDescriptor;
}
/**
 * 
 * @export
 * @interface Primary
 */
export interface Primary {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Primary
     */
    color?: string;
}
/**
 * Provides shared fields for all PrimaryTransaction request types. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface PrimaryTransaction
 */
export interface PrimaryTransaction {
    /**
     * Object name of the primary transaction request.
     * @type {string}
     * @memberof PrimaryTransaction
     */
    requestType: string;
    /**
     * 
     * @type {Amount}
     * @memberof PrimaryTransaction
     */
    transactionAmount: Amount;
    /**
     * An optional outlet ID for clients that support multiple stores in the same app.
     * @type {string}
     * @memberof PrimaryTransaction
     */
    storeId?: string;
    /**
     * The unique merchant transaction ID from the request header, if supplied.
     * @type {string}
     * @memberof PrimaryTransaction
     */
    merchantTransactionId?: string;
    /**
     * 
     * @type {TransactionOrigin}
     * @memberof PrimaryTransaction
     */
    transactionOrigin?: TransactionOrigin;
    /**
     * 
     * @type {Order}
     * @memberof PrimaryTransaction
     */
    order?: Order;
}
/**
 * Model for processor data.
 * @export
 * @interface ProcessorData
 */
export interface ProcessorData {
    /**
     * Reference transaction ID.
     * @type {string}
     * @memberof ProcessorData
     */
    referenceNumber?: string;
    /**
     * Code returned to confirm transaction.
     * @type {string}
     * @memberof ProcessorData
     */
    authorizationCode?: string;
    /**
     * Response code from endpoints.
     * @type {string}
     * @memberof ProcessorData
     */
    responseCode?: string;
    /**
     * Network used for transaction.
     * @type {string}
     * @memberof ProcessorData
     */
    network?: string;
    /**
     * Raw response code from issuer.
     * @type {string}
     * @memberof ProcessorData
     */
    associationResponseCode?: string;
    /**
     * Message returned from endpoints.
     * @type {string}
     * @memberof ProcessorData
     */
    responseMessage?: string;
    /**
     * 
     * @type {AVSResponse}
     * @memberof ProcessorData
     */
    avsResponse?: AVSResponse;
    /**
     * Code returned for CVV.
     * @type {string}
     * @memberof ProcessorData
     */
    securityCodeResponse?: ProcessorDataSecurityCodeResponseEnum;
    /**
     * Code to map merchant advice code to ISO specification.
     * @type {string}
     * @memberof ProcessorData
     */
    merchantAdviceCodeIndicator?: string;
    /**
     * Indicates whether the transaction was routed through the payment card\'s own network or through a different network.
     * @type {string}
     * @memberof ProcessorData
     */
    responseIndicator?: string;
    /**
     * Receipt number from debit network provider.
     * @type {string}
     * @memberof ProcessorData
     */
    debitReceiptNumber?: string;
    /**
     * MasterCard provided Transaction Integrity Class for Point of Sale (POS) Purchase and Purchase with Cash Back transactions initiated on the Authorization Platform.
     * @type {string}
     * @memberof ProcessorData
     */
    transactionIntegrityClass?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ProcessorDataSecurityCodeResponseEnum {
    MATCHED = 'MATCHED',
    NOTMATCHED = 'NOT_MATCHED',
    NOTPROCESSED = 'NOT_PROCESSED',
    NOTPRESENT = 'NOT_PRESENT',
    NOTCERTIFIED = 'NOT_CERTIFIED',
    NOTCHECKED = 'NOT_CHECKED'
}

/**
 * Object contains font and color properties.
 * @export
 * @interface Properties
 */
export interface Properties {
    /**
     * 
     * @type {FontFace}
     * @memberof Properties
     */
    fontFace?: FontFace;
    /**
     * Font size property.
     * @type {string}
     * @memberof Properties
     */
    fontSize?: string;
    /**
     * 
     * @type {FontWeight}
     * @memberof Properties
     */
    fontWeight?: FontWeight;
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Properties
     */
    fontColor?: string;
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Properties
     */
    color?: string;
}
/**
 * Purchase card details.
 * @export
 * @interface PurchaseCards
 */
export interface PurchaseCards {
    /**
     * 
     * @type {PurchaseCardsLevel2}
     * @memberof PurchaseCards
     */
    level2?: PurchaseCardsLevel2;
    /**
     * 
     * @type {PurchaseCardsLevel3}
     * @memberof PurchaseCards
     */
    level3?: PurchaseCardsLevel3;
}
/**
 * Level 2 data for monitoring and controlling corporate expenditures.
 * @export
 * @interface PurchaseCardsLevel2
 */
export interface PurchaseCardsLevel2 {
    /**
     * Customer code/customer reference ID.
     * @type {string}
     * @memberof PurchaseCardsLevel2
     */
    customerReferenceID?: string;
    /**
     * Purchase identifier/merchant-related data.
     * @type {string}
     * @memberof PurchaseCardsLevel2
     */
    supplierInvoiceNumber?: string;
    /**
     * Merchant VAT registration/single business reference number/merchant tax ID or corporation VAT number.
     * @type {string}
     * @memberof PurchaseCardsLevel2
     */
    supplierVATRegistrationNumber?: string;
    /**
     * 
     * @type {AdditionalAmountRate}
     * @memberof PurchaseCardsLevel2
     */
    totalDiscountAmountAndRate?: AdditionalAmountRate;
    /**
     * 
     * @type {AdditionalAmountRate}
     * @memberof PurchaseCardsLevel2
     */
    vatShippingAmountAndRate?: AdditionalAmountRate;
}
/**
 * Level 3 data for monitoring and controlling corporate expenditures.
 * @export
 * @interface PurchaseCardsLevel3
 */
export interface PurchaseCardsLevel3 {
    /**
     * Line items of monitoring and controlling corporate expenditures data.
     * @type {Array<PurchaseCardsLevel3LineItems>}
     * @memberof PurchaseCardsLevel3
     */
    lineItems: Array<PurchaseCardsLevel3LineItems>;
}
/**
 * 
 * @export
 * @interface PurchaseCardsLevel3LineItems
 */
export interface PurchaseCardsLevel3LineItems {
    /**
     * The commodity code used to classify the item purchased.
     * @type {string}
     * @memberof PurchaseCardsLevel3LineItems
     */
    commodityCode?: string;
    /**
     * Merchant product identifier/the Universal Product Code (UPC) of the item purchased.
     * @type {string}
     * @memberof PurchaseCardsLevel3LineItems
     */
    productCode?: string;
    /**
     * The description.
     * @type {string}
     * @memberof PurchaseCardsLevel3LineItems
     */
    description?: string;
    /**
     * The quantity.
     * @type {number}
     * @memberof PurchaseCardsLevel3LineItems
     */
    quantity?: number;
    /**
     * The unit of measure.
     * @type {string}
     * @memberof PurchaseCardsLevel3LineItems
     */
    unitMeasure?: string;
    /**
     * Rate amount in 3 decimal 12 bytes total digit.
     * @type {number}
     * @memberof PurchaseCardsLevel3LineItems
     */
    unitPrice?: number;
    /**
     * 
     * @type {AdditionalAmountRate}
     * @memberof PurchaseCardsLevel3LineItems
     */
    vatAmountAndRate?: AdditionalAmountRate;
    /**
     * 
     * @type {AdditionalAmountRate}
     * @memberof PurchaseCardsLevel3LineItems
     */
    discountAmountAndRate?: AdditionalAmountRate;
    /**
     * Rate amount in 3 decimal 12 bytes total digit.
     * @type {number}
     * @memberof PurchaseCardsLevel3LineItems
     */
    lineItemTotal?: number;
}
/**
 * Provides POS receipt data.
 * @export
 * @interface Receipt
 */
export interface Receipt {
    /**
     * Defines the consumer of the receipt (e.g. cardholder, merchant).
     * @type {string}
     * @memberof Receipt
     */
    type: ReceiptTypeEnum;
    /**
     * Array of formatted lines that represents the actual receipt data, that can be printed out.
     * @type {Array<string>}
     * @memberof Receipt
     */
    data: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum ReceiptTypeEnum {
    Cardholder = 'cardholder',
    Merchant = 'merchant'
}

/**
 * Defines receipt related parameters that are necessary to generate a receipt.
 * @export
 * @interface ReceiptRequestInfo
 */
export interface ReceiptRequestInfo {
    /**
     * Defines the consumer of the receipt (e.g. cardholder, merchant).
     * @type {string}
     * @memberof ReceiptRequestInfo
     */
    type: ReceiptRequestInfoTypeEnum;
    /**
     * The locale of the receipt. The format has to be a well-formed BCP 47 language tag.
     * @type {string}
     * @memberof ReceiptRequestInfo
     */
    locale?: string;
    /**
     * The line width of the receipt. Default will be 32 characters.
     * @type {number}
     * @memberof ReceiptRequestInfo
     */
    linewidth?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ReceiptRequestInfoTypeEnum {
    Cardholder = 'cardholder',
    Merchant = 'merchant'
}

/**
 * Receiver information for a funding transaction.
 * @export
 * @interface ReceiverInfo
 */
export interface ReceiverInfo {
    /**
     * Receiver name.
     * @type {string}
     * @memberof ReceiverInfo
     */
    name: string;
    /**
     * Receiver street address.
     * @type {string}
     * @memberof ReceiverInfo
     */
    streetAddress: string;
    /**
     * Receiver city.
     * @type {string}
     * @memberof ReceiverInfo
     */
    city: string;
    /**
     * Receiver state.
     * @type {string}
     * @memberof ReceiverInfo
     */
    stateCode: string;
    /**
     * Receiver country code.
     * @type {string}
     * @memberof ReceiverInfo
     */
    countryCode: string;
    /**
     * Receiver postal code.
     * @type {string}
     * @memberof ReceiverInfo
     */
    postalCode: string;
    /**
     * Receiver phone number.
     * @type {string}
     * @memberof ReceiverInfo
     */
    phoneNumber: string;
    /**
     * Receiver reference number.
     * @type {string}
     * @memberof ReceiverInfo
     */
    referenceNumber: string;
    /**
     * Receiver account number.
     * @type {string}
     * @memberof ReceiverInfo
     */
    accountNumber?: string;
}
/**
 * Details about existing gateway schedule.
 * @export
 * @interface RecurringPaymentDetails
 */
export interface RecurringPaymentDetails {
    /**
     * Store ID number.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    storeId?: string;
    /**
     * Purchase order number.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    purchaseOrderNumber?: string;
    /**
     * Invoice number.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    invoiceNumber?: string;
    /**
     * Date recurring payment was created.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    creationDate?: string;
    /**
     * Date of mandate signature.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    startDate?: string;
    /**
     * Date of next transaction process attempt.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    nextAttemptDate?: string;
    /**
     * 
     * @type {Amount}
     * @memberof RecurringPaymentDetails
     */
    transactionAmount?: Amount;
    /**
     * 
     * @type {PaymentMethodDetails}
     * @memberof RecurringPaymentDetails
     */
    paymentMethodDetails?: PaymentMethodDetails;
    /**
     * 
     * @type {Frequency}
     * @memberof RecurringPaymentDetails
     */
    frequency?: Frequency;
    /**
     * Number of times the recurring payment will process.
     * @type {number}
     * @memberof RecurringPaymentDetails
     */
    numberOfPayments?: number;
    /**
     * Times the recurring payment has already run.
     * @type {number}
     * @memberof RecurringPaymentDetails
     */
    runCount?: number;
    /**
     * State of the recurring payment.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    state?: RecurringPaymentDetailsStateEnum;
    /**
     * User supplied comments.
     * @type {string}
     * @memberof RecurringPaymentDetails
     */
    comments?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RecurringPaymentDetailsStateEnum {
    Installed = 'Installed',
    Inactivated = 'Inactivated',
    Cancelled = 'Cancelled'
}

/**
 * Order response containing recurring payment details.
 * @export
 * @interface RecurringPaymentDetailsResponse
 */
export interface RecurringPaymentDetailsResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof RecurringPaymentDetailsResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof RecurringPaymentDetailsResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof RecurringPaymentDetailsResponse
     */
    responseType?: ResponseType;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof RecurringPaymentDetailsResponse
     */
    orderId?: string;
    /**
     * 
     * @type {Billing}
     * @memberof RecurringPaymentDetailsResponse
     */
    billing?: Billing;
    /**
     * 
     * @type {Shipping}
     * @memberof RecurringPaymentDetailsResponse
     */
    shipping?: Shipping;
    /**
     * Required for some payment methods (for example, Klarna).
     * @type {Array<TransactionResponse>}
     * @memberof RecurringPaymentDetailsResponse
     */
    transactions?: Array<TransactionResponse>;
    /**
     * 
     * @type {AdditionalDetails}
     * @memberof RecurringPaymentDetailsResponse
     */
    additionalDetails?: AdditionalDetails;
    /**
     * 
     * @type {RecurringPaymentDetails}
     * @memberof RecurringPaymentDetailsResponse
     */
    recurringPaymentDetails?: RecurringPaymentDetails;
}
/**
 * Request to create a new payment schedule using a referenced order ID.
 * @export
 * @interface ReferencedOrderPaymentSchedulesRequest
 */
export interface ReferencedOrderPaymentSchedulesRequest extends PaymentSchedulesRequest {
    /**
     * Order ID used to create recurring payment from existing transaction.
     * @type {string}
     * @memberof ReferencedOrderPaymentSchedulesRequest
     */
    referencedOrderId: string;
}
/**
 * 
 * @export
 * @interface ReferencedOrderPaymentSchedulesRequestAllOf
 */
export interface ReferencedOrderPaymentSchedulesRequestAllOf {
    /**
     * Order ID used to create recurring payment from existing transaction.
     * @type {string}
     * @memberof ReferencedOrderPaymentSchedulesRequestAllOf
     */
    referencedOrderId: string;
}
/**
 * Used to generate payment tokens with an existing order ID.
 * @export
 * @interface ReferencedOrderPaymentTokenizationRequest
 */
export interface ReferencedOrderPaymentTokenizationRequest extends PaymentTokenizationRequest {
    /**
     * Retrieves the payment instrument information from an existing order.
     * @type {string}
     * @memberof ReferencedOrderPaymentTokenizationRequest
     */
    referencedOrderId: string;
}
/**
 * 
 * @export
 * @interface ReferencedOrderPaymentTokenizationRequestAllOf
 */
export interface ReferencedOrderPaymentTokenizationRequestAllOf {
    /**
     * Retrieves the payment instrument information from an existing order.
     * @type {string}
     * @memberof ReferencedOrderPaymentTokenizationRequestAllOf
     */
    referencedOrderId: string;
}
/**
 * A JSON object that holds info about the payment registration method.
 * @export
 * @interface RegistrationMethod
 */
export interface RegistrationMethod {
    /**
     * Unique ID for the payment method type.
     * @type {string}
     * @memberof RegistrationMethod
     */
    methodType: RegistrationMethodMethodTypeEnum;
    /**
     * The unique ID of this payment method if it was previously registered with a registration/method or if it is currently being registered. Must be unique for the entire system (not just within a specific merchant or industry). Mandatory if being used inside a registration/method.
     * @type {string}
     * @memberof RegistrationMethod
     */
    methodId?: string;
    /**
     * A JSON object that carries any additional information that might be helpful for fraud detection.
     * @type {object}
     * @memberof RegistrationMethod
     */
    userDefined?: object;
    /**
     * The address that should be used to send billing information for this payment method.
     * @type {string}
     * @memberof RegistrationMethod
     */
    billingPhoneNumber?: string;
    /**
     * The address that should be used to send billing information for this payment method.
     * @type {string}
     * @memberof RegistrationMethod
     */
    methodAlias?: string;
    /**
     * 
     * @type {FraudRegistrationCard}
     * @memberof RegistrationMethod
     */
    card: FraudRegistrationCard;
    /**
     * 
     * @type {FraudAddress}
     * @memberof RegistrationMethod
     */
    methodAddress?: FraudAddress;
}

/**
    * @export
    * @enum {string}
    */
export enum RegistrationMethodMethodTypeEnum {
    Card = 'method/card',
    Wallet = 'method/wallet'
}

/**
 * Response from remove fraud blocked items request.
 * @export
 * @interface RemoveFraudBlockedItemsResponse
 */
export interface RemoveFraudBlockedItemsResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof RemoveFraudBlockedItemsResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof RemoveFraudBlockedItemsResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof RemoveFraudBlockedItemsResponse
     */
    responseType?: ResponseType;
    /**
     * Status from delete fraud blocked items operation.
     * @type {string}
     * @memberof RemoveFraudBlockedItemsResponse
     */
    status?: string;
}
/**
 * Amount component details, used in responses.
 * @export
 * @interface ResponseAmountComponents
 */
export interface ResponseAmountComponents {
    /**
     * Subtotal amount.
     * @type {number}
     * @memberof ResponseAmountComponents
     */
    subtotal?: number;
    /**
     * Value-added tax amount.
     * @type {number}
     * @memberof ResponseAmountComponents
     */
    vatAmount?: number;
    /**
     * Local tax amount.
     * @type {number}
     * @memberof ResponseAmountComponents
     */
    localTax?: number;
    /**
     * Shipping amount.
     * @type {number}
     * @memberof ResponseAmountComponents
     */
    shipping?: number;
    /**
     * Cashback amount.
     * @type {number}
     * @memberof ResponseAmountComponents
     */
    cashback?: number;
    /**
     * Tip amount.
     * @type {number}
     * @memberof ResponseAmountComponents
     */
    tip?: number;
    /**
     * Amount added for proccessing or handling fees.
     * @type {number}
     * @memberof ResponseAmountComponents
     */
    convenienceFee?: number;
}
/**
 * 
 * @export
 * @interface ResponseAmountComponentsAllOf
 */
export interface ResponseAmountComponentsAllOf {
    /**
     * Amount added for proccessing or handling fees.
     * @type {number}
     * @memberof ResponseAmountComponentsAllOf
     */
    convenienceFee?: number;
}
/**
 * The type of the response.
 * @export
 * @enum {string}
 */
export enum ResponseType {
    BadRequest = 'BadRequest',
    Unauthenticated = 'Unauthenticated',
    Unauthorized = 'Unauthorized',
    NotFound = 'NotFound',
    GatewayDeclined = 'GatewayDeclined',
    EndpointDeclined = 'EndpointDeclined',
    ServerError = 'ServerError',
    EndpointCommunicationError = 'EndpointCommunicationError',
    UnsupportedMediaType = 'UnsupportedMediaType'
}

/**
 * Request to perform return transaction.
 * @export
 * @interface ReturnTransaction
 */
export interface ReturnTransaction extends SecondaryTransaction {
    /**
     * 
     * @type {Amount}
     * @memberof ReturnTransaction
     */
    transactionAmount: Amount;
    /**
     * 
     * @type {SoftDescriptor}
     * @memberof ReturnTransaction
     */
    softDescriptor?: SoftDescriptor;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof ReturnTransaction
     */
    currencyConversion?: CurrencyConversion;
}
/**
 * 
 * @export
 * @interface ReturnTransactionAllOf
 */
export interface ReturnTransactionAllOf {
    /**
     * 
     * @type {Amount}
     * @memberof ReturnTransactionAllOf
     */
    transactionAmount: Amount;
    /**
     * 
     * @type {SoftDescriptor}
     * @memberof ReturnTransactionAllOf
     */
    softDescriptor?: SoftDescriptor;
    /**
     * 
     * @type {CurrencyConversion}
     * @memberof ReturnTransactionAllOf
     */
    currencyConversion?: CurrencyConversion;
}
/**
 * Fraud detect request payload.
 * @export
 * @interface ScoreOnlyRequest
 */
export interface ScoreOnlyRequest {
    /**
     * Merchant reference code. Used by FirstAPI and reflected in settlement records and Webhook notifications. Typically, the merchantRef field is the purchase order number or unique sequence value associated to a given transaction.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    merchantRef?: string;
    /**
     * Type of transaction merchant wants to process.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    transactionType: string;
    /**
     * Defines the type of the original transaction that is being evaluated for the Fraud Score.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    originalTransactionType: ScoreOnlyRequestOriginalTransactionTypeEnum;
    /**
     * The unique ID of this transaction. Must be unique for the entire system (not just within a specific merchant or industry). Subsequent requests related to the same transaction must have the same transactionId (e.g. transaction/deposit or transaction/authorization-reversal). This field is used for matching transactions with settlement and chargeback information. If there is no such ID available you may wish to compose one from fields available in both systems. Consider including backend, issuer, merchant id, date and time, amount, etc. as necessary.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    originalTransactionId: string;
    /**
     * The amount processed for the original transaction.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    amount: string;
    /**
     * The currency of the original transaction.
     * @type {string}
     * @memberof ScoreOnlyRequest
     */
    currencyCode: string;
    /**
     * 
     * @type {Customer}
     * @memberof ScoreOnlyRequest
     */
    customer?: Customer;
    /**
     * 
     * @type {BillingAddress}
     * @memberof ScoreOnlyRequest
     */
    billingAddress?: BillingAddress;
    /**
     * 
     * @type {Device}
     * @memberof ScoreOnlyRequest
     */
    device?: Device;
    /**
     * 
     * @type {Loyalty}
     * @memberof ScoreOnlyRequest
     */
    loyalty?: Loyalty;
    /**
     * 
     * @type {Payment}
     * @memberof ScoreOnlyRequest
     */
    payment: Payment;
    /**
     * 
     * @type {Merchant}
     * @memberof ScoreOnlyRequest
     */
    merchant: Merchant;
    /**
     * 
     * @type {FraudOrder}
     * @memberof ScoreOnlyRequest
     */
    order?: FraudOrder;
    /**
     * A JSON object that can carry any additional information that might be helpful for fraud detection.
     * @type {object}
     * @memberof ScoreOnlyRequest
     */
    userDefined?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ScoreOnlyRequestOriginalTransactionTypeEnum {
    Authorization = 'transaction/authorization',
    AuthorizationReversal = 'transaction/authorization-reversal',
    Deposit = 'transaction/deposit',
    DepositReversal = 'transaction/deposit-reversal',
    Purchase = 'transaction/purchase',
    PurchaseReversal = 'transaction/purchase-reversal',
    RefundAuthorization = 'transaction/refund-authorization',
    RefundDeposit = 'transaction/refund-deposit',
    Verification = 'transaction/verification',
    BalanceInquiry = 'transaction/balance-inquiry'
}

/**
 * Fraud detect response.
 * @export
 * @interface ScoreOnlyResponse
 */
export interface ScoreOnlyResponse {
    /**
     * Unique trace ID for issue triage.
     * @type {string}
     * @memberof ScoreOnlyResponse
     */
    correlationId?: string;
    /**
     * Please refer to \"Errors Section\" for more info.
     * @type {string}
     * @memberof ScoreOnlyResponse
     */
    transactionStatus?: ScoreOnlyResponseTransactionStatusEnum;
    /**
     * If status returned is \"failure\", input validation errors occurred. Please refer to the \"Errors Section\" for more info. Valid values are \'success\' and \'failure\'.
     * @type {string}
     * @memberof ScoreOnlyResponse
     */
    validationStatus?: string;
    /**
     * The transactionType provided in request.
     * @type {string}
     * @memberof ScoreOnlyResponse
     */
    transactionType?: string;
    /**
     * 
     * @type {ScoreOnlyResponseFraudScore}
     * @memberof ScoreOnlyResponse
     */
    fraudScore?: ScoreOnlyResponseFraudScore;
}

/**
    * @export
    * @enum {string}
    */
export enum ScoreOnlyResponseTransactionStatusEnum {
    ScoredSuccessfully = 'Scored Successfully',
    NotProcessed = 'Not Processed'
}

/**
 * Fraud likelihood assessment consisting of a score, associated warning(s), and explanation(s) of score received.
 * @export
 * @interface ScoreOnlyResponseFraudScore
 */
export interface ScoreOnlyResponseFraudScore {
    /**
     * The score attributed to this request by our machine learning system, ranging from 0 (less likely to be fraud) to 1000 (more likely to be fraud).
     * @type {string}
     * @memberof ScoreOnlyResponseFraudScore
     */
    score?: string;
    /**
     * A list of non-critical warnings raised while processing the request. Warnings included in this list will have integration and data-quality related messages.
     * @type {Array<string>}
     * @memberof ScoreOnlyResponseFraudScore
     */
    warnings?: Array<string>;
    /**
     * Explanation of the fraud score applied consisting of a description, type of the explanation, and rule (if applicable).
     * @type {Array<ScoreOnlyResponseFraudScoreExplanations>}
     * @memberof ScoreOnlyResponseFraudScore
     */
    explanations?: Array<ScoreOnlyResponseFraudScoreExplanations>;
    /**
     * The action that should be taken for the request that was sent.
     * @type {string}
     * @memberof ScoreOnlyResponseFraudScore
     */
    recommendedDecision?: string;
}
/**
 * 
 * @export
 * @interface ScoreOnlyResponseFraudScoreExplanations
 */
export interface ScoreOnlyResponseFraudScoreExplanations {
    /**
     * Description of the fraud score explanation.
     * @type {string}
     * @memberof ScoreOnlyResponseFraudScoreExplanations
     */
    description?: string;
    /**
     * ID of the rule being triggered.
     * @type {string}
     * @memberof ScoreOnlyResponseFraudScoreExplanations
     */
    rule?: string;
    /**
     * Type of the explanation (model or rule).
     * @type {string}
     * @memberof ScoreOnlyResponseFraudScoreExplanations
     */
    type?: string;
}
/**
 * Model for secondary financial transactions. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface SecondaryTransaction
 */
export interface SecondaryTransaction {
    /**
     * Object name of the secondary transaction request.
     * @type {string}
     * @memberof SecondaryTransaction
     */
    requestType: string;
    /**
     * An optional outlet ID for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof SecondaryTransaction
     */
    storeId?: string;
    /**
     * The unique merchant transaction ID from the request, if supplied.
     * @type {string}
     * @memberof SecondaryTransaction
     */
    merchantTransactionId?: string;
    /**
     * Comment for the secondary transaction.
     * @type {string}
     * @memberof SecondaryTransaction
     */
    comments?: string;
    /**
     * 
     * @type {Order}
     * @memberof SecondaryTransaction
     */
    order?: Order;
}
/**
 * Request authentication of the payment card using the 3DS 1.0 URL redirect scheme.
 * @export
 * @interface Secure3D10AuthenticationRequest
 */
export interface Secure3D10AuthenticationRequest extends AuthenticationRequest {
}
/**
 * Submit the result of the authentication managed outside of the gateway for a 3-D Secure 1.0 scheme. For more convenient usage without implementing 3-D Secure yourself see \"authenticationRequest\" section.
 * @export
 * @interface Secure3D10AuthenticationResult
 */
export interface Secure3D10AuthenticationResult extends AuthenticationResult {
    /**
     * Card enrollment result from the Verification Response (VeRes).
     * @type {string}
     * @memberof Secure3D10AuthenticationResult
     */
    verificationResponse?: Secure3D10AuthenticationResultVerificationResponseEnum;
    /**
     * Result of authentication attempt from Payer Authentication Response (PaRes).
     * @type {string}
     * @memberof Secure3D10AuthenticationResult
     */
    authenticationAttemptResult?: Secure3D10AuthenticationResultAuthenticationAttemptResultEnum;
    /**
     * The Cardholder Authentication Verification Value (CAVV) is a cryptographic value derived by the issuer during payment authentication that can provide evidence of the results of payment authentication during an online purchase.
     * @type {string}
     * @memberof Secure3D10AuthenticationResult
     */
    cavv?: string;
    /**
     * The transaction identifier (XID) is a unique tracking number set by the merchant.
     * @type {string}
     * @memberof Secure3D10AuthenticationResult
     */
    xid?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum Secure3D10AuthenticationResultVerificationResponseEnum {
    Y = 'Y',
    N = 'N',
    U = 'U'
}
/**
    * @export
    * @enum {string}
    */
export enum Secure3D10AuthenticationResultAuthenticationAttemptResultEnum {
    Y = 'Y',
    N = 'N',
    U = 'U',
    A = 'A'
}

/**
 * 
 * @export
 * @interface Secure3D10AuthenticationResultAllOf
 */
export interface Secure3D10AuthenticationResultAllOf {
    /**
     * Card enrollment result from the Verification Response (VeRes).
     * @type {string}
     * @memberof Secure3D10AuthenticationResultAllOf
     */
    verificationResponse?: Secure3D10AuthenticationResultAllOfVerificationResponseEnum;
    /**
     * Result of authentication attempt from Payer Authentication Response (PaRes).
     * @type {string}
     * @memberof Secure3D10AuthenticationResultAllOf
     */
    authenticationAttemptResult?: Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum;
    /**
     * The Cardholder Authentication Verification Value (CAVV) is a cryptographic value derived by the issuer during payment authentication that can provide evidence of the results of payment authentication during an online purchase.
     * @type {string}
     * @memberof Secure3D10AuthenticationResultAllOf
     */
    cavv?: string;
    /**
     * The transaction identifier (XID) is a unique tracking number set by the merchant.
     * @type {string}
     * @memberof Secure3D10AuthenticationResultAllOf
     */
    xid?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum Secure3D10AuthenticationResultAllOfVerificationResponseEnum {
    Y = 'Y',
    N = 'N',
    U = 'U'
}
/**
    * @export
    * @enum {string}
    */
export enum Secure3D10AuthenticationResultAllOfAuthenticationAttemptResultEnum {
    Y = 'Y',
    N = 'N',
    U = 'U',
    A = 'A'
}

/**
 * Authentication update request specific to 3DSecure 1.0 transactions.
 * @export
 * @interface Secure3D10AuthenticationUpdateRequest
 */
export interface Secure3D10AuthenticationUpdateRequest extends AuthenticationUpdateRequest {
    /**
     * A formatted message providing results of the issuer’s cardholder authentication.
     * @type {string}
     * @memberof Secure3D10AuthenticationUpdateRequest
     */
    payerAuthenticationResponse: string;
    /**
     * Formatted string encoding transaction time, order ID, and return URL data.
     * @type {string}
     * @memberof Secure3D10AuthenticationUpdateRequest
     */
    merchantData: string;
    /**
     * Card security code if required by merchant.
     * @type {string}
     * @memberof Secure3D10AuthenticationUpdateRequest
     */
    securityCode?: string;
}
/**
 * 
 * @export
 * @interface Secure3D10AuthenticationUpdateRequestAllOf
 */
export interface Secure3D10AuthenticationUpdateRequestAllOf {
    /**
     * A formatted message providing results of the issuer’s cardholder authentication.
     * @type {string}
     * @memberof Secure3D10AuthenticationUpdateRequestAllOf
     */
    payerAuthenticationResponse: string;
    /**
     * Formatted string encoding transaction time, order ID, and return URL data.
     * @type {string}
     * @memberof Secure3D10AuthenticationUpdateRequestAllOf
     */
    merchantData: string;
    /**
     * Card security code if required by merchant.
     * @type {string}
     * @memberof Secure3D10AuthenticationUpdateRequestAllOf
     */
    securityCode?: string;
}
/**
 * Request authentication of the payment card using the 3DS 2.x URL redirect scheme.
 * @export
 * @interface Secure3D21AuthenticationRequest
 */
export interface Secure3D21AuthenticationRequest extends AuthenticationRequest {
    /**
     * The result of the authentication will be sent to this URL. If not provided, a term URL will be dynamically generated. Note this must be a valid URL (special characters should be URL-encoded).
     * @type {string}
     * @memberof Secure3D21AuthenticationRequest
     */
    termURL?: string;
    /**
     * The 3DS method iframe and transaction ID will be sent here. Note this must be a valid URL (special characters should be URL-encoded).
     * @type {string}
     * @memberof Secure3D21AuthenticationRequest
     */
    methodNotificationURL?: string;
    /**
     * Indicates whether or not a challenge should be performed. 01 = No preference (You have no preference whether a challenge should be performed. This is the default value) 02 = No challenge requested (You prefer that no challenge should be performed) 03 = Challenge requested: 3DS Requestor Preference (You prefer that a challenge should be performed) 04 = Challenge requested: Mandate (There are local or regional mandates that mean that a challenge must be performed) 
     * @type {string}
     * @memberof Secure3D21AuthenticationRequest
     */
    challengeIndicator?: Secure3D21AuthenticationRequestChallengeIndicatorEnum;
    /**
     * Defines the size of the challenge window displayed to customers during authentication. 01 = 250 x 400 02 = 390 x 400 03 = 500 x 600 04 = 600 x 400 05 = Full screen 
     * @type {string}
     * @memberof Secure3D21AuthenticationRequest
     */
    challengeWindowSize?: Secure3D21AuthenticationRequestChallengeWindowSizeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Secure3D21AuthenticationRequestChallengeIndicatorEnum {
    _01 = '01',
    _02 = '02',
    _03 = '03',
    _04 = '04'
}
/**
    * @export
    * @enum {string}
    */
export enum Secure3D21AuthenticationRequestChallengeWindowSizeEnum {
    _01 = '01',
    _02 = '02',
    _03 = '03',
    _04 = '04',
    _05 = '05'
}

/**
 * 
 * @export
 * @interface Secure3D21AuthenticationRequestAllOf
 */
export interface Secure3D21AuthenticationRequestAllOf {
    /**
     * The result of the authentication will be sent to this URL. If not provided, a term URL will be dynamically generated. Note this must be a valid URL (special characters should be URL-encoded).
     * @type {string}
     * @memberof Secure3D21AuthenticationRequestAllOf
     */
    termURL?: string;
    /**
     * The 3DS method iframe and transaction ID will be sent here. Note this must be a valid URL (special characters should be URL-encoded).
     * @type {string}
     * @memberof Secure3D21AuthenticationRequestAllOf
     */
    methodNotificationURL?: string;
    /**
     * Indicates whether or not a challenge should be performed. 01 = No preference (You have no preference whether a challenge should be performed. This is the default value) 02 = No challenge requested (You prefer that no challenge should be performed) 03 = Challenge requested: 3DS Requestor Preference (You prefer that a challenge should be performed) 04 = Challenge requested: Mandate (There are local or regional mandates that mean that a challenge must be performed) 
     * @type {string}
     * @memberof Secure3D21AuthenticationRequestAllOf
     */
    challengeIndicator?: Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum;
    /**
     * Defines the size of the challenge window displayed to customers during authentication. 01 = 250 x 400 02 = 390 x 400 03 = 500 x 600 04 = 600 x 400 05 = Full screen 
     * @type {string}
     * @memberof Secure3D21AuthenticationRequestAllOf
     */
    challengeWindowSize?: Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Secure3D21AuthenticationRequestAllOfChallengeIndicatorEnum {
    _01 = '01',
    _02 = '02',
    _03 = '03',
    _04 = '04'
}
/**
    * @export
    * @enum {string}
    */
export enum Secure3D21AuthenticationRequestAllOfChallengeWindowSizeEnum {
    _01 = '01',
    _02 = '02',
    _03 = '03',
    _04 = '04',
    _05 = '05'
}

/**
 * Submit the result of the authentication managed outside of the gateway for a 3-D Secure 2.x scheme. For more convenient usage without implementing 3-D Secure yourself see \"authenticationRequest\" section.
 * @export
 * @interface Secure3D21AuthenticationResult
 */
export interface Secure3D21AuthenticationResult extends AuthenticationResult {
    /**
     * The Cardholder Authentication Verification Value (CAVV) is a cryptographic value derived by the issuer during payment authentication that can provide evidence of the results of payment authentication during an online purchase.
     * @type {string}
     * @memberof Secure3D21AuthenticationResult
     */
    cavv?: string;
    /**
     * The transaction identifier (XID) is a unique tracking number set by the merchant.
     * @type {string}
     * @memberof Secure3D21AuthenticationResult
     */
    xid?: string;
    /**
     * The response transaction UUID. Only applicable to MasterCard.
     * @type {string}
     * @memberof Secure3D21AuthenticationResult
     */
    transactionId?: string;
    /**
     * The result of authentication attempt returned by the 3D Secure authentication process (PaRes).
     * @type {string}
     * @memberof Secure3D21AuthenticationResult
     */
    authenticationResponse?: Secure3D21AuthenticationResultAuthenticationResponseEnum;
    /**
     * The transaction status as returned by the 3D Secure authentication process.
     * @type {string}
     * @memberof Secure3D21AuthenticationResult
     */
    transactionStatus?: Secure3D21AuthenticationResultTransactionStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Secure3D21AuthenticationResultAuthenticationResponseEnum {
    A = 'A',
    N = 'N',
    U = 'U',
    Y = 'Y',
    C = 'C',
    R = 'R'
}
/**
    * @export
    * @enum {string}
    */
export enum Secure3D21AuthenticationResultTransactionStatusEnum {
    A = 'A',
    N = 'N',
    U = 'U',
    Y = 'Y',
    C = 'C',
    R = 'R'
}

/**
 * 
 * @export
 * @interface Secure3D21AuthenticationResultAllOf
 */
export interface Secure3D21AuthenticationResultAllOf {
    /**
     * The Cardholder Authentication Verification Value (CAVV) is a cryptographic value derived by the issuer during payment authentication that can provide evidence of the results of payment authentication during an online purchase.
     * @type {string}
     * @memberof Secure3D21AuthenticationResultAllOf
     */
    cavv?: string;
    /**
     * The transaction identifier (XID) is a unique tracking number set by the merchant.
     * @type {string}
     * @memberof Secure3D21AuthenticationResultAllOf
     */
    xid?: string;
    /**
     * The response transaction UUID. Only applicable to MasterCard.
     * @type {string}
     * @memberof Secure3D21AuthenticationResultAllOf
     */
    transactionId?: string;
    /**
     * The result of authentication attempt returned by the 3D Secure authentication process (PaRes).
     * @type {string}
     * @memberof Secure3D21AuthenticationResultAllOf
     */
    authenticationResponse?: Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum;
    /**
     * The transaction status as returned by the 3D Secure authentication process.
     * @type {string}
     * @memberof Secure3D21AuthenticationResultAllOf
     */
    transactionStatus?: Secure3D21AuthenticationResultAllOfTransactionStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Secure3D21AuthenticationResultAllOfAuthenticationResponseEnum {
    A = 'A',
    N = 'N',
    U = 'U',
    Y = 'Y',
    C = 'C',
    R = 'R'
}
/**
    * @export
    * @enum {string}
    */
export enum Secure3D21AuthenticationResultAllOfTransactionStatusEnum {
    A = 'A',
    N = 'N',
    U = 'U',
    Y = 'Y',
    C = 'C',
    R = 'R'
}

/**
 * Authentication update request specific to 3DSecure 2.x transactions.
 * @export
 * @interface Secure3D21AuthenticationUpdateRequest
 */
export interface Secure3D21AuthenticationUpdateRequest extends AuthenticationUpdateRequest {
    /**
     * Indicates how the merchant received the 3DS method.
     * @type {string}
     * @memberof Secure3D21AuthenticationUpdateRequest
     */
    methodNotificationStatus?: Secure3D21AuthenticationUpdateRequestMethodNotificationStatusEnum;
    /**
     * 
     * @type {ACSResponse}
     * @memberof Secure3D21AuthenticationUpdateRequest
     */
    acsResponse?: ACSResponse;
}

/**
    * @export
    * @enum {string}
    */
export enum Secure3D21AuthenticationUpdateRequestMethodNotificationStatusEnum {
    RECEIVED = 'RECEIVED',
    EXPECTEDBUTNOTRECEIVED = 'EXPECTED_BUT_NOT_RECEIVED',
    NOTEXPECTED = 'NOT_EXPECTED'
}

/**
 * 
 * @export
 * @interface Secure3D21AuthenticationUpdateRequestAllOf
 */
export interface Secure3D21AuthenticationUpdateRequestAllOf {
    /**
     * Indicates how the merchant received the 3DS method.
     * @type {string}
     * @memberof Secure3D21AuthenticationUpdateRequestAllOf
     */
    methodNotificationStatus?: Secure3D21AuthenticationUpdateRequestAllOfMethodNotificationStatusEnum;
    /**
     * 
     * @type {ACSResponse}
     * @memberof Secure3D21AuthenticationUpdateRequestAllOf
     */
    acsResponse?: ACSResponse;
}

/**
    * @export
    * @enum {string}
    */
export enum Secure3D21AuthenticationUpdateRequestAllOfMethodNotificationStatusEnum {
    RECEIVED = 'RECEIVED',
    EXPECTEDBUTNOTRECEIVED = 'EXPECTED_BUT_NOT_RECEIVED',
    NOTEXPECTED = 'NOT_EXPECTED'
}

/**
 * Encapsulates 3DS authentication details in transaction responses.
 * @export
 * @interface Secure3DAuthenticationResponse
 */
export interface Secure3DAuthenticationResponse {
    /**
     * The type of authentication.
     * @type {string}
     * @memberof Secure3DAuthenticationResponse
     */
    type?: Secure3DAuthenticationResponseTypeEnum;
    /**
     * The version of 3DS used to authenticate.
     * @type {string}
     * @memberof Secure3DAuthenticationResponse
     */
    version?: Secure3DAuthenticationResponseVersionEnum;
    /**
     * 
     * @type {Secure3DAuthenticationResponseParams}
     * @memberof Secure3DAuthenticationResponse
     */
    params?: Secure3DAuthenticationResponseParams;
    /**
     * 
     * @type {Secure3DAuthenticationResponseSecure3dMethod}
     * @memberof Secure3DAuthenticationResponse
     */
    secure3dMethod?: Secure3DAuthenticationResponseSecure3dMethod;
}

/**
    * @export
    * @enum {string}
    */
export enum Secure3DAuthenticationResponseTypeEnum {
    _3DSECURE = '3D_SECURE'
}
/**
    * @export
    * @enum {string}
    */
export enum Secure3DAuthenticationResponseVersionEnum {
    _10 = '1.0',
    _21 = '2.1',
    _22 = '2.2'
}

/**
 * Additional parameters for authentication redirect.
 * @export
 * @interface Secure3DAuthenticationResponseParams
 */
export interface Secure3DAuthenticationResponseParams {
    /**
     * Message sent from merchant server to authenticate the cardholder.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    payerAuthenticationRequest?: string;
    /**
     * Terminal URL for processing request.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    termURL?: string;
    /**
     * Formatted string encoding transaction time, order ID, and return URL data.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    merchantData?: string;
    /**
     * The URL for the authentication redirect for the merchant.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    acsURL?: string;
    /**
     * The CReq message initiates cardholder interaction in a 3DS 2.x challenge flow and carries authentication data from the cardholder.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    cReq?: string;
    /**
     * Customer web browser session data.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseParams
     */
    sessionData?: string;
}
/**
 * Encapsulates the 3DS method form and unique transaction identifier.
 * @export
 * @interface Secure3DAuthenticationResponseSecure3dMethod
 */
export interface Secure3DAuthenticationResponseSecure3dMethod {
    /**
     * An iframe to be hidden in the browser used to collect browser data for the issuers. This information adds to the overall consumer profile and helps in identifying potentially fraudulent transactions.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseSecure3dMethod
     */
    methodForm?: string;
    /**
     * A unique transaction identifier supplied by the ACS.
     * @type {string}
     * @memberof Secure3DAuthenticationResponseSecure3dMethod
     */
    secure3dTransId?: string;
}
/**
 * Contains 3DSecure response code.
 * @export
 * @interface Secure3dResponse
 */
export interface Secure3dResponse {
    /**
     * Code received after successful payer-auth verification.
     * @type {string}
     * @memberof Secure3dResponse
     */
    responseCode3dSecure?: string;
}
/**
 * Sender information for a disbursement transaction.
 * @export
 * @interface SenderInfo
 */
export interface SenderInfo {
    /**
     * Sender name.
     * @type {string}
     * @memberof SenderInfo
     */
    name: string;
    /**
     * Sender street address.
     * @type {string}
     * @memberof SenderInfo
     */
    streetAddress: string;
    /**
     * Sender city.
     * @type {string}
     * @memberof SenderInfo
     */
    city: string;
    /**
     * Sender state.
     * @type {string}
     * @memberof SenderInfo
     */
    stateCode: string;
    /**
     * Sender country code.
     * @type {string}
     * @memberof SenderInfo
     */
    countryCode: string;
    /**
     * Sender postal code.
     * @type {string}
     * @memberof SenderInfo
     */
    postalCode: string;
    /**
     * Sender phone number.
     * @type {string}
     * @memberof SenderInfo
     */
    phoneNumber: string;
    /**
     * Sender date of birth (YYYYMMDD).
     * @type {string}
     * @memberof SenderInfo
     */
    birthDate?: string;
    /**
     * Sender reference number.
     * @type {string}
     * @memberof SenderInfo
     */
    referenceNumber: string;
    /**
     * Sender account number.
     * @type {string}
     * @memberof SenderInfo
     */
    accountNumber: string;
}
/**
 * The payment object for SEPA Local Payment.
 * @export
 * @interface Sepa
 */
export interface Sepa {
    /**
     * Bank account in IBAN format.
     * @type {string}
     * @memberof Sepa
     */
    iban: string;
    /**
     * The name of the payer.
     * @type {string}
     * @memberof Sepa
     */
    name: string;
    /**
     * Country of residence of the payer using the ISO 3166 standard.
     * @type {string}
     * @memberof Sepa
     */
    country: string;
    /**
     * The email address of the payer.
     * @type {string}
     * @memberof Sepa
     */
    email?: string;
    /**
     * 
     * @type {SepaMandate}
     * @memberof Sepa
     */
    mandate: SepaMandate;
}
/**
 * Model for the SEPA Mandate information.
 * @export
 * @interface SepaMandate
 */
export interface SepaMandate {
    /**
     * Existing mandate reference, managed by merchant. Must match [A-Za-z0-9:?/+(),. -]{1,35} and not start with two slashes (\"//\"). Also known as the mandate ID.
     * @type {string}
     * @memberof SepaMandate
     */
    reference: string;
    /**
     * Valid URL pointing to the SEPA mandate (PDF / HTML format recommended).
     * @type {string}
     * @memberof SepaMandate
     */
    url: string;
    /**
     * Date of mandate signature.
     * @type {string}
     * @memberof SepaMandate
     */
    signatureDate: string;
    /**
     * Sequence type of the direct debit. This defaults to \'SINGLE\' if not provided.
     * @type {string}
     * @memberof SepaMandate
     */
    type: SepaMandateTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SepaMandateTypeEnum {
    SINGLE = 'SINGLE',
    FIRSTCOLLECTION = 'FIRST_COLLECTION',
    RECURRINGCOLLECTION = 'RECURRING_COLLECTION',
    FINALCOLLECTION = 'FINAL_COLLECTION'
}

/**
 * Payment method containing sepa information.
 * @export
 * @interface SepaPaymentMethod
 */
export interface SepaPaymentMethod {
    /**
     * 
     * @type {Sepa}
     * @memberof SepaPaymentMethod
     */
    sepa: Sepa;
}
/**
 * 
 * @export
 * @interface SepaPaymentMethodAllOf
 */
export interface SepaPaymentMethodAllOf {
    /**
     * 
     * @type {Sepa}
     * @memberof SepaPaymentMethodAllOf
     */
    sepa: Sepa;
}
/**
 * Request to create sale transaction using sepa.
 * @export
 * @interface SepaSaleTransaction
 */
export interface SepaSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {SepaPaymentMethod}
     * @memberof SepaSaleTransaction
     */
    paymentMethod: SepaPaymentMethod;
}
/**
 * 
 * @export
 * @interface SepaSaleTransactionAllOf
 */
export interface SepaSaleTransactionAllOf {
    /**
     * 
     * @type {SepaPaymentMethod}
     * @memberof SepaSaleTransactionAllOf
     */
    paymentMethod: SepaPaymentMethod;
}
/**
 * Request to create or update success/fail URLs for store.
 * @export
 * @interface SharedSecretConfigurationRequest
 */
export interface SharedSecretConfigurationRequest {
    /**
     * Shared secret/password for Connect.
     * @type {string}
     * @memberof SharedSecretConfigurationRequest
     */
    sharedSecret: string;
}
/**
 * Response from a shared secret configuration request.
 * @export
 * @interface SharedSecretConfigurationResponse
 */
export interface SharedSecretConfigurationResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof SharedSecretConfigurationResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof SharedSecretConfigurationResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof SharedSecretConfigurationResponse
     */
    responseType?: ResponseType;
    /**
     * An optional outlet ID for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof SharedSecretConfigurationResponse
     */
    storeId?: string;
    /**
     * Shared secret/password for Connect.
     * @type {string}
     * @memberof SharedSecretConfigurationResponse
     */
    sharedSecret?: string;
    /**
     * The message/status received after updating shared secret service config.
     * @type {string}
     * @memberof SharedSecretConfigurationResponse
     */
    responseMessage?: string;
    /**
     * Response timestamp.
     * @type {number}
     * @memberof SharedSecretConfigurationResponse
     */
    responseTimestamp?: number;
}
/**
 * The address where the items in this order should be shipped to.
 * @export
 * @interface ShipToAddress
 */
export interface ShipToAddress {
    /**
     * Free-form phone number associated with the ship-to address.
     * @type {string}
     * @memberof ShipToAddress
     */
    phone?: string;
    /**
     * First line of street address.
     * @type {string}
     * @memberof ShipToAddress
     */
    address1?: string;
    /**
     * Second line of street address.
     * @type {string}
     * @memberof ShipToAddress
     */
    address2?: string;
    /**
     * City.
     * @type {string}
     * @memberof ShipToAddress
     */
    city?: string;
    /**
     * State or province.
     * @type {string}
     * @memberof ShipToAddress
     */
    state?: string;
    /**
     * Postal Code, free form.
     * @type {string}
     * @memberof ShipToAddress
     */
    zip?: string;
    /**
     * Country.
     * @type {string}
     * @memberof ShipToAddress
     */
    country?: string;
}
/**
 * Shipping information.
 * @export
 * @interface Shipping
 */
export interface Shipping {
    /**
     * Name of customer for shipping.
     * @type {string}
     * @memberof Shipping
     */
    name?: string;
    /**
     * 
     * @type {Contact}
     * @memberof Shipping
     */
    contact?: Contact;
    /**
     * 
     * @type {Address}
     * @memberof Shipping
     */
    address?: Address;
}
/**
 * Identifying information about a merchant which appears on buyer\'s credit/debit card statements.
 * @export
 * @interface SoftDescriptor
 */
export interface SoftDescriptor {
    /**
     * Store \"doing-business-as\" name.
     * @type {string}
     * @memberof SoftDescriptor
     */
    dynamicMerchantName: string;
    /**
     * Customer service phone number information that is passed to the issuer (it may appear on the cardholder’s statement) or if merchant wants to pass information that differs from the information stored on our master File.
     * @type {string}
     * @memberof SoftDescriptor
     */
    customerServiceNumber?: string;
    /**
     * The 4-digit merchant category code (MCC). The merchant might be associated with multiple MCCs. In that case the MCC provided here will be the one that better describes the current transaction.
     * @type {string}
     * @memberof SoftDescriptor
     */
    mcc?: string;
    /**
     * 
     * @type {Address}
     * @memberof SoftDescriptor
     */
    dynamicAddress?: Address;
}
/**
 * Split-shipment related information, in order to reuse the same authorization.
 * @export
 * @interface SplitShipment
 */
export interface SplitShipment {
    /**
     * Total count of the shipment, can be set at preauth or the first postauth.
     * @type {number}
     * @memberof SplitShipment
     */
    totalCount?: number;
    /**
     * Indicates whether the transaction is the final shipment.
     * @type {boolean}
     * @memberof SplitShipment
     */
    finalShipment?: boolean;
}
/**
 * 
 * @export
 * @interface StoreBrandingStyleConfiguration
 */
export interface StoreBrandingStyleConfiguration {
    /**
     * An optional outlet id for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof StoreBrandingStyleConfiguration
     */
    id: string;
    /**
     * 
     * @type {CombinedMode}
     * @memberof StoreBrandingStyleConfiguration
     */
    combined?: CombinedMode;
    /**
     * 
     * @type {ClassicMode}
     * @memberof StoreBrandingStyleConfiguration
     */
    classic?: ClassicMode;
}
/**
 * Object for email settings.
 * @export
 * @interface StoreEmailSettings
 */
export interface StoreEmailSettings {
    /**
     * An outlet identificator.
     * @type {string}
     * @memberof StoreEmailSettings
     */
    id: string;
    /**
     * 
     * @type {EmailNotificationData}
     * @memberof StoreEmailSettings
     */
    emailNotificationData: EmailNotificationData;
}
/**
 * Object that holds result from update email settings request.
 * @export
 * @interface StoreEmailSettingsResult
 */
export interface StoreEmailSettingsResult {
    /**
     * An outlet identificator.
     * @type {string}
     * @memberof StoreEmailSettingsResult
     */
    id?: string;
    /**
     * Status from email settings.
     * @type {string}
     * @memberof StoreEmailSettingsResult
     */
    status?: string;
}
/**
 * Object for fraud settings.
 * @export
 * @interface StoreFraudSettings
 */
export interface StoreFraudSettings {
    /**
     * The outlet identificator.
     * @type {string}
     * @memberof StoreFraudSettings
     */
    id: string;
    /**
     * 
     * @type {FraudSettings}
     * @memberof StoreFraudSettings
     */
    fraudSettings: FraudSettings;
}
/**
 * Object that holds result from update fraud settings request.
 * @export
 * @interface StoreFraudSettingsResult
 */
export interface StoreFraudSettingsResult {
    /**
     * An outlet identificator.
     * @type {string}
     * @memberof StoreFraudSettingsResult
     */
    id?: string;
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof StoreFraudSettingsResult
     */
    blockedCardIdentifier?: TokenIdentifier;
    /**
     * Status from fraud settings.
     * @type {string}
     * @memberof StoreFraudSettingsResult
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface StoreUrlConfiguration
 */
export interface StoreUrlConfiguration {
    /**
     * An optional outlet id for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof StoreUrlConfiguration
     */
    id: string;
    /**
     * Transaction notification URL for Connect.
     * @type {string}
     * @memberof StoreUrlConfiguration
     */
    transactionNotificationUrl?: string;
    /**
     * Recurring transaction notification URL for recurring payments.
     * @type {string}
     * @memberof StoreUrlConfiguration
     */
    recurringTransactionNotificationUrl?: string;
    /**
     * Response success URL for Connect.
     * @type {string}
     * @memberof StoreUrlConfiguration
     */
    responseSuccessUrl?: string;
    /**
     * Response failure URL for Connect.
     * @type {string}
     * @memberof StoreUrlConfiguration
     */
    responseFailureUrl?: string;
    /**
     * Skip connect result page when transaction is approved.
     * @type {boolean}
     * @memberof StoreUrlConfiguration
     */
    skipResultPageForSuccess?: boolean;
    /**
     * Skip connect result page when transaction is not approved.
     * @type {boolean}
     * @memberof StoreUrlConfiguration
     */
    skipResultPageForFailure?: boolean;
    /**
     * Overwrite URLs in database by those from request.
     * @type {boolean}
     * @memberof StoreUrlConfiguration
     */
    overwriteUrlAllowed?: boolean;
}
/**
 * Request to create or update notification and success/failure URLs for store.
 * @export
 * @interface StoreUrlConfigurationRequest
 */
export interface StoreUrlConfigurationRequest {
    /**
     * 
     * @type {Array<StoreUrlConfiguration>}
     * @memberof StoreUrlConfigurationRequest
     */
    stores?: Array<StoreUrlConfiguration>;
}
/**
 * Response from a store url configuration request.
 * @export
 * @interface StoreUrlConfigurationResponse
 */
export interface StoreUrlConfigurationResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof StoreUrlConfigurationResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof StoreUrlConfigurationResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof StoreUrlConfigurationResponse
     */
    responseType?: ResponseType;
    /**
     * 
     * @type {Array<StoreUrlConfigurationResult>}
     * @memberof StoreUrlConfigurationResponse
     */
    stores?: Array<StoreUrlConfigurationResult>;
}
/**
 * 
 * @export
 * @interface StoreUrlConfigurationResult
 */
export interface StoreUrlConfigurationResult {
    /**
     * An optional outlet id for clients that support multiple stores in the same developer app.
     * @type {string}
     * @memberof StoreUrlConfigurationResult
     */
    id?: string;
    /**
     * Status from store url configuration process.
     * @type {string}
     * @memberof StoreUrlConfigurationResult
     */
    status?: string;
}
/**
 * Object for sending stored credentials.
 * @export
 * @interface StoredCredential
 */
export interface StoredCredential {
    /**
     * Indicates if the transaction is first or subsequent. Valid values are \'FIRST\' and \'SUBSEQUENT\'.
     * @type {string}
     * @memberof StoredCredential
     */
    sequence: StoredCredentialSequenceEnum;
    /**
     * Indicates if the transaction is scheduled or part of an installment.
     * @type {boolean}
     * @memberof StoredCredential
     */
    scheduled: boolean;
    /**
     * The transaction ID received from schemes for the initial transaction. May be required if sequence is \'SUBSEQUENT\'.
     * @type {string}
     * @memberof StoredCredential
     */
    referencedSchemeTransactionId?: string;
    /**
     * Indicates whether it is a merchant-initiated or explicitly consented to by card holder. Valid values are \'MERCHANT\' and \'CARDHOLDER\'.
     * @type {string}
     * @memberof StoredCredential
     */
    initiator?: StoredCredentialInitiatorEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum StoredCredentialSequenceEnum {
    FIRST = 'FIRST',
    SUBSEQUENT = 'SUBSEQUENT'
}
/**
    * @export
    * @enum {string}
    */
export enum StoredCredentialInitiatorEnum {
    MERCHANT = 'MERCHANT',
    CARDHOLDER = 'CARDHOLDER'
}

/**
 * Once sub-merchant element is given, the transaction is considered to be a sub-merchant transaction.
 * @export
 * @interface SubMerchantData
 */
export interface SubMerchantData {
    /**
     * Merchant category code.
     * @type {string}
     * @memberof SubMerchantData
     */
    mcc: string;
    /**
     * Store legal name.
     * @type {string}
     * @memberof SubMerchantData
     */
    legalName?: string;
    /**
     * Timezone.
     * @type {string}
     * @memberof SubMerchantData
     */
    timezone?: string;
    /**
     * 
     * @type {Address}
     * @memberof SubMerchantData
     */
    address?: Address;
    /**
     * 
     * @type {Document}
     * @memberof SubMerchantData
     */
    document?: Document;
    /**
     * Sub-merchant ID.
     * @type {string}
     * @memberof SubMerchantData
     */
    merchantId?: string;
}
/**
 * Sub-merchant split object for SettlementSplit.
 * @export
 * @interface SubMerchantSplit
 */
export interface SubMerchantSplit {
    /**
     * ID of merchant for tracking.
     * @type {string}
     * @memberof SubMerchantSplit
     */
    merchantID: string;
    /**
     * The amount each sub-merchant receives.
     * @type {number}
     * @memberof SubMerchantSplit
     */
    amount: number;
}
/**
 * ACH means automated clearing house. Contains properties common across TeleCheck message types. Abstract class, do not use this class directly, use one of its children.
 * @export
 * @interface TeleCheckAchPaymentMethod
 */
export interface TeleCheckAchPaymentMethod {
    /**
     * ACH application type values will be one of either TeleCheckICAPaymentMethod or TeleCheckCBPPaymentMethod.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    achType: string;
    /**
     * Bank routing number.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    routingNumber: string;
    /**
     * Bank account number.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    accountNumber: string;
    /**
     * Identifies if the account type is checking or savings.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    accountType: TeleCheckAchPaymentMethodAccountTypeEnum;
    /**
     * Check number.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    checkNumber?: string;
    /**
     * Identifies if the check type is personal or company.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    checkType: TeleCheckAchPaymentMethodCheckTypeEnum;
    /**
     * Identifies the product code in the transaction.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    productCode?: string;
    /**
     * 
     * @type {IdInfo}
     * @memberof TeleCheckAchPaymentMethod
     */
    manualIdInfo?: IdInfo;
    /**
     * 
     * @type {IdInfo}
     * @memberof TeleCheckAchPaymentMethod
     */
    supplementIdInfo?: IdInfo;
    /**
     * Used to track the agent transaction activity.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    agentId?: string;
    /**
     * Identifies the register or lane number where the original sale transaction occurred.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    terminalId?: string;
    /**
     * Unique ID assigned by the merchant for the consumer (never recycled). It is an additional level of authentication. To use this feature, the merchant must work with TeleCheck Risk to discuss. Registration IDs must not be generated for an existing or returning consumer returns. The single registration ID must be unique per consumer.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    registrationId?: string;
    /**
     * Date the consumer originally registered in format MMDDYYYY.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    registrationDate?: string;
    /**
     * Release type is used as a risk variable to gauge risk level when the merchant is releasing the purchased merchandise.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    releaseType?: TeleCheckAchPaymentMethodReleaseTypeEnum;
    /**
     * Flags a transaction as a VIP order (based on merchant criteria). This field should not be sent for non-VIP orders.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    vipCustomer?: TeleCheckAchPaymentMethodVipCustomerEnum;
    /**
     * Session identifier.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    sessionId: string;
    /**
     * Identifies the US state or territory where the original sale transaction occurred.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    terminalState?: string;
    /**
     * Identifies the city where the original sale transaction occurred.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethod
     */
    terminalCity?: string;
    /**
     * 
     * @type {TeleCheckAchPaymentMethodAchBillTo}
     * @memberof TeleCheckAchPaymentMethod
     */
    achBillTo: TeleCheckAchPaymentMethodAchBillTo;
}

/**
    * @export
    * @enum {string}
    */
export enum TeleCheckAchPaymentMethodAccountTypeEnum {
    C = 'C',
    S = 'S'
}
/**
    * @export
    * @enum {string}
    */
export enum TeleCheckAchPaymentMethodCheckTypeEnum {
    P = 'P',
    C = 'C'
}
/**
    * @export
    * @enum {string}
    */
export enum TeleCheckAchPaymentMethodReleaseTypeEnum {
    C = 'C',
    D = 'D',
    P = 'P',
    T = 'T'
}
/**
    * @export
    * @enum {string}
    */
export enum TeleCheckAchPaymentMethodVipCustomerEnum {
    Y = 'Y',
    N = 'N'
}

/**
 * Billing details for telecheck transactions.
 * @export
 * @interface TeleCheckAchPaymentMethodAchBillTo
 */
export interface TeleCheckAchPaymentMethodAchBillTo {
    /**
     * Customer billing first name.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethodAchBillTo
     */
    firstName?: string;
    /**
     * Customer billing last name.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethodAchBillTo
     */
    lastName: string;
    /**
     * Customer billing address, first line.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethodAchBillTo
     */
    addressOne: string;
    /**
     * Customer billing address, second line.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethodAchBillTo
     */
    addressTwo?: string;
    /**
     * Customer billing city.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethodAchBillTo
     */
    city: string;
    /**
     * Customer billing state.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethodAchBillTo
     */
    state: string;
    /**
     * Customer billing zip code.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethodAchBillTo
     */
    zip: string;
    /**
     * Customer billing phone number.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethodAchBillTo
     */
    phone: string;
    /**
     * Customer billing email. Required if performing an ICA transaction.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethodAchBillTo
     */
    email?: string;
    /**
     * ISO country code. Required if performing an ICA transaction.
     * @type {string}
     * @memberof TeleCheckAchPaymentMethodAchBillTo
     */
    countryCode?: string;
}
/**
 * ACH TeleCheck payment method for check by phone application type.
 * @export
 * @interface TeleCheckCBPPaymentMethod
 */
export interface TeleCheckCBPPaymentMethod extends TeleCheckAchPaymentMethod {
}


/**
 * ACH TeleCheck payment method for internet check acceptance application type.
 * @export
 * @interface TeleCheckICAPaymentMethod
 */
export interface TeleCheckICAPaymentMethod extends TeleCheckAchPaymentMethod {
    /**
     * Customer IP address from the terminal where the order was placed (as captured by merchant).
     * @type {string}
     * @memberof TeleCheckICAPaymentMethod
     */
    customerIpAddress: string;
    /**
     * International mobile equipment identity code.
     * @type {string}
     * @memberof TeleCheckICAPaymentMethod
     */
    imeiCode?: string;
    /**
     * 
     * @type {AchRecurringType}
     * @memberof TeleCheckICAPaymentMethod
     */
    recurringType?: AchRecurringType;
}


/**
 * 
 * @export
 * @interface TeleCheckICAPaymentMethodAllOf
 */
export interface TeleCheckICAPaymentMethodAllOf {
    /**
     * Customer IP address from the terminal where the order was placed (as captured by merchant).
     * @type {string}
     * @memberof TeleCheckICAPaymentMethodAllOf
     */
    customerIpAddress: string;
    /**
     * International mobile equipment identity code.
     * @type {string}
     * @memberof TeleCheckICAPaymentMethodAllOf
     */
    imeiCode?: string;
    /**
     * 
     * @type {AchRecurringType}
     * @memberof TeleCheckICAPaymentMethodAllOf
     */
    recurringType?: AchRecurringType;
}
/**
 * Object contains text style properties.
 * @export
 * @interface Text
 */
export interface Text {
    /**
     * 
     * @type {Primary}
     * @memberof Text
     */
    primary?: Primary;
    /**
     * 
     * @type {Title}
     * @memberof Text
     */
    title?: Title;
}
/**
 * 
 * @export
 * @interface Title
 */
export interface Title {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof Title
     */
    color?: string;
}
/**
 * Token identifier object.
 * @export
 * @interface TokenIdentifier
 */
export interface TokenIdentifier {
    /**
     * Token identifier.
     * @type {string}
     * @memberof TokenIdentifier
     */
    tokenIdentifier?: string;
}
/**
 * 
 * @export
 * @interface TopBar
 */
export interface TopBar {
    /**
     * Hexadecimal color value.
     * @type {string}
     * @memberof TopBar
     */
    color?: string;
}
/**
 * Transaction response with error field included.
 * @export
 * @interface TransactionErrorResponse
 */
export interface TransactionErrorResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof TransactionErrorResponse
     */
    responseType?: ResponseType;
    /**
     * The response transaction ID.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    ipgTransactionId?: string;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    orderId?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof TransactionErrorResponse
     */
    transactionType?: TransactionType;
    /**
     * 
     * @type {PaymentTokenDetails}
     * @memberof TransactionErrorResponse
     */
    paymentToken?: PaymentTokenDetails;
    /**
     * 
     * @type {TransactionOrigin}
     * @memberof TransactionErrorResponse
     */
    transactionOrigin?: TransactionOrigin;
    /**
     * 
     * @type {PaymentMethodDetails}
     * @memberof TransactionErrorResponse
     */
    paymentMethodDetails?: PaymentMethodDetails;
    /**
     * Country of the card issuer.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    country?: string;
    /**
     * The terminal that is processing the transaction.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    terminalId?: string;
    /**
     * The unique (on Acquirer level) mechant ID. Usually this value has been chosen from the merchant itself and will be used in communication with the endpoint.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    merchantId?: string;
    /**
     * The unique merchant transaction ID from the request header, if supplied.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    merchantTransactionId?: string;
    /**
     * The transaction time in seconds since epoch.
     * @type {number}
     * @memberof TransactionErrorResponse
     */
    transactionTime?: number;
    /**
     * 
     * @type {Amount}
     * @memberof TransactionErrorResponse
     */
    approvedAmount?: Amount;
    /**
     * Represents the status of a transaction immediately following the original processing request. This value is not stored for the transaction and is only available in the response when the transaction is processed. TransactionStatus is not returned on either the transaction inquiry or on the order inquiry.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    transactionStatus?: TransactionErrorResponseTransactionStatusEnum;
    /**
     * Shows the state of the current transaction.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    transactionState?: TransactionErrorResponseTransactionStateEnum;
    /**
     * 
     * @type {Secure3dResponse}
     * @memberof TransactionErrorResponse
     */
    secure3dResponse?: Secure3dResponse;
    /**
     * The endpoint redirection URL.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    redirectURL?: string;
    /**
     * 
     * @type {Secure3DAuthenticationResponse}
     * @memberof TransactionErrorResponse
     */
    authenticationResponse?: Secure3DAuthenticationResponse;
    /**
     * The transaction ID received from schemes for the initial transaction of card on file flows.
     * @type {string}
     * @memberof TransactionErrorResponse
     */
    schemeTransactionId?: string;
    /**
     * 
     * @type {ProcessorData}
     * @memberof TransactionErrorResponse
     */
    processor?: ProcessorData;
    /**
     * 
     * @type {AdditionalTransactionDetails}
     * @memberof TransactionErrorResponse
     */
    additionalDetails?: AdditionalTransactionDetails;
    /**
     * 
     * @type {AccountUpdaterResponse}
     * @memberof TransactionErrorResponse
     */
    accountUpdaterResponse?: AccountUpdaterResponse;
    /**
     * 
     * @type {AchResponse}
     * @memberof TransactionErrorResponse
     */
    achResponse?: AchResponse;
    /**
     * 
     * @type {CurrencyConversionResponse}
     * @memberof TransactionErrorResponse
     */
    currencyConversionResponse?: CurrencyConversionResponse;
    /**
     * 
     * @type {Error}
     * @memberof TransactionErrorResponse
     */
    error?: Error;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionErrorResponseTransactionStatusEnum {
    APPROVED = 'APPROVED',
    WAITING = 'WAITING',
    VALIDATIONFAILED = 'VALIDATION_FAILED',
    PROCESSINGFAILED = 'PROCESSING_FAILED',
    DECLINED = 'DECLINED'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionErrorResponseTransactionStateEnum {
    AUTHORIZED = 'AUTHORIZED',
    CAPTURED = 'CAPTURED',
    DECLINED = 'DECLINED',
    CHECKED = 'CHECKED',
    COMPLETEDGET = 'COMPLETED_GET',
    INITIALIZED = 'INITIALIZED',
    PENDING = 'PENDING',
    READY = 'READY',
    TEMPLATE = 'TEMPLATE',
    SETTLED = 'SETTLED',
    VOIDED = 'VOIDED',
    WAITING = 'WAITING'
}

/**
 * The source of the transaction. The possible values are ECOM (if the order was received via email or Internet), MAIL, PHONE and RETAIL (face to face).
 * @export
 * @enum {string}
 */
export enum TransactionOrigin {
    ECOM = 'ECOM',
    MAIL = 'MAIL',
    PHONE = 'PHONE',
    RETAIL = 'RETAIL'
}

/**
 * Common object for primary and secondary payment request responses.
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof TransactionResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof TransactionResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof TransactionResponse
     */
    responseType?: ResponseType;
    /**
     * The response transaction ID.
     * @type {string}
     * @memberof TransactionResponse
     */
    ipgTransactionId?: string;
    /**
     * Client order ID if supplied by client, otherwise the order ID.
     * @type {string}
     * @memberof TransactionResponse
     */
    orderId?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof TransactionResponse
     */
    transactionType?: TransactionType;
    /**
     * 
     * @type {PaymentTokenDetails}
     * @memberof TransactionResponse
     */
    paymentToken?: PaymentTokenDetails;
    /**
     * 
     * @type {TransactionOrigin}
     * @memberof TransactionResponse
     */
    transactionOrigin?: TransactionOrigin;
    /**
     * 
     * @type {PaymentMethodDetails}
     * @memberof TransactionResponse
     */
    paymentMethodDetails?: PaymentMethodDetails;
    /**
     * Country of the card issuer.
     * @type {string}
     * @memberof TransactionResponse
     */
    country?: string;
    /**
     * The terminal that is processing the transaction.
     * @type {string}
     * @memberof TransactionResponse
     */
    terminalId?: string;
    /**
     * The unique (on Acquirer level) mechant ID. Usually this value has been chosen from the merchant itself and will be used in communication with the endpoint.
     * @type {string}
     * @memberof TransactionResponse
     */
    merchantId?: string;
    /**
     * The unique merchant transaction ID from the request header, if supplied.
     * @type {string}
     * @memberof TransactionResponse
     */
    merchantTransactionId?: string;
    /**
     * The transaction time in seconds since epoch.
     * @type {number}
     * @memberof TransactionResponse
     */
    transactionTime?: number;
    /**
     * 
     * @type {Amount}
     * @memberof TransactionResponse
     */
    approvedAmount?: Amount;
    /**
     * Represents the status of a transaction immediately following the original processing request. This value is not stored for the transaction and is only available in the response when the transaction is processed. TransactionStatus is not returned on either the transaction inquiry or on the order inquiry.
     * @type {string}
     * @memberof TransactionResponse
     */
    transactionStatus?: TransactionResponseTransactionStatusEnum;
    /**
     * Shows the state of the current transaction.
     * @type {string}
     * @memberof TransactionResponse
     */
    transactionState?: TransactionResponseTransactionStateEnum;
    /**
     * 
     * @type {Secure3dResponse}
     * @memberof TransactionResponse
     */
    secure3dResponse?: Secure3dResponse;
    /**
     * The endpoint redirection URL.
     * @type {string}
     * @memberof TransactionResponse
     */
    redirectURL?: string;
    /**
     * 
     * @type {Secure3DAuthenticationResponse}
     * @memberof TransactionResponse
     */
    authenticationResponse?: Secure3DAuthenticationResponse;
    /**
     * The transaction ID received from schemes for the initial transaction of card on file flows.
     * @type {string}
     * @memberof TransactionResponse
     */
    schemeTransactionId?: string;
    /**
     * 
     * @type {ProcessorData}
     * @memberof TransactionResponse
     */
    processor?: ProcessorData;
    /**
     * 
     * @type {AdditionalTransactionDetails}
     * @memberof TransactionResponse
     */
    additionalDetails?: AdditionalTransactionDetails;
    /**
     * 
     * @type {AccountUpdaterResponse}
     * @memberof TransactionResponse
     */
    accountUpdaterResponse?: AccountUpdaterResponse;
    /**
     * 
     * @type {AchResponse}
     * @memberof TransactionResponse
     */
    achResponse?: AchResponse;
    /**
     * 
     * @type {CurrencyConversionResponse}
     * @memberof TransactionResponse
     */
    currencyConversionResponse?: CurrencyConversionResponse;
}

/**
    * @export
    * @enum {string}
    */
export enum TransactionResponseTransactionStatusEnum {
    APPROVED = 'APPROVED',
    WAITING = 'WAITING',
    VALIDATIONFAILED = 'VALIDATION_FAILED',
    PROCESSINGFAILED = 'PROCESSING_FAILED',
    DECLINED = 'DECLINED'
}
/**
    * @export
    * @enum {string}
    */
export enum TransactionResponseTransactionStateEnum {
    AUTHORIZED = 'AUTHORIZED',
    CAPTURED = 'CAPTURED',
    DECLINED = 'DECLINED',
    CHECKED = 'CHECKED',
    COMPLETEDGET = 'COMPLETED_GET',
    INITIALIZED = 'INITIALIZED',
    PENDING = 'PENDING',
    READY = 'READY',
    TEMPLATE = 'TEMPLATE',
    SETTLED = 'SETTLED',
    VOIDED = 'VOIDED',
    WAITING = 'WAITING'
}

/**
 * Type of transaction to perform. Primary transaction types in requests include \'SALE\', \'PREAUTH\', \'CREDIT\' and \'FORCED_TICKET\'.
 * @export
 * @enum {string}
 */
export enum TransactionType {
    SALE = 'SALE',
    PREAUTH = 'PREAUTH',
    CREDIT = 'CREDIT',
    FORCEDTICKET = 'FORCED_TICKET',
    VOID = 'VOID',
    RETURN = 'RETURN',
    POSTAUTH = 'POSTAUTH',
    PAYERAUTH = 'PAYER_AUTH',
    DISBURSEMENT = 'DISBURSEMENT'
}

/**
 * Request authentication of the payment card using the UnionPay SMS scheme.
 * @export
 * @interface UnionPayAuthenticationRequest
 */
export interface UnionPayAuthenticationRequest extends AuthenticationRequest {
    /**
     * Mobile number for SMS verification.
     * @type {string}
     * @memberof UnionPayAuthenticationRequest
     */
    smsPhoneNumber: string;
}
/**
 * 
 * @export
 * @interface UnionPayAuthenticationRequestAllOf
 */
export interface UnionPayAuthenticationRequestAllOf {
    /**
     * Mobile number for SMS verification.
     * @type {string}
     * @memberof UnionPayAuthenticationRequestAllOf
     */
    smsPhoneNumber: string;
}
/**
 * Authentication update request specific to UnionPay transactions.
 * @export
 * @interface UnionPayAuthenticationUpdateRequest
 */
export interface UnionPayAuthenticationUpdateRequest extends AuthenticationUpdateRequest {
    /**
     * Customer mobile number for SMS verification.
     * @type {string}
     * @memberof UnionPayAuthenticationUpdateRequest
     */
    smsVerificationCode: string;
    /**
     * Card security code if required by merchant.
     * @type {string}
     * @memberof UnionPayAuthenticationUpdateRequest
     */
    securityCode?: string;
}
/**
 * 
 * @export
 * @interface UnionPayAuthenticationUpdateRequestAllOf
 */
export interface UnionPayAuthenticationUpdateRequestAllOf {
    /**
     * Customer mobile number for SMS verification.
     * @type {string}
     * @memberof UnionPayAuthenticationUpdateRequestAllOf
     */
    smsVerificationCode: string;
    /**
     * Card security code if required by merchant.
     * @type {string}
     * @memberof UnionPayAuthenticationUpdateRequestAllOf
     */
    securityCode?: string;
}
/**
 * Provide an information for email settings.
 * @export
 * @interface UpdateEmailSettingsRequest
 */
export interface UpdateEmailSettingsRequest {
    /**
     * 
     * @type {Array<StoreEmailSettings>}
     * @memberof UpdateEmailSettingsRequest
     */
    stores: Array<StoreEmailSettings>;
}
/**
 * Response from update email settings request.
 * @export
 * @interface UpdateEmailSettingsResponse
 */
export interface UpdateEmailSettingsResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof UpdateEmailSettingsResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof UpdateEmailSettingsResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof UpdateEmailSettingsResponse
     */
    responseType?: ResponseType;
    /**
     * 
     * @type {Array<StoreEmailSettingsResult>}
     * @memberof UpdateEmailSettingsResponse
     */
    stores?: Array<StoreEmailSettingsResult>;
}
/**
 * Provide an information for fraud settings management.
 * @export
 * @interface UpdateFraudSettingsRequest
 */
export interface UpdateFraudSettingsRequest {
    /**
     * 
     * @type {Array<StoreFraudSettings>}
     * @memberof UpdateFraudSettingsRequest
     */
    stores?: Array<StoreFraudSettings>;
}
/**
 * Response from update fraud settings request.
 * @export
 * @interface UpdateFraudSettingsResponse
 */
export interface UpdateFraudSettingsResponse {
    /**
     * Echoes back the value in the request header for tracking.
     * @type {string}
     * @memberof UpdateFraudSettingsResponse
     */
    clientRequestId?: string;
    /**
     * Request identifier in API, can be used to request logs from the support team.
     * @type {string}
     * @memberof UpdateFraudSettingsResponse
     */
    apiTraceId?: string;
    /**
     * 
     * @type {ResponseType}
     * @memberof UpdateFraudSettingsResponse
     */
    responseType?: ResponseType;
    /**
     * 
     * @type {Array<StoreFraudSettingsResult>}
     * @memberof UpdateFraudSettingsResponse
     */
    stores?: Array<StoreFraudSettingsResult>;
}
/**
 * Use this model to Update payment token.
 * @export
 * @interface UpdatePaymentToken
 */
export interface UpdatePaymentToken {
    /**
     * Client-supplied payment token value.
     * @type {string}
     * @memberof UpdatePaymentToken
     */
    value: string;
    /**
     * If the token is reusable.
     * @type {boolean}
     * @memberof UpdatePaymentToken
     */
    reusable?: boolean;
    /**
     * Decline duplicate payment info if client token is supplied.
     * @type {boolean}
     * @memberof UpdatePaymentToken
     */
    declineDuplicates?: boolean;
    /**
     * 
     * @type {PaymentCard}
     * @memberof UpdatePaymentToken
     */
    paymentCard: PaymentCard;
}
/**
 * Payment token usage details.
 * @export
 * @interface UsePaymentToken
 */
export interface UsePaymentToken {
    /**
     * Client-supplied payment token value.
     * @type {string}
     * @memberof UsePaymentToken
     */
    value: string;
    /**
     * The ID of a same store (or) sibling store in a hierarchy for which the token was originally created.
     * @type {string}
     * @memberof UsePaymentToken
     */
    tokenOriginStoreId?: string;
    /**
     * 
     * @type {CardFunction}
     * @memberof UsePaymentToken
     */
    _function?: CardFunction;
    /**
     * Card verification value/number.
     * @type {string}
     * @memberof UsePaymentToken
     */
    securityCode?: string;
    /**
     * 
     * @type {Expiration}
     * @memberof UsePaymentToken
     */
    expiryDate?: Expiration;
}
/**
 * The result of the 3DS (3D Secure) check.
 * @export
 * @interface Verification3ds
 */
export interface Verification3ds {
    /**
     * 3DS response code.
     * @type {string}
     * @memberof Verification3ds
     */
    code: string;
    /**
     * Interpretation of the response code.
     * @type {string}
     * @memberof Verification3ds
     */
    status?: string;
    /**
     * Identifier of the scheme.
     * @type {string}
     * @memberof Verification3ds
     */
    scheme: string;
}
/**
 * The result of the AVS (Address Verification System) check.
 * @export
 * @interface VerificationAvs
 */
export interface VerificationAvs {
    /**
     * AVS response code.
     * @type {string}
     * @memberof VerificationAvs
     */
    code: string;
    /**
     * Interpretation of the response code.
     * @type {string}
     * @memberof VerificationAvs
     */
    status?: string;
    /**
     * Identifier of the scheme.
     * @type {string}
     * @memberof VerificationAvs
     */
    scheme: string;
}
/**
 * The result of the CVV (Card Verification Value, or Card Security Code) check.
 * @export
 * @interface VerificationCvv
 */
export interface VerificationCvv {
    /**
     * CVV response code.
     * @type {string}
     * @memberof VerificationCvv
     */
    code: string;
    /**
     * Interpretation of the response code.
     * @type {string}
     * @memberof VerificationCvv
     */
    status?: string;
    /**
     * Identifier of the scheme.
     * @type {string}
     * @memberof VerificationCvv
     */
    scheme: string;
}
/**
 * Request to perform a void of all authorizations associated with the current order. This request type is applicable for voiding preauth and incremental preauth transactions.
 * @export
 * @interface VoidPreAuthTransactions
 */
export interface VoidPreAuthTransactions extends SecondaryTransaction {
}
/**
 * Request to perform void transaction.
 * @export
 * @interface VoidTransaction
 */
export interface VoidTransaction extends SecondaryTransaction {
}
/**
 * Various wallet payment methods the gateway supports. Abstract class, do not use this class directly, use one of its children: EncryptedApplePayWalletPaymentMethod, EncryptedGooglePayWalletPaymentMethod, EncryptedSamsungPayWalletPaymentMethod, DecryptedApplePayWalletPaymentMethod, DecryptedGooglePayWalletPaymentMethod, DecryptedSamsungPayWalletPaymentMethod, MasterpassWalletPaymentMethod
 * @export
 * @interface WalletPaymentMethod
 */
export interface WalletPaymentMethod {
    /**
     * Type of wallet.
     * @type {string}
     * @memberof WalletPaymentMethod
     */
    walletType: string;
}
/**
 * Request to create preAuth primary transaction using digital wallet.
 * @export
 * @interface WalletPreAuthTransaction
 */
export interface WalletPreAuthTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {WalletPaymentMethod}
     * @memberof WalletPreAuthTransaction
     */
    walletPaymentMethod: WalletPaymentMethod;
    /**
     * 
     * @type {SplitShipment}
     * @memberof WalletPreAuthTransaction
     */
    splitShipment?: SplitShipment;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof WalletPreAuthTransaction
     */
    paymentFacilitator?: PaymentFacilitator;
    /**
     * This flag can only be used in a preAuth transaction that updates the amount of a previous preAuth transaction to either increase the preAuth amount (DecrementalPreAuthFlag = false) or decrease the preAuth amount (DecrementalPreAuthFlag = true).
     * @type {boolean}
     * @memberof WalletPreAuthTransaction
     */
    decrementalFlag?: boolean;
}
/**
 * 
 * @export
 * @interface WalletPreAuthTransactionAllOf
 */
export interface WalletPreAuthTransactionAllOf {
    /**
     * 
     * @type {WalletPaymentMethod}
     * @memberof WalletPreAuthTransactionAllOf
     */
    walletPaymentMethod: WalletPaymentMethod;
    /**
     * 
     * @type {SplitShipment}
     * @memberof WalletPreAuthTransactionAllOf
     */
    splitShipment?: SplitShipment;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof WalletPreAuthTransactionAllOf
     */
    paymentFacilitator?: PaymentFacilitator;
    /**
     * This flag can only be used in a preAuth transaction that updates the amount of a previous preAuth transaction to either increase the preAuth amount (DecrementalPreAuthFlag = false) or decrease the preAuth amount (DecrementalPreAuthFlag = true).
     * @type {boolean}
     * @memberof WalletPreAuthTransactionAllOf
     */
    decrementalFlag?: boolean;
}
/**
 * Request to create sale primary transaction using digital wallet.
 * @export
 * @interface WalletSaleTransaction
 */
export interface WalletSaleTransaction extends PrimaryTransaction {
    /**
     * 
     * @type {WalletPaymentMethod}
     * @memberof WalletSaleTransaction
     */
    walletPaymentMethod: WalletPaymentMethod;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof WalletSaleTransaction
     */
    paymentFacilitator?: PaymentFacilitator;
}
/**
 * 
 * @export
 * @interface WalletSaleTransactionAllOf
 */
export interface WalletSaleTransactionAllOf {
    /**
     * 
     * @type {WalletPaymentMethod}
     * @memberof WalletSaleTransactionAllOf
     */
    walletPaymentMethod: WalletPaymentMethod;
    /**
     * 
     * @type {PaymentFacilitator}
     * @memberof WalletSaleTransactionAllOf
     */
    paymentFacilitator?: PaymentFacilitator;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccessTokenRequest} accessTokenRequest Access token request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accessTokenRequest: AccessTokenRequest, messageSignature?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling authenticationAccessTokensPost.');
            }
            // verify required parameter 'accessTokenRequest' is not null or undefined
            if (accessTokenRequest === null || accessTokenRequest === undefined) {
                throw new RequiredError('accessTokenRequest','Required parameter accessTokenRequest was null or undefined when calling authenticationAccessTokensPost.');
            }
            const localVarPath = `/authentication/access-tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"AccessTokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(accessTokenRequest !== undefined ? accessTokenRequest : {}) : (accessTokenRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccessTokenRequest} accessTokenRequest Access token request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accessTokenRequest: AccessTokenRequest, messageSignature?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse> {
            const localVarAxiosArgs = AuthenticationApiAxiosParamCreator(configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
         * @summary Generate an access token for user authentication.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccessTokenRequest} accessTokenRequest Access token request
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationAccessTokensPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accessTokenRequest: AccessTokenRequest, messageSignature?: string, options?: any) {
            return AuthenticationApiFp(configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options)(axios, basePath);
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
     * @summary Generate an access token for user authentication.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccessTokenRequest} accessTokenRequest Access token request
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authenticationAccessTokensPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accessTokenRequest: AccessTokenRequest, messageSignature?: string, options?: any): AxiosPromise<AccessTokenResponse>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * This is the access token generation call for authorizing subsequent financial transactions. A valid access token is required for web client requests.
     * @summary Generate an access token for user authentication.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccessTokenRequest} accessTokenRequest Access token request
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationAccessTokensPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accessTokenRequest: AccessTokenRequest, messageSignature?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).authenticationAccessTokensPost(contentType, clientRequestId, apiKey, timestamp, accessTokenRequest, messageSignature, options)(this.axios, this.basePath);
    }

}


/**
 * CurrencyConversionApi - axios parameter creator
 * @export
 */
export const CurrencyConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, exchangeRateRequest: ExchangeRateRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling getExchangeRate.');
            }
            // verify required parameter 'exchangeRateRequest' is not null or undefined
            if (exchangeRateRequest === null || exchangeRateRequest === undefined) {
                throw new RequiredError('exchangeRateRequest','Required parameter exchangeRateRequest was null or undefined when calling getExchangeRate.');
            }
            const localVarPath = `/exchange-rates`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"ExchangeRateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(exchangeRateRequest !== undefined ? exchangeRateRequest : {}) : (exchangeRateRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyConversionApi - functional programming interface
 * @export
 */
export const CurrencyConversionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, exchangeRateRequest: ExchangeRateRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeRateResponse> {
            const localVarAxiosArgs = CurrencyConversionApiAxiosParamCreator(configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CurrencyConversionApi - factory interface
 * @export
 */
export const CurrencyConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Sale, return and lookup exchange rate with dynamic currency conversion option.
         * @summary Generate dynamic currency conversion transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRate(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, exchangeRateRequest: ExchangeRateRequest, messageSignature?: string, region?: string, options?: any) {
            return CurrencyConversionApiFp(configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * CurrencyConversionApi - interface
 * @export
 * @interface CurrencyConversionApi
 */
export interface CurrencyConversionApiInterface {
    /**
     * Sale, return and lookup exchange rate with dynamic currency conversion option.
     * @summary Generate dynamic currency conversion transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyConversionApiInterface
     */
    getExchangeRate(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, exchangeRateRequest: ExchangeRateRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<ExchangeRateResponse>;

}

/**
 * CurrencyConversionApi - object-oriented interface
 * @export
 * @class CurrencyConversionApi
 * @extends {BaseAPI}
 */
export class CurrencyConversionApi extends BaseAPI implements CurrencyConversionApiInterface {
    /**
     * Sale, return and lookup exchange rate with dynamic currency conversion option.
     * @summary Generate dynamic currency conversion transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ExchangeRateRequest} exchangeRateRequest Accepted request types: DCCExchangeRateRequest and DynamicPricingExchangeRateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyConversionApi
     */
    public getExchangeRate(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, exchangeRateRequest: ExchangeRateRequest, messageSignature?: string, region?: string, options?: any) {
        return CurrencyConversionApiFp(this.configuration).getExchangeRate(contentType, clientRequestId, apiKey, timestamp, exchangeRateRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

}


/**
 * FraudDetectApi - axios parameter creator
 * @export
 */
export const FraudDetectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, clientRegistration: ClientRegistration, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling fraudClientRegistrationPost.');
            }
            // verify required parameter 'clientRegistration' is not null or undefined
            if (clientRegistration === null || clientRegistration === undefined) {
                throw new RequiredError('clientRegistration','Required parameter clientRegistration was null or undefined when calling fraudClientRegistrationPost.');
            }
            const localVarPath = `/fraud/client-registration`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"ClientRegistration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(clientRegistration !== undefined ? clientRegistration : {}) : (clientRegistration || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentRegistration: PaymentRegistration, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            // verify required parameter 'paymentRegistration' is not null or undefined
            if (paymentRegistration === null || paymentRegistration === undefined) {
                throw new RequiredError('paymentRegistration','Required parameter paymentRegistration was null or undefined when calling fraudPaymentRegistrationPost.');
            }
            const localVarPath = `/fraud/payment-registration`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"PaymentRegistration" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentRegistration !== undefined ? paymentRegistration : {}) : (paymentRegistration || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, scoreOnlyRequest: ScoreOnlyRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling scoreOnly.');
            }
            // verify required parameter 'scoreOnlyRequest' is not null or undefined
            if (scoreOnlyRequest === null || scoreOnlyRequest === undefined) {
                throw new RequiredError('scoreOnlyRequest','Required parameter scoreOnlyRequest was null or undefined when calling scoreOnly.');
            }
            const localVarPath = `/fraud/score-only`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"ScoreOnlyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(scoreOnlyRequest !== undefined ? scoreOnlyRequest : {}) : (scoreOnlyRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FraudDetectApi - functional programming interface
 * @export
 */
export const FraudDetectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, clientRegistration: ClientRegistration, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FraudRegistrationResponse> {
            const localVarAxiosArgs = FraudDetectApiAxiosParamCreator(configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentRegistration: PaymentRegistration, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FraudRegistrationResponse> {
            const localVarAxiosArgs = FraudDetectApiAxiosParamCreator(configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, scoreOnlyRequest: ScoreOnlyRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScoreOnlyResponse> {
            const localVarAxiosArgs = FraudDetectApiAxiosParamCreator(configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FraudDetectApi - factory interface
 * @export
 */
export const FraudDetectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to register client for fraud detect transaction.
         * @summary Client registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ClientRegistration} clientRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudClientRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, clientRegistration: ClientRegistration, messageSignature?: string, region?: string, options?: any) {
            return FraudDetectApiFp(configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to register payment for fraud detect transaction.
         * @summary Payment registration for fraud detect transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentRegistration} paymentRegistration 
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fraudPaymentRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentRegistration: PaymentRegistration, messageSignature?: string, region?: string, options?: any) {
            return FraudDetectApiFp(configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to obtain a fraud score for a transaction.
         * @summary Score a transaction for fraud.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scoreOnly(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, scoreOnlyRequest: ScoreOnlyRequest, messageSignature?: string, region?: string, options?: any) {
            return FraudDetectApiFp(configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * FraudDetectApi - interface
 * @export
 * @interface FraudDetectApi
 */
export interface FraudDetectApiInterface {
    /**
     * Use this to register client for fraud detect transaction.
     * @summary Client registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ClientRegistration} clientRegistration 
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApiInterface
     */
    fraudClientRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, clientRegistration: ClientRegistration, messageSignature?: string, region?: string, options?: any): AxiosPromise<FraudRegistrationResponse>;

    /**
     * Use this to register payment for fraud detect transaction.
     * @summary Payment registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentRegistration} paymentRegistration 
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApiInterface
     */
    fraudPaymentRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentRegistration: PaymentRegistration, messageSignature?: string, region?: string, options?: any): AxiosPromise<FraudRegistrationResponse>;

    /**
     * Use this to obtain a fraud score for a transaction.
     * @summary Score a transaction for fraud.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApiInterface
     */
    scoreOnly(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, scoreOnlyRequest: ScoreOnlyRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<ScoreOnlyResponse>;

}

/**
 * FraudDetectApi - object-oriented interface
 * @export
 * @class FraudDetectApi
 * @extends {BaseAPI}
 */
export class FraudDetectApi extends BaseAPI implements FraudDetectApiInterface {
    /**
     * Use this to register client for fraud detect transaction.
     * @summary Client registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ClientRegistration} clientRegistration 
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    public fraudClientRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, clientRegistration: ClientRegistration, messageSignature?: string, region?: string, options?: any) {
        return FraudDetectApiFp(this.configuration).fraudClientRegistrationPost(contentType, clientRequestId, apiKey, timestamp, clientRegistration, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to register payment for fraud detect transaction.
     * @summary Payment registration for fraud detect transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentRegistration} paymentRegistration 
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    public fraudPaymentRegistrationPost(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentRegistration: PaymentRegistration, messageSignature?: string, region?: string, options?: any) {
        return FraudDetectApiFp(this.configuration).fraudPaymentRegistrationPost(contentType, clientRequestId, apiKey, timestamp, paymentRegistration, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to obtain a fraud score for a transaction.
     * @summary Score a transaction for fraud.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {ScoreOnlyRequest} scoreOnlyRequest Accepted request type: ScoreOnlyRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FraudDetectApi
     */
    public scoreOnly(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, scoreOnlyRequest: ScoreOnlyRequest, messageSignature?: string, region?: string, options?: any) {
        return FraudDetectApiFp(this.configuration).scoreOnly(contentType, clientRequestId, apiKey, timestamp, scoreOnlyRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

}


/**
 * InformationLookupApi - axios parameter creator
 * @export
 */
export const InformationLookupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardInfoLookupRequest: CardInfoLookupRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling cardInfoLookup.');
            }
            // verify required parameter 'cardInfoLookupRequest' is not null or undefined
            if (cardInfoLookupRequest === null || cardInfoLookupRequest === undefined) {
                throw new RequiredError('cardInfoLookupRequest','Required parameter cardInfoLookupRequest was null or undefined when calling cardInfoLookup.');
            }
            const localVarPath = `/card-information`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"CardInfoLookupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cardInfoLookupRequest !== undefined ? cardInfoLookupRequest : {}) : (cardInfoLookupRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to look up card related information associated with a payment card or payment token.
         * @summary Account information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountInfoLookupRequest} accountInfoLookupRequest Accepted request type: PaymentCardInfoLookupRequest and PaymentTokenInfoLookupRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccount(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accountInfoLookupRequest: AccountInfoLookupRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling lookupAccount.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling lookupAccount.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling lookupAccount.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling lookupAccount.');
            }
            // verify required parameter 'accountInfoLookupRequest' is not null or undefined
            if (accountInfoLookupRequest === null || accountInfoLookupRequest === undefined) {
                throw new RequiredError('accountInfoLookupRequest','Required parameter accountInfoLookupRequest was null or undefined when calling lookupAccount.');
            }
            const localVarPath = `/account-information`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"AccountInfoLookupRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(accountInfoLookupRequest !== undefined ? accountInfoLookupRequest : {}) : (accountInfoLookupRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InformationLookupApi - functional programming interface
 * @export
 */
export const InformationLookupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardInfoLookupRequest: CardInfoLookupRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardInfoLookupResponse> {
            const localVarAxiosArgs = InformationLookupApiAxiosParamCreator(configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to look up card related information associated with a payment card or payment token.
         * @summary Account information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountInfoLookupRequest} accountInfoLookupRequest Accepted request type: PaymentCardInfoLookupRequest and PaymentTokenInfoLookupRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccount(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accountInfoLookupRequest: AccountInfoLookupRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardInfoLookupResponse> {
            const localVarAxiosArgs = InformationLookupApiAxiosParamCreator(configuration).lookupAccount(contentType, clientRequestId, apiKey, timestamp, accountInfoLookupRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InformationLookupApi - factory interface
 * @export
 */
export const InformationLookupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to look up card related information such as issuer country, card function and card brand.
         * @summary Card information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cardInfoLookup(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardInfoLookupRequest: CardInfoLookupRequest, messageSignature?: string, region?: string, options?: any) {
            return InformationLookupApiFp(configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to look up card related information associated with a payment card or payment token.
         * @summary Account information lookup.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountInfoLookupRequest} accountInfoLookupRequest Accepted request type: PaymentCardInfoLookupRequest and PaymentTokenInfoLookupRequest
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupAccount(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accountInfoLookupRequest: AccountInfoLookupRequest, messageSignature?: string, region?: string, options?: any) {
            return InformationLookupApiFp(configuration).lookupAccount(contentType, clientRequestId, apiKey, timestamp, accountInfoLookupRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * InformationLookupApi - interface
 * @export
 * @interface InformationLookupApi
 */
export interface InformationLookupApiInterface {
    /**
     * Use this to look up card related information such as issuer country, card function and card brand.
     * @summary Card information lookup.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationLookupApiInterface
     */
    cardInfoLookup(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardInfoLookupRequest: CardInfoLookupRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<CardInfoLookupResponse>;

    /**
     * Use this to look up card related information associated with a payment card or payment token.
     * @summary Account information lookup.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccountInfoLookupRequest} accountInfoLookupRequest Accepted request type: PaymentCardInfoLookupRequest and PaymentTokenInfoLookupRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationLookupApiInterface
     */
    lookupAccount(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accountInfoLookupRequest: AccountInfoLookupRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<CardInfoLookupResponse>;

}

/**
 * InformationLookupApi - object-oriented interface
 * @export
 * @class InformationLookupApi
 * @extends {BaseAPI}
 */
export class InformationLookupApi extends BaseAPI implements InformationLookupApiInterface {
    /**
     * Use this to look up card related information such as issuer country, card function and card brand.
     * @summary Card information lookup.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardInfoLookupRequest} cardInfoLookupRequest Accepted request type: CardInfoLookupRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationLookupApi
     */
    public cardInfoLookup(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardInfoLookupRequest: CardInfoLookupRequest, messageSignature?: string, region?: string, options?: any) {
        return InformationLookupApiFp(this.configuration).cardInfoLookup(contentType, clientRequestId, apiKey, timestamp, cardInfoLookupRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to look up card related information associated with a payment card or payment token.
     * @summary Account information lookup.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccountInfoLookupRequest} accountInfoLookupRequest Accepted request type: PaymentCardInfoLookupRequest and PaymentTokenInfoLookupRequest
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InformationLookupApi
     */
    public lookupAccount(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accountInfoLookupRequest: AccountInfoLookupRequest, messageSignature?: string, region?: string, options?: any) {
        return InformationLookupApiFp(this.configuration).lookupAccount(contentType, clientRequestId, apiKey, timestamp, accountInfoLookupRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

}


/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling orderInquiry.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling orderInquiry.');
            }
            const localVarPath = `/orders/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new RequiredError('secondaryTransaction','Required parameter secondaryTransaction was null or undefined when calling submitSecondaryTransactionFromOrder.');
            }
            const localVarPath = `/orders/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(secondaryTransaction !== undefined ? secondaryTransaction : {}) : (secondaryTransaction || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = OrderApiAxiosParamCreator(configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this query to get the current state of an existing order.
         * @summary Retrieve the state of an order.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
            return OrderApiFp(configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
         * @summary Perform return or postAuth secondary transactions.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransactionFromOrder(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, options?: any) {
            return OrderApiFp(configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * OrderApi - interface
 * @export
 * @interface OrderApi
 */
export interface OrderApiInterface {
    /**
     * Use this query to get the current state of an existing order.
     * @summary Retrieve the state of an order.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    orderInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): AxiosPromise<OrderResponse>;

    /**
     * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
     * @summary Perform return or postAuth secondary transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApiInterface
     */
    submitSecondaryTransactionFromOrder(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, options?: any): AxiosPromise<TransactionResponse>;

}

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI implements OrderApiInterface {
    /**
     * Use this query to get the current state of an existing order.
     * @summary Retrieve the state of an order.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
        return OrderApiFp(this.configuration).orderInquiry(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Use this to perform a postAuth or return secondary transaction using order ID. Partial postAuths and returns are allowed.
     * @summary Perform return or postAuth secondary transactions.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public submitSecondaryTransactionFromOrder(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, options?: any) {
        return OrderApiFp(this.configuration).submitSecondaryTransactionFromOrder(contentType, clientRequestId, apiKey, timestamp, orderId, secondaryTransaction, messageSignature, region, options)(this.axios, this.basePath);
    }

}


/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, authenticationUpdateRequest: AuthenticationUpdateRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling finalizeSecureTransaction.');
            }
            // verify required parameter 'authenticationUpdateRequest' is not null or undefined
            if (authenticationUpdateRequest === null || authenticationUpdateRequest === undefined) {
                throw new RequiredError('authenticationUpdateRequest','Required parameter authenticationUpdateRequest was null or undefined when calling finalizeSecureTransaction.');
            }
            const localVarPath = `/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"AuthenticationUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(authenticationUpdateRequest !== undefined ? authenticationUpdateRequest : {}) : (authenticationUpdateRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction, AchPreAuthTransaction, AchSaleTransaction, AchCreditTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, primaryTransaction: PrimaryTransaction, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling submitPrimaryTransaction.');
            }
            // verify required parameter 'primaryTransaction' is not null or undefined
            if (primaryTransaction === null || primaryTransaction === undefined) {
                throw new RequiredError('primaryTransaction','Required parameter primaryTransaction was null or undefined when calling submitPrimaryTransaction.');
            }
            const localVarPath = `/payments`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"PrimaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(primaryTransaction !== undefined ? primaryTransaction : {}) : (primaryTransaction || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling submitSecondaryTransaction.');
            }
            // verify required parameter 'secondaryTransaction' is not null or undefined
            if (secondaryTransaction === null || secondaryTransaction === undefined) {
                throw new RequiredError('secondaryTransaction','Required parameter secondaryTransaction was null or undefined when calling submitSecondaryTransaction.');
            }
            const localVarPath = `/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"SecondaryTransaction" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(secondaryTransaction !== undefined ? secondaryTransaction : {}) : (secondaryTransaction || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, messageSignature?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling transactionInquiry.');
            }
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling transactionInquiry.');
            }
            const localVarPath = `/payments/{transaction-id}`
                .replace(`{${"transaction-id"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, authenticationUpdateRequest: AuthenticationUpdateRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = PaymentApiAxiosParamCreator(configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction, AchPreAuthTransaction, AchSaleTransaction, AchCreditTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, primaryTransaction: PrimaryTransaction, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = PaymentApiAxiosParamCreator(configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = PaymentApiAxiosParamCreator(configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = PaymentApiAxiosParamCreator(configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
         * @summary Update a 3DSecure or UnionPay payment and continue processing.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeSecureTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, authenticationUpdateRequest: AuthenticationUpdateRequest, messageSignature?: string, region?: string, options?: any) {
            return PaymentApiFp(configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to originate a financial transaction like a sale, preauthorization, or credit.
         * @summary Generate a primary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction, AchPreAuthTransaction, AchSaleTransaction, AchCreditTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitPrimaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, primaryTransaction: PrimaryTransaction, messageSignature?: string, region?: string, options?: any) {
            return PaymentApiFp(configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
         * @summary Perform a secondary transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSecondaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, storeId?: string, options?: any) {
            return PaymentApiFp(configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this query to get the current state of an existing transaction.
         * @summary Retrieve the state of a transaction.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
            return PaymentApiFp(configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(axios, basePath);
        },
    };
};

/**
 * PaymentApi - interface
 * @export
 * @interface PaymentApi
 */
export interface PaymentApiInterface {
    /**
     * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
     * @summary Update a 3DSecure or UnionPay payment and continue processing.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    finalizeSecureTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, authenticationUpdateRequest: AuthenticationUpdateRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<TransactionResponse>;

    /**
     * Use this to originate a financial transaction like a sale, preauthorization, or credit.
     * @summary Generate a primary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction, AchPreAuthTransaction, AchSaleTransaction, AchCreditTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    submitPrimaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, primaryTransaction: PrimaryTransaction, messageSignature?: string, region?: string, options?: any): AxiosPromise<TransactionResponse>;

    /**
     * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
     * @summary Perform a secondary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    submitSecondaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, storeId?: string, options?: any): AxiosPromise<TransactionResponse>;

    /**
     * Use this query to get the current state of an existing transaction.
     * @summary Retrieve the state of a transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApiInterface
     */
    transactionInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): AxiosPromise<TransactionResponse>;

}

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI implements PaymentApiInterface {
    /**
     * Use this to handle a 3DSecure redirect response or UnionPay authentication, updating the transaction and continuing processing.
     * @summary Update a 3DSecure or UnionPay payment and continue processing.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {AuthenticationUpdateRequest} authenticationUpdateRequest Accepted request types: Secure3D10AuthenticationUpdateRequest, Secure3D21AuthenticationUpdateRequest, and UnionPayAuthenticationUpdateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public finalizeSecureTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, authenticationUpdateRequest: AuthenticationUpdateRequest, messageSignature?: string, region?: string, options?: any) {
        return PaymentApiFp(this.configuration).finalizeSecureTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, authenticationUpdateRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to originate a financial transaction like a sale, preauthorization, or credit.
     * @summary Generate a primary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PrimaryTransaction} primaryTransaction Accepted request types: AliPaySaleTransaction, ChinaPnRSaleTransaction, PaymentCardCreditTransaction, PaymentCardForcedTicketTransaction, PaymentCardSaleTransaction, PaymentCardPreAuthTransaction, PaymentCardPayerAuthTransaction, PaymentCardDisbursementTransaction, PaymentTokenCreditTransaction, PaymentTokenPreAuthTransaction, PaymentTokenSaleTransaction, PaymentTokenDisbursementTransaction, PaypalCreditTransaction, SepaSaleTransaction, WalletSaleTransaction, and WalletPreAuthTransaction, PaymentDeviceSaleTransaction, PaymentDevicePreAuthTransaction, PaymentDeviceCreditTransaction, PaymentDeviceDisbursementTransaction, AchPreAuthTransaction, AchSaleTransaction, AchCreditTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public submitPrimaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, primaryTransaction: PrimaryTransaction, messageSignature?: string, region?: string, options?: any) {
        return PaymentApiFp(this.configuration).submitPrimaryTransaction(contentType, clientRequestId, apiKey, timestamp, primaryTransaction, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to perform a void, postAuth or return secondary transaction. Partial postAuths and returns are allowed.
     * @summary Perform a secondary transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {SecondaryTransaction} secondaryTransaction Accepted request types: PostAuthTransaction, VoidTransaction, VoidPreAuthTransactions, ReturnTransaction, AchPostAuthTransaction, AchVoidTransaction and AchReturnTransaction.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public submitSecondaryTransaction(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, secondaryTransaction: SecondaryTransaction, messageSignature?: string, region?: string, storeId?: string, options?: any) {
        return PaymentApiFp(this.configuration).submitSecondaryTransaction(contentType, clientRequestId, apiKey, timestamp, transactionId, secondaryTransaction, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Use this query to get the current state of an existing transaction.
     * @summary Retrieve the state of a transaction.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} transactionId Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public transactionInquiry(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, transactionId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
        return PaymentApiFp(this.configuration).transactionInquiry(contentType, clientRequestId, apiKey, timestamp, transactionId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }

}


/**
 * PaymentSchedulesApi - axios parameter creator
 * @export
 */
export const PaymentSchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling cancelPaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling cancelPaymentSchedule.');
            }
            const localVarPath = `/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling createPaymentSchedule.');
            }
            // verify required parameter 'paymentSchedulesRequest' is not null or undefined
            if (paymentSchedulesRequest === null || paymentSchedulesRequest === undefined) {
                throw new RequiredError('paymentSchedulesRequest','Required parameter paymentSchedulesRequest was null or undefined when calling createPaymentSchedule.');
            }
            const localVarPath = `/payment-schedules`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"PaymentSchedulesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentSchedulesRequest !== undefined ? paymentSchedulesRequest : {}) : (paymentSchedulesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling inquiryPaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling inquiryPaymentSchedule.');
            }
            const localVarPath = `/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updatePaymentSchedule.');
            }
            // verify required parameter 'paymentSchedulesRequest' is not null or undefined
            if (paymentSchedulesRequest === null || paymentSchedulesRequest === undefined) {
                throw new RequiredError('paymentSchedulesRequest','Required parameter paymentSchedulesRequest was null or undefined when calling updatePaymentSchedule.');
            }
            const localVarPath = `/payment-schedules/{order-id}`
                .replace(`{${"order-id"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"PaymentSchedulesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentSchedulesRequest !== undefined ? paymentSchedulesRequest : {}) : (paymentSchedulesRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentSchedulesApi - functional programming interface
 * @export
 */
export const PaymentSchedulesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSchedulesResponse> {
            const localVarAxiosArgs = PaymentSchedulesApiAxiosParamCreator(configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSchedulesResponse> {
            const localVarAxiosArgs = PaymentSchedulesApiAxiosParamCreator(configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecurringPaymentDetailsResponse> {
            const localVarAxiosArgs = PaymentSchedulesApiAxiosParamCreator(configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSchedulesResponse> {
            const localVarAxiosArgs = PaymentSchedulesApiAxiosParamCreator(configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentSchedulesApi - factory interface
 * @export
 */
export const PaymentSchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to cancel an existing gateway payment schedule.
         * @summary Cancel a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
            return PaymentSchedulesApiFp(configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to create a gateway payment schedule.
         * @summary Create gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any) {
            return PaymentSchedulesApiFp(configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to view an existing gateway payment schedule.
         * @summary View a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inquiryPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
            return PaymentSchedulesApiFp(configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this to update a gateway payment schedule.
         * @summary Update a gateway payment schedule.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
         * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any) {
            return PaymentSchedulesApiFp(configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * PaymentSchedulesApi - interface
 * @export
 * @interface PaymentSchedulesApi
 */
export interface PaymentSchedulesApiInterface {
    /**
     * Use this to cancel an existing gateway payment schedule.
     * @summary Cancel a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApiInterface
     */
    cancelPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): AxiosPromise<PaymentSchedulesResponse>;

    /**
     * Use this to create a gateway payment schedule.
     * @summary Create gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApiInterface
     */
    createPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<PaymentSchedulesResponse>;

    /**
     * Use this to view an existing gateway payment schedule.
     * @summary View a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApiInterface
     */
    inquiryPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any): AxiosPromise<RecurringPaymentDetailsResponse>;

    /**
     * Use this to update a gateway payment schedule.
     * @summary Update a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApiInterface
     */
    updatePaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<PaymentSchedulesResponse>;

}

/**
 * PaymentSchedulesApi - object-oriented interface
 * @export
 * @class PaymentSchedulesApi
 * @extends {BaseAPI}
 */
export class PaymentSchedulesApi extends BaseAPI implements PaymentSchedulesApiInterface {
    /**
     * Use this to cancel an existing gateway payment schedule.
     * @summary Cancel a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    public cancelPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
        return PaymentSchedulesApiFp(this.configuration).cancelPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Use this to create a gateway payment schedule.
     * @summary Create gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    public createPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any) {
        return PaymentSchedulesApiFp(this.configuration).createPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, paymentSchedulesRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to view an existing gateway payment schedule.
     * @summary View a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    public inquiryPaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, messageSignature?: string, region?: string, storeId?: string, options?: any) {
        return PaymentSchedulesApiFp(this.configuration).inquiryPaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, messageSignature, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Use this to update a gateway payment schedule.
     * @summary Update a gateway payment schedule.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} orderId Gateway order identifier as returned in the parameter orderId.
     * @param {PaymentSchedulesRequest} paymentSchedulesRequest Accepted request types: PaymentMethodPaymentSchedulesRequest and ReferencedOrderPaymentSchedulesRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentSchedulesApi
     */
    public updatePaymentSchedule(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, orderId: string, paymentSchedulesRequest: PaymentSchedulesRequest, messageSignature?: string, region?: string, options?: any) {
        return PaymentSchedulesApiFp(this.configuration).updatePaymentSchedule(contentType, clientRequestId, apiKey, timestamp, orderId, paymentSchedulesRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

}


/**
 * PaymentTokenApi - axios parameter creator
 * @export
 */
export const PaymentTokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentTokenizationRequest: PaymentTokenizationRequest, messageSignature?: string, authorization?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling createPaymentToken.');
            }
            // verify required parameter 'paymentTokenizationRequest' is not null or undefined
            if (paymentTokenizationRequest === null || paymentTokenizationRequest === undefined) {
                throw new RequiredError('paymentTokenizationRequest','Required parameter paymentTokenizationRequest was null or undefined when calling createPaymentToken.');
            }
            const localVarPath = `/payment-tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"PaymentTokenizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentTokenizationRequest !== undefined ? paymentTokenizationRequest : {}) : (paymentTokenizationRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling deletePaymentToken.');
            }
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling deletePaymentToken.');
            }
            const localVarPath = `/payment-tokens/{token-id}`
                .replace(`{${"token-id"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payment card details associated with token.
         * @summary Get payment card details associated with token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTokenDetails(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling getPaymentTokenDetails.');
            }
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling getPaymentTokenDetails.');
            }
            const localVarPath = `/payment-tokens/{token-id}`
                .replace(`{${"token-id"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this update one or more payment tokens.
         * @summary Update one or more payment tokens.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentCardPaymentTokenUpdateRequest} paymentCardPaymentTokenUpdateRequest Accepted request type: PaymentCardPaymentTokenUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentCardPaymentTokenUpdateRequest: PaymentCardPaymentTokenUpdateRequest, messageSignature?: string, authorization?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling updatePaymentToken.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling updatePaymentToken.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling updatePaymentToken.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling updatePaymentToken.');
            }
            // verify required parameter 'paymentCardPaymentTokenUpdateRequest' is not null or undefined
            if (paymentCardPaymentTokenUpdateRequest === null || paymentCardPaymentTokenUpdateRequest === undefined) {
                throw new RequiredError('paymentCardPaymentTokenUpdateRequest','Required parameter paymentCardPaymentTokenUpdateRequest was null or undefined when calling updatePaymentToken.');
            }
            const localVarPath = `/payment-tokens`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (authorization !== undefined && authorization !== null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"PaymentCardPaymentTokenUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentCardPaymentTokenUpdateRequest !== undefined ? paymentCardPaymentTokenUpdateRequest : {}) : (paymentCardPaymentTokenUpdateRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentTokenApi - functional programming interface
 * @export
 */
export const PaymentTokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentTokenizationRequest: PaymentTokenizationRequest, messageSignature?: string, authorization?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTokenizationResponse> {
            const localVarAxiosArgs = PaymentTokenApiAxiosParamCreator(configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTokenizationResponse> {
            const localVarAxiosArgs = PaymentTokenApiAxiosParamCreator(configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get payment card details associated with token.
         * @summary Get payment card details associated with token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTokenDetails(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTokenizationResponse> {
            const localVarAxiosArgs = PaymentTokenApiAxiosParamCreator(configuration).getPaymentTokenDetails(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this update one or more payment tokens.
         * @summary Update one or more payment tokens.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentCardPaymentTokenUpdateRequest} paymentCardPaymentTokenUpdateRequest Accepted request type: PaymentCardPaymentTokenUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentCardPaymentTokenUpdateRequest: PaymentCardPaymentTokenUpdateRequest, messageSignature?: string, authorization?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTokenUpdateResponse> {
            const localVarAxiosArgs = PaymentTokenApiAxiosParamCreator(configuration).updatePaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentCardPaymentTokenUpdateRequest, messageSignature, authorization, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentTokenApi - factory interface
 * @export
 */
export const PaymentTokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to create a payment token from a payment card.
         * @summary Create a payment token from a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentTokenizationRequest: PaymentTokenizationRequest, messageSignature?: string, authorization?: string, region?: string, options?: any) {
            return PaymentTokenApiFp(configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options)(axios, basePath);
        },
        /**
         * Use this to delete a payment token.
         * @summary Delete a payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any) {
            return PaymentTokenApiFp(configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(axios, basePath);
        },
        /**
         * Get payment card details associated with token.
         * @summary Get payment card details associated with token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} tokenId Identifies a payment token.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTokenDetails(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any) {
            return PaymentTokenApiFp(configuration).getPaymentTokenDetails(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(axios, basePath);
        },
        /**
         * Use this update one or more payment tokens.
         * @summary Update one or more payment tokens.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentCardPaymentTokenUpdateRequest} paymentCardPaymentTokenUpdateRequest Accepted request type: PaymentCardPaymentTokenUpdateRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentCardPaymentTokenUpdateRequest: PaymentCardPaymentTokenUpdateRequest, messageSignature?: string, authorization?: string, region?: string, options?: any) {
            return PaymentTokenApiFp(configuration).updatePaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentCardPaymentTokenUpdateRequest, messageSignature, authorization, region, options)(axios, basePath);
        },
    };
};

/**
 * PaymentTokenApi - interface
 * @export
 * @interface PaymentTokenApi
 */
export interface PaymentTokenApiInterface {
    /**
     * Use this to create a payment token from a payment card.
     * @summary Create a payment token from a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApiInterface
     */
    createPaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentTokenizationRequest: PaymentTokenizationRequest, messageSignature?: string, authorization?: string, region?: string, options?: any): AxiosPromise<PaymentTokenizationResponse>;

    /**
     * Use this to delete a payment token.
     * @summary Delete a payment token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApiInterface
     */
    deletePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any): AxiosPromise<PaymentTokenizationResponse>;

    /**
     * Get payment card details associated with token.
     * @summary Get payment card details associated with token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApiInterface
     */
    getPaymentTokenDetails(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any): AxiosPromise<PaymentTokenizationResponse>;

    /**
     * Use this update one or more payment tokens.
     * @summary Update one or more payment tokens.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentCardPaymentTokenUpdateRequest} paymentCardPaymentTokenUpdateRequest Accepted request type: PaymentCardPaymentTokenUpdateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApiInterface
     */
    updatePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentCardPaymentTokenUpdateRequest: PaymentCardPaymentTokenUpdateRequest, messageSignature?: string, authorization?: string, region?: string, options?: any): AxiosPromise<PaymentTokenUpdateResponse>;

}

/**
 * PaymentTokenApi - object-oriented interface
 * @export
 * @class PaymentTokenApi
 * @extends {BaseAPI}
 */
export class PaymentTokenApi extends BaseAPI implements PaymentTokenApiInterface {
    /**
     * Use this to create a payment token from a payment card.
     * @summary Create a payment token from a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentTokenizationRequest} paymentTokenizationRequest Accepted request types: PaymentCardPaymentTokenizationRequest, PaymentDevicePaymentTokenizationRequest, and ReferencedOrderPaymentTokenizationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    public createPaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentTokenizationRequest: PaymentTokenizationRequest, messageSignature?: string, authorization?: string, region?: string, options?: any) {
        return PaymentTokenApiFp(this.configuration).createPaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentTokenizationRequest, messageSignature, authorization, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to delete a payment token.
     * @summary Delete a payment token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    public deletePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any) {
        return PaymentTokenApiFp(this.configuration).deletePaymentToken(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Get payment card details associated with token.
     * @summary Get payment card details associated with token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} tokenId Identifies a payment token.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    public getPaymentTokenDetails(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, tokenId: string, messageSignature?: string, authorization?: string, region?: string, storeId?: string, options?: any) {
        return PaymentTokenApiFp(this.configuration).getPaymentTokenDetails(contentType, clientRequestId, apiKey, timestamp, tokenId, messageSignature, authorization, region, storeId, options)(this.axios, this.basePath);
    }

    /**
     * Use this update one or more payment tokens.
     * @summary Update one or more payment tokens.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentCardPaymentTokenUpdateRequest} paymentCardPaymentTokenUpdateRequest Accepted request type: PaymentCardPaymentTokenUpdateRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [authorization] The access token previously generated with the access-tokens call. Use the format \&#39;Bearer {access-token}\&#39;.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokenApi
     */
    public updatePaymentToken(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentCardPaymentTokenUpdateRequest: PaymentCardPaymentTokenUpdateRequest, messageSignature?: string, authorization?: string, region?: string, options?: any) {
        return PaymentTokenApiFp(this.configuration).updatePaymentToken(contentType, clientRequestId, apiKey, timestamp, paymentCardPaymentTokenUpdateRequest, messageSignature, authorization, region, options)(this.axios, this.basePath);
    }

}


/**
 * PaymentURLApi - axios parameter creator
 * @export
 */
export const PaymentURLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentUrlRequest: PaymentUrlRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling createPaymentUrl.');
            }
            // verify required parameter 'paymentUrlRequest' is not null or undefined
            if (paymentUrlRequest === null || paymentUrlRequest === undefined) {
                throw new RequiredError('paymentUrlRequest','Required parameter paymentUrlRequest was null or undefined when calling createPaymentUrl.');
            }
            const localVarPath = `/payment-url`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"PaymentUrlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(paymentUrlRequest !== undefined ? paymentUrlRequest : {}) : (paymentUrlRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, messageSignature?: string, region?: string, storeId?: string, transactionId?: string, orderId?: string, paymentUrlId?: string, transactionTime?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling deletePaymentUrl.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling deletePaymentUrl.');
            }
            const localVarPath = `/payment-url`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (transactionId !== undefined) {
                localVarQueryParameter['transactionId'] = transactionId;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (paymentUrlId !== undefined) {
                localVarQueryParameter['paymentUrlId'] = paymentUrlId;
            }

            if (transactionTime !== undefined) {
                localVarQueryParameter['transactionTime'] = transactionTime;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, fromDate: string, toDate: string, messageSignature?: string, region?: string, storeId?: string, orderId?: string, merchantTransactionId?: string, status?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'fromDate' is not null or undefined
            if (fromDate === null || fromDate === undefined) {
                throw new RequiredError('fromDate','Required parameter fromDate was null or undefined when calling paymentUrlDetail.');
            }
            // verify required parameter 'toDate' is not null or undefined
            if (toDate === null || toDate === undefined) {
                throw new RequiredError('toDate','Required parameter toDate was null or undefined when calling paymentUrlDetail.');
            }
            const localVarPath = `/payment-url`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (merchantTransactionId !== undefined) {
                localVarQueryParameter['merchantTransactionId'] = merchantTransactionId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentURLApi - functional programming interface
 * @export
 */
export const PaymentURLApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentUrlRequest: PaymentUrlRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUrlResponse> {
            const localVarAxiosArgs = PaymentURLApiAxiosParamCreator(configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, messageSignature?: string, region?: string, storeId?: string, transactionId?: string, orderId?: string, paymentUrlId?: string, transactionTime?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUrlResponse> {
            const localVarAxiosArgs = PaymentURLApiAxiosParamCreator(configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, fromDate: string, toDate: string, messageSignature?: string, region?: string, storeId?: string, orderId?: string, merchantTransactionId?: string, status?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentUrlDetailResponse> {
            const localVarAxiosArgs = PaymentURLApiAxiosParamCreator(configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentURLApi - factory interface
 * @export
 */
export const PaymentURLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to generate an embedding payment link.
         * @summary Create a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentUrlRequest: PaymentUrlRequest, messageSignature?: string, region?: string, options?: any) {
            return PaymentURLApiFp(configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to delete an embedding payment link.
         * @summary Delete a payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [paymentUrlId] The ID code from the payment URL.
         * @param {string} [transactionTime] The transaction time in seconds since epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, messageSignature?: string, region?: string, storeId?: string, transactionId?: string, orderId?: string, paymentUrlId?: string, transactionTime?: string, options?: any) {
            return PaymentURLApiFp(configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options)(axios, basePath);
        },
        /**
         * Use this query to get the current state of an existing paymentURL.
         * @summary Retrieve the state of payment URL.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {string} fromDate The start date for payment URL in seconds since epoch.
         * @param {string} toDate The end date for payment URL search query in seconds since epoch.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
         * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
         * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
         * @param {string} [status] The status of payment URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentUrlDetail(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, fromDate: string, toDate: string, messageSignature?: string, region?: string, storeId?: string, orderId?: string, merchantTransactionId?: string, status?: string, options?: any) {
            return PaymentURLApiFp(configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options)(axios, basePath);
        },
    };
};

/**
 * PaymentURLApi - interface
 * @export
 * @interface PaymentURLApi
 */
export interface PaymentURLApiInterface {
    /**
     * Use this to generate an embedding payment link.
     * @summary Create a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApiInterface
     */
    createPaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentUrlRequest: PaymentUrlRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<PaymentUrlResponse>;

    /**
     * Use this to delete an embedding payment link.
     * @summary Delete a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [paymentUrlId] The ID code from the payment URL.
     * @param {string} [transactionTime] The transaction time in seconds since epoch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApiInterface
     */
    deletePaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, messageSignature?: string, region?: string, storeId?: string, transactionId?: string, orderId?: string, paymentUrlId?: string, transactionTime?: string, options?: any): AxiosPromise<PaymentUrlResponse>;

    /**
     * Use this query to get the current state of an existing paymentURL.
     * @summary Retrieve the state of payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} fromDate The start date for payment URL in seconds since epoch.
     * @param {string} toDate The end date for payment URL search query in seconds since epoch.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
     * @param {string} [status] The status of payment URL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApiInterface
     */
    paymentUrlDetail(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, fromDate: string, toDate: string, messageSignature?: string, region?: string, storeId?: string, orderId?: string, merchantTransactionId?: string, status?: string, options?: any): AxiosPromise<PaymentUrlDetailResponse>;

}

/**
 * PaymentURLApi - object-oriented interface
 * @export
 * @class PaymentURLApi
 * @extends {BaseAPI}
 */
export class PaymentURLApi extends BaseAPI implements PaymentURLApiInterface {
    /**
     * Use this to generate an embedding payment link.
     * @summary Create a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {PaymentUrlRequest} paymentUrlRequest Accepted request type: PaymentUrlRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    public createPaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, paymentUrlRequest: PaymentUrlRequest, messageSignature?: string, region?: string, options?: any) {
        return PaymentURLApiFp(this.configuration).createPaymentUrl(contentType, clientRequestId, apiKey, timestamp, paymentUrlRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to delete an embedding payment link.
     * @summary Delete a payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [transactionId] Gateway transaction identifier as returned in the parameter ipgTransactionId or merchantTransactionId.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [paymentUrlId] The ID code from the payment URL.
     * @param {string} [transactionTime] The transaction time in seconds since epoch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    public deletePaymentUrl(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, messageSignature?: string, region?: string, storeId?: string, transactionId?: string, orderId?: string, paymentUrlId?: string, transactionTime?: string, options?: any) {
        return PaymentURLApiFp(this.configuration).deletePaymentUrl(contentType, clientRequestId, apiKey, timestamp, messageSignature, region, storeId, transactionId, orderId, paymentUrlId, transactionTime, options)(this.axios, this.basePath);
    }

    /**
     * Use this query to get the current state of an existing paymentURL.
     * @summary Retrieve the state of payment URL.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {string} fromDate The start date for payment URL in seconds since epoch.
     * @param {string} toDate The end date for payment URL search query in seconds since epoch.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {string} [storeId] An optional outlet ID for clients that support multiple stores in the same developer app.
     * @param {string} [orderId] Gateway order identifier as returned in the parameter orderId.
     * @param {string} [merchantTransactionId] Gateway merchant identifier as returned in the parameter merchantTransactionId.
     * @param {string} [status] The status of payment URL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentURLApi
     */
    public paymentUrlDetail(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, fromDate: string, toDate: string, messageSignature?: string, region?: string, storeId?: string, orderId?: string, merchantTransactionId?: string, status?: string, options?: any) {
        return PaymentURLApiFp(this.configuration).paymentUrlDetail(contentType, clientRequestId, apiKey, timestamp, fromDate, toDate, messageSignature, region, storeId, orderId, merchantTransactionId, status, options)(this.axios, this.basePath);
    }

}


/**
 * VerificationApi - axios parameter creator
 * @export
 */
export const VerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this to perform an account verification for a payment card or payment token.
         * @summary Verify a payment card or payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountVerificationRequest} accountVerificationRequest Accepted request type: PaymentCardVerificationRequest and PaymentTokenVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAccount(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accountVerificationRequest: AccountVerificationRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling verifyAccount.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling verifyAccount.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling verifyAccount.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling verifyAccount.');
            }
            // verify required parameter 'accountVerificationRequest' is not null or undefined
            if (accountVerificationRequest === null || accountVerificationRequest === undefined) {
                throw new RequiredError('accountVerificationRequest','Required parameter accountVerificationRequest was null or undefined when calling verifyAccount.');
            }
            const localVarPath = `/account-verification`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"AccountVerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(accountVerificationRequest !== undefined ? accountVerificationRequest : {}) : (accountVerificationRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this to perform card verification for a payment card. Use the account-verification endpoint instead for this request.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardVerificationRequest: CardVerificationRequest, messageSignature?: string, region?: string, options: any = {}): RequestArgs {
            // verify required parameter 'contentType' is not null or undefined
            if (contentType === null || contentType === undefined) {
                throw new RequiredError('contentType','Required parameter contentType was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'clientRequestId' is not null or undefined
            if (clientRequestId === null || clientRequestId === undefined) {
                throw new RequiredError('clientRequestId','Required parameter clientRequestId was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'apiKey' is not null or undefined
            if (apiKey === null || apiKey === undefined) {
                throw new RequiredError('apiKey','Required parameter apiKey was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'timestamp' is not null or undefined
            if (timestamp === null || timestamp === undefined) {
                throw new RequiredError('timestamp','Required parameter timestamp was null or undefined when calling verifyCard.');
            }
            // verify required parameter 'cardVerificationRequest' is not null or undefined
            if (cardVerificationRequest === null || cardVerificationRequest === undefined) {
                throw new RequiredError('cardVerificationRequest','Required parameter cardVerificationRequest was null or undefined when calling verifyCard.');
            }
            const localVarPath = `/card-verification`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }

            if (clientRequestId !== undefined && clientRequestId !== null) {
                localVarHeaderParameter['Client-Request-Id'] = String(clientRequestId);
            }

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['Api-Key'] = String(apiKey);
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter['Timestamp'] = String(JSON.stringify(timestamp));
            }

            if (messageSignature !== undefined && messageSignature !== null) {
                localVarHeaderParameter['Message-Signature'] = String(messageSignature);
            }

            if (region !== undefined && region !== null) {
                localVarHeaderParameter['Region'] = String(region);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...options.headers};
            const needsSerialization = (<any>"CardVerificationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(cardVerificationRequest !== undefined ? cardVerificationRequest : {}) : (cardVerificationRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this to perform an account verification for a payment card or payment token.
         * @summary Verify a payment card or payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountVerificationRequest} accountVerificationRequest Accepted request type: PaymentCardVerificationRequest and PaymentTokenVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAccount(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accountVerificationRequest: AccountVerificationRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = VerificationApiAxiosParamCreator(configuration).verifyAccount(contentType, clientRequestId, apiKey, timestamp, accountVerificationRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this to perform card verification for a payment card. Use the account-verification endpoint instead for this request.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardVerificationRequest: CardVerificationRequest, messageSignature?: string, region?: string, options?: any): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse> {
            const localVarAxiosArgs = VerificationApiAxiosParamCreator(configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Use this to perform an account verification for a payment card or payment token.
         * @summary Verify a payment card or payment token.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {AccountVerificationRequest} accountVerificationRequest Accepted request type: PaymentCardVerificationRequest and PaymentTokenVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyAccount(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accountVerificationRequest: AccountVerificationRequest, messageSignature?: string, region?: string, options?: any) {
            return VerificationApiFp(configuration).verifyAccount(contentType, clientRequestId, apiKey, timestamp, accountVerificationRequest, messageSignature, region, options)(axios, basePath);
        },
        /**
         * Use this to perform card verification for a payment card. Use the account-verification endpoint instead for this request.
         * @summary Verify a payment card.
         * @param {'application/json'} contentType Content type.
         * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
         * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
         * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
         * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
         * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
         * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCard(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardVerificationRequest: CardVerificationRequest, messageSignature?: string, region?: string, options?: any) {
            return VerificationApiFp(configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options)(axios, basePath);
        },
    };
};

/**
 * VerificationApi - interface
 * @export
 * @interface VerificationApi
 */
export interface VerificationApiInterface {
    /**
     * Use this to perform an account verification for a payment card or payment token.
     * @summary Verify a payment card or payment token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccountVerificationRequest} accountVerificationRequest Accepted request type: PaymentCardVerificationRequest and PaymentTokenVerificationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApiInterface
     */
    verifyAccount(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accountVerificationRequest: AccountVerificationRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<TransactionResponse>;

    /**
     * Use this to perform card verification for a payment card. Use the account-verification endpoint instead for this request.
     * @summary Verify a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApiInterface
     */
    verifyCard(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardVerificationRequest: CardVerificationRequest, messageSignature?: string, region?: string, options?: any): AxiosPromise<TransactionResponse>;

}

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI implements VerificationApiInterface {
    /**
     * Use this to perform an account verification for a payment card or payment token.
     * @summary Verify a payment card or payment token.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {AccountVerificationRequest} accountVerificationRequest Accepted request type: PaymentCardVerificationRequest and PaymentTokenVerificationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verifyAccount(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, accountVerificationRequest: AccountVerificationRequest, messageSignature?: string, region?: string, options?: any) {
        return VerificationApiFp(this.configuration).verifyAccount(contentType, clientRequestId, apiKey, timestamp, accountVerificationRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

    /**
     * Use this to perform card verification for a payment card. Use the account-verification endpoint instead for this request.
     * @summary Verify a payment card.
     * @param {'application/json'} contentType Content type.
     * @param {string} clientRequestId A client-generated ID for request tracking and signature creation, unique per request.  This is also used for idempotency control. We recommend 128-bit UUID format.
     * @param {string} apiKey Key given to merchant after boarding associating their requests with the appropriate app in Apigee.
     * @param {number} timestamp Epoch timestamp in milliseconds in the request from a client system. Used for Message Signature generation and time limit (5 mins).
     * @param {CardVerificationRequest} cardVerificationRequest Accepted request type: CardVerificationRequest.
     * @param {string} [messageSignature] Used to ensure the request has not been tampered with during transmission. The Message-Signature is the Base64 encoded HMAC hash (SHA256 algorithm with the API Secret as the key.) For more information, refer to the supporting documentation on the Developer Portal.
     * @param {string} [region] Indicates the region where the client wants the transaction to be processed. This will override the default processing region identified for the client. Available options are argentina, brazil, germany, india and northamerica. Region specific store setup and APIGEE boarding is required in order to use an alternate region for processing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verifyCard(contentType: 'application/json', clientRequestId: string, apiKey: string, timestamp: number, cardVerificationRequest: CardVerificationRequest, messageSignature?: string, region?: string, options?: any) {
        return VerificationApiFp(this.configuration).verifyCard(contentType, clientRequestId, apiKey, timestamp, cardVerificationRequest, messageSignature, region, options)(this.axios, this.basePath);
    }

}


